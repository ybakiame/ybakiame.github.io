<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on ybakiame Blog</title>
    <link>https://example.com/categories/java/</link>
    <description>Recent content in Java on ybakiame Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 19 Oct 2021 21:16:55 +0800</lastBuildDate><atom:link href="https://example.com/categories/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java中的Date和Mysql中的datetime</title>
      <link>https://example.com/p/java%E4%B8%AD%E7%9A%84date%E5%92%8Cmysql%E4%B8%AD%E7%9A%84datetime/</link>
      <pubDate>Tue, 19 Oct 2021 21:16:55 +0800</pubDate>
      
      <guid>https://example.com/p/java%E4%B8%AD%E7%9A%84date%E5%92%8Cmysql%E4%B8%AD%E7%9A%84datetime/</guid>
      <description>java中的date 1、java.sql.date   格式为``2016-02-01` 是针对SQL语句使用的，它只包含日期而没有时间部分 一般是在数据库的时间字段   2、java.util.date   格式为 Wed Oct 20 15:02:35 CST 2021 在除SQL语句外的情况下面使用 一般是日常日期字段   sqlDate和UtilDate 1、java.util.Date 是 java.sql.Date 的父类 2、相互转化 java.sql.Date sqlDate=new Java.sql.Date(); java.util.Date utilDate=new java.util.Date (sqlDate.getTime()); 3、继承关系  java.lang.Object -&amp;gt; java.util.Date -&amp;gt; java.sql.Date
 4、 使用环境   java.sql.Date主要是用于sql中！ java.util.Date一般的环境下都可以使用！    5、转化 SimpleDateFormat bartDateFormat = new SimpleDateFormat(&amp;#34;yyyy-MM-dd&amp;#34;); String dateStringToParse = &amp;#34;2007-7-12&amp;#34;; //utilDate to sqlDate  try { //使用符合格式的字符串构建一个utilDate  java.</description>
    </item>
    
    <item>
      <title>Filter和Listener</title>
      <link>https://example.com/p/filter%E5%92%8Clistener/</link>
      <pubDate>Tue, 11 May 2021 15:29:19 +0800</pubDate>
      
      <guid>https://example.com/p/filter%E5%92%8Clistener/</guid>
      <description>Filter和Listener FIlter 指过滤器  概念   生活中的过滤器:空气过滤器 净水器 web中的过滤器:当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能 过滤器的一些功能: 一般用于完整通用的操作：  比如登录验证 统一编码设置 敏感字符过滤     快速入门:
  步骤:
 定义一个类 实现Filter接口， 复写方法 配置拦截资源: 注解配置 @WebFilter(&amp;quot;/*&amp;quot;) web.xml配置    @WebFilter(&amp;#34;/*&amp;#34;) public class FilterDemo implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(&amp;#34;执行了filter&amp;#34;); chain.doFilter(request, response); } }     过滤器细节
  web.xml
  &amp;lt;filter&amp;gt; &amp;lt;filter-name&amp;gt;demo1&amp;lt;/filter-name&amp;gt; &amp;lt;filter-class&amp;gt;com.</description>
    </item>
    
    <item>
      <title>使用EL表达式</title>
      <link>https://example.com/p/%E4%BD%BF%E7%94%A8el%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Tue, 11 May 2021 15:29:19 +0800</pubDate>
      
      <guid>https://example.com/p/%E4%BD%BF%E7%94%A8el%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>EL（Expression Language） JSP表达式语言（EL）使得访问存储在JavaBean中的数据变得非常简单。JSP EL既可以用来创建算术表达式也可以用来创建逻辑表达式。在JSP EL表达式内可以使用整型数，浮点数，字符串，常量true、false，还有null。
一个简单的语法 ${expr} {expr} 其中，expr指的是表达式。在JSP EL中通用的操作符是 . 和 {} 。这两个操作符允许您通过内嵌的JSP对象访问各种各样的JavaBean属性。
&amp;lt;jsp:setProperty name=&amp;quot;box&amp;quot; property=&amp;quot;perimeter&amp;quot; name=&amp;quot;box&amp;quot; property=&amp;quot;perimeter&amp;quot; value=&amp;quot;${2*box.width+2*box.height}&amp;quot;/&amp;gt;value=&amp;quot;${2*box.width+2*box.height}&amp;quot;/&amp;gt; 当JSP编译器在属性中见到&amp;quot;${}&amp;ldquo;格式后，它会产生代码来计算这个表达式，并且产生一个替代品来代替表达式的值。
您也可以在标签的模板文本中使用表达式语言。比如jsp:text标签简单地将其主体中的文本插入到JSP输出中：
&amp;lt;jsp:text&amp;gt; &amp;lt;h1&amp;gt;Hello JSP!&amp;lt;/h1&amp;gt;&amp;lt;h1&amp;gt;Hello JSP!&amp;lt;/h1&amp;gt; &amp;lt;/jsp:text&amp;gt;&amp;lt;/jsp:text&amp;gt; 现在，在jsp:text标签主体中使用表达式，就像这样：
&amp;lt;jsp:text&amp;gt; Box Perimeter is: ${2*box.width + 2*box.height} &amp;lt;/jsp:text&amp;gt;&amp;lt;/jsp:text&amp;gt; 在EL表达式中可以使用圆括号来组织子表达式。比如${(1 + 2) * 3}等于9，但是${1 + (2 * 3)} 等于7。
想要停用对EL表达式的评估的话，需要使用page指令将isELIgnored属性值设为true：
&amp;lt;%@ page isELIgnored =&amp;quot;true|false&amp;quot; %&amp;gt; 这样，EL表达式就会被忽略。若设为false，则容器将会计算EL表达式。
 EL中的基础操作符 EL表达式支持大部分Java所提供的算术和逻辑操作符：
   操作符 描述     . 访问一个Bean属性或者一个映射条目   [] 访问一个数组或者链表的元素   ( ) 组织一个子表达式以改变优先级   + 加   - 减或负   * 乘   / or div 除   % or mod 取模   == or eq 测试是否相等   !</description>
    </item>
    
    <item>
      <title>数据库数据分页</title>
      <link>https://example.com/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E5%88%86%E9%A1%B5/</link>
      <pubDate>Tue, 11 May 2021 15:29:19 +0800</pubDate>
      
      <guid>https://example.com/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E5%88%86%E9%A1%B5/</guid>
      <description>数据库分页   在DAO中提供方法
  public List&amp;lt;Hero&amp;gt; list(int start, int count) start表示开始的个数，count表示取多少条 比如 list(0, 5) ， 即表示第一页，每页有5条数据 比如 list(5, 5) ， 即表示第二页，每页有5条数据   修改HeroListServlet
  int start = 0; int count = 5; List&amp;lt;Hero&amp;gt; heros = new HeroDAO().list(start, count);   下一页
HeroListServlet : 通过参数获取start，如果浏览器没有传递参数，就设置为0。 根据start，计算next. next的值就是start+count. 然后把next传递给listHero.jsp
listHero.jsp 在最后面增加一个超链
&amp;lt;a href=&amp;quot;?start=${next}&amp;quot;&amp;gt;[下一页]&amp;lt;/a&amp;gt;
start=${next} 从服务器传递过来的next值
  上一页
HeroListServlet: 根据start，计算pre. pre的值就是start-count. 然后把pre传递给listHero.jsp
listHero.jsp 在下一页前增加一个超链
&amp;lt;a href=&amp;quot;?start=${pre}&amp;quot;&amp;gt;[上一页]&amp;lt;/a&amp;gt;
start=${pre} 从服务器传递过来的pre值</description>
    </item>
    
  </channel>
</rss>
