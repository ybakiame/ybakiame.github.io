<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mysql on ybakiame的个人博客</title>
    <link>https://example.com/categories/mysql/</link>
    <description>Recent content in Mysql on ybakiame的个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 27 Sep 2021 20:01:36 +0800</lastBuildDate><atom:link href="https://example.com/categories/mysql/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Mysql事务</title>
      <link>https://example.com/p/mysql%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Mon, 27 Sep 2021 20:01:36 +0800</pubDate>
      
      <guid>https://example.com/p/mysql%E4%BA%8B%E5%8A%A1/</guid>
      <description>什么是事件？ 是MySQL5.1新增的事件也叫做定时任务，事件调度器,是一组SQL集，用来执行定时任务，跟触发器很像，都是被动执行的，事件由时间触发执行，而触发器是由事件（增删改）触发执行；
查看事件是否开启  SHOW VARIABLES LIKE &#39;event_scheduler&#39;;
开启事件:SET GLOBAL event_scheduler = ON/1; SET @@global.event_scheduler = ON/1;
关闭事件:SET GLOBAL event_scheduler = OFF/0; SET @@global.event_scheduler = OFF/0;
 查看事件  查看当前所在数据库的事件:
SHOW EVENTS; SHOW PROCESSLIST; 
查看数据库中所有的事件:
SELECT * FROM mysql.event;
 事件的控制  临时关闭/打开事件 ALTER EVENT 事件名 DISABLE/ENABLE; 删除事件 DROP EVENT 事件名;
 定时执行事件 DELIMITER$$/*创建定时事件*/CREATEEVENT`demo`.`comm`/*指定时间执行*/ONSCHEDULEAT&amp;#39;2021-09-27 16:34:00&amp;#39;/*完成时不保留启用 执行完成之后删除事件*/ONCOMPLETIONNOTPRESERVEENABLEDOBEGINUPDATE`commodity`SET`c_number`=1;END$$DELIMITER;循环执行事件 DELIMITER$$/*创建事件*/CREATEEVENT`demo`.`addmoeny`/*循环执行 间隔时间为1天*/ONSCHEDULEEVERY&amp;#39;1&amp;#39;DAY/*SECOND(秒)*//*循环的开始时间*/STARTS&amp;#39;2021-09-27 00:00:00&amp;#39;/*循环的结束时间*/ENDS&amp;#39;2022-04-29 00:00:00&amp;#39;/*完成时不保留启用*/ONCOMPLETIONNOTPRESERVEENABLE/*开始*/DOBEGINUPDATEmyuserSET`u_money`=`u_money`+10;/*结束*/END$$DELIMITER;</description>
    </item>
    
    <item>
      <title>Mysql主从数据库不同步问题</title>
      <link>https://example.com/p/mysql%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8D%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 27 Sep 2021 19:55:16 +0800</pubDate>
      
      <guid>https://example.com/p/mysql%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8D%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/</guid>
      <description>数据库主从异常问题不同步问题 数据库主从异常问题
场景描述：在使用web功能时发现刚添加的数据在列表中没有展示，或者有时候展示有时候不展示（多个从库时出现）
如何查找问题：  这时我们已经怀疑可能从库延迟了，我们需要确认下是延迟问题还是同步中断
我们需要链接到从库执行命令：
show slave status\G
来查看从库同步情况
 同步中断问题  如果Slave_IO_Running （负责与主机的io通信）
Slave_SQL_Running （负责自己的slave mysql进程）
这两个参数如果有一个是no的，说明同步已经中断了。
这时我们需要去看Last_Errno(错误码) Last_Error（错误信息），来确定什么原因导致的错误。
接下来我们可以通过以下命令跳过错误，让同步正常执行
/*停止同步*/stopslave/*设置跳过错误*/setglobalsql_slave_skip_counter=1;/*开始同步*/startslave 同步延迟问题  当我们发现Master_Log_File参数和Relay_Master_Log_File参数不一致或者Read_Master_Log_Pos和Relay_Log_Pos参数相差很大时，这表明从库延迟了
  这时我们先确认是主库导致的还是从库自身导致的，我们可以通过查看服务器负载来定位问题，使用命令top和iotop来分别查看cpu和io的使用情况
  定位到具体服务器后，在数据库中执行show full processlist来查看当前查询语句中执行时间较长的语句，定位后再做优化就可以了，有时可能慢sql已经执行完了，
  我们使用命令看不到慢sql，那我们就需要到mysql慢日志中去查看最近产生的慢日志，对慢sql进行优化
 </description>
    </item>
    
    <item>
      <title>Mysql主从数据库配置</title>
      <link>https://example.com/p/mysql%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Sun, 26 Sep 2021 21:02:53 +0800</pubDate>
      
      <guid>https://example.com/p/mysql%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE/</guid>
      <description>说明： 在项目部署到生产环境时，会有很多不可抗力的因素，数据库会出现崩溃停止运行数据丢失，数据对不上的问题，这个时候就需要两个数据库同步运行，来确保一个数据库崩溃另一个能马上顶上。
部署步骤： 在windows下部署: 配置文件位于mysql的安装目录下
在linux下部署: 配置文件位于/etc/my.cnf (不同linux发行版可能会有所不同)
配置主库    停止主库的mysql进程
net stop mysql1
  配置my.ini文件
#主数据库端ID号 server_id=1#开启二进制日志 log-bin=mysql-bin#需要复制的数据库名，如果复制多个数据库，重复设置这个选项即可(或者多个库用逗号隔开) #binlog-do-db = db #不需要复制的库，和上项同理 #binlog-ignore-db=mysql #将从服务器从主服务器收到的更新记入到从服务器自己的二进制日志文件中 #log-slave-updates #控制binlog的写入频率。每执行多少次事务写入一次(这个参数性能消耗很大，但可减小MySQL崩溃造成的损失) #sync_binlog = 1 #这个参数一般用在主主同步中，用来错开自增值, 防止键值冲突 #auto_increment_offset = 1 #这个参数一般用在主主同步中，用来错开自增值, 防止键值冲突 #auto_increment_increment = 1 #二进制日志自动删除的天数，默认值为0,表示“没有自动删除”，启动时和二进制日志循环时可能删除 #expire_logs_days = 7 #将函数复制到slave #log_bin_trust_function_creators = 1   保存修改后的配置，重启mysql服务
net start mysql
  登陆到主机的数据库，并建立一个用户给从库连接使用
允许所有ip连接GRANTREPLICATIONSLAVEON*.*TO&amp;#39;myslave&amp;#39;@&amp;#39;%&amp;#39;IDENTIFIEDBY&amp;#39;123456&amp;#39;;指定ip的做法GRANTREPLICATIONSLAVEON*.*TOmyslave@&amp;#39;192.168.41.0/255.255.255.0&amp;#39;IDENTIFIEDBY&amp;#39;123456&amp;#39;;  myslave是用户名
  123456密码是用户对应的密码
  192.168.41.0是ip地址
    更新数据库权限</description>
    </item>
    
    <item>
      <title>Mysql视图</title>
      <link>https://example.com/p/mysql%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Sun, 26 Sep 2021 20:56:53 +0800</pubDate>
      
      <guid>https://example.com/p/mysql%E8%A7%86%E5%9B%BE/</guid>
      <description>什么是视图？ mysql的视图的5.0.1版本之后开始提供的。 视图（View）是一种虚拟存在的表，并不在数据库中实际存在，视图中的数据会在使用视图时动态生成。
/*创建视图*/CREATE/*视图算法*//*[ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] 视图定义者 [DEFINER = { user | CURRENT_USER }] sql的安全性 [SQL SECURITY { DEFINER | INVOKER }]*//*数据库+视图名字*/VIEW`demo`.`statisticsview`AS/*要使用哪些数据生成视图*/(SELECTCOUNT(*)ASusers,SUM(`f_quota`)ASflowersFROM`user`,`flowers`WHERE`f_mapping_user`=`u_id`);查询视图 和普通的表查询一样，使用SELECT 即可</description>
    </item>
    
    <item>
      <title>Mysql事务</title>
      <link>https://example.com/p/mysql%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Thu, 23 Sep 2021 14:04:12 +0800</pubDate>
      
      <guid>https://example.com/p/mysql%E4%BA%8B%E5%8A%A1/</guid>
      <description>事务
  是什么是事务？ 事务就是一个完整的业务逻辑。
 举例： 假如张三向李四转账100元。
​	1）张三账户扣100元
​	2）李四的账户加100元
以上操作就是一个最小工作单元，要么同时成功要么同时失败，不可拆分。
   事务支持
 只有 INSERT DELETE UPDATE 以上三种语句和事务有关系。
   事务是如何实现同时成功或同时失败？
   &amp;gt; InnoDB存储引擎；提供一组用来记录事务性活动日志文件。 &amp;gt; &amp;gt; 提交事务： &amp;gt; &amp;gt; ​	清空事务性活动日志文件，并彻底把数据持久化到表中。 &amp;gt; &amp;gt; 回滚事务： &amp;gt; &amp;gt; ​	按文件进行回滚操作，并清空事务性活动日志文件。   如何提交事务，回滚事务？
 提交事务： COMMIT 语句
回滚事务： ROLLBACK 语句
关闭默认提交： START TRANSACTION
   事务包括4个特性
 A：原子性
​	说明事务是最小工作单元，不可再分。
C：一致性
​	所有任务要求，在同一事务当中，所有操作必须同时成功，同时失败。</description>
    </item>
    
    <item>
      <title>Mysql触发器</title>
      <link>https://example.com/p/mysql%E8%A7%A6%E5%8F%91%E5%99%A8/</link>
      <pubDate>Thu, 23 Sep 2021 13:31:02 +0800</pubDate>
      
      <guid>https://example.com/p/mysql%E8%A7%A6%E5%8F%91%E5%99%A8/</guid>
      <description>触发器的概念：
​	触发器是一种特殊的存储过程，不同于存储过程，触发器是通过事件触发执行，而不是手动调用执行的。 什么事触发事件？ 触发器（trigger），是指表中内容发生改变（增、删、改）时，系统会自动触发并执行的事件。 作用： 1、可以在触发时，校验或转换数据，保证数据安全。 2、触发器发生错误时，前面用户执行成功的操作会被回滚。 &amp;hellip;
表结构 CREATEDATABASEdemo;USE`demo`;CREATETABLE`user`(`u_id`BIGINT(18)NOTNULLAUTO_INCREMENTCOMMENT&amp;#39;用户id&amp;#39;,`u_name`VARCHAR(15)NOTNULLCOMMENT&amp;#39;用户名&amp;#39;,`u_sex`CHAR(1)NOTNULLDEFAULT&amp;#39;男&amp;#39;COMMENT&amp;#39;性别&amp;#39;,`u_createtime`DATETIMENOTNULLCOMMENT&amp;#39;创建时间&amp;#39;,`u_eff`INT(1)NOTNULLDEFAULT&amp;#39;1&amp;#39;COMMENT&amp;#39;有效&amp;#39;,PRIMARYKEY(`u_id`))CREATETABLE`flowers`(`f_id`BIGINT(18)NOTNULLAUTO_INCREMENTCOMMENT&amp;#39;花呗表id&amp;#39;,`f_credit_points`INT(4)NOTNULLCOMMENT&amp;#39;信用积分&amp;#39;,`f_quota`INT(5)NOTNULLCOMMENT&amp;#39;花呗额度&amp;#39;,`f_mapping_user`BIGINT(18)NOTNULLCOMMENT&amp;#39;用户id&amp;#39;,PRIMARYKEY(`f_id`))创建触发器 DELIMITER$$/*自定义结束符号*//*创建*/CREATE/*TRIGGER 触发器*//*库名+触发器名*//*BEFORE/AFTER 在sql之前执行还是之后执行*//*INSERT/UPDATE/DELETE触发条件*/TRIGGER`demo`.`userflowers`AFTERINSERT/*作用于哪个表*/ON`demo`.`user`/*每行都受影响，都执行，行级触发器*/FOREACHROWBEGIN/*触发执行的语句*/INSERTINTO`flowers`(`f_credit_points`,`f_quota`,`f_mapping_user`)VALUE(100,1000,new.u_id);END$$DELIMITER;执行语句 INSERTINTO`user`(`u_name`,`u_sex`,`u_createtime`)VALUE(&amp;#34;张三&amp;#34;,&amp;#34;女&amp;#34;,&amp;#34;2021-09-23 09:34:00&amp;#34;);1.   new和old的使用       INSERT 没有old只有new new表示将要插入或者已经插入的数据   UPDATE 既有old也有new old表示更新之前的数据 new表示更新之后的数据   DELETE 没有new只有old old表示删除前或已经被删除的数据    触发器条件使用if elseif else DELIMITER$$CREATETRIGGER`demo`.`userupdate`AFTERUPDATEON`demo`.`user`FOREACHROWBEGIN/*判断是否有效字段变为0*/IFnew.`u_eff`=0THEN/*删除花呗*/DELETEFROM`flowers`WHERE`f_mapping_user`=new.u_id;ELSEIFnew.`u_eff`=1THEN/*添加花呗*/INSERTINTO`flowers`(`f_credit_points`,`f_quota`,`f_mapping_user`)VALUE(100,1000,new.u_id);ELSE/*其它情况*/ENDIF;END$$DELIMITER;变量的使用 DELIMITER$$USE`demo`$$DROPTRIGGER/*!50032 IF EXISTS */`userflowers`$$CREATE/*!50017 DEFINER = &amp;#39;root&amp;#39;@&amp;#39;localhost&amp;#39; */TRIGGER`userflowers`AFTERINSERTON`user`FOREACHROWBEGIN/*触发执行的语句*/INSERTINTO`flowers`(`f_credit_points`,`f_quota`,`f_mapping_user`)VALUE(100,1000,new.u_id);/* 用户变量：以@开始，形式为 @变量名 用户变量只针对当前客户端生效 全局变量：定义方式 set GLOBAL 变量名，或者 set @@global.变量名 对所有客户端生效，但是具有super权限才可以设置全局变量 */SELECTCOUNT(*)FROMUSERINTO@num;UPDATE`statistics`SET`users`=@numWHEREs_id=1;END;$$DELIMITER;</description>
    </item>
    
  </channel>
</rss>
