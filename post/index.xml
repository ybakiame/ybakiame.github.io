<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on ybakiame的个人博客</title>
    <link>https://example.com/post/</link>
    <description>Recent content in Posts on ybakiame的个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 21 Oct 2021 21:51:22 +0800</lastBuildDate><atom:link href="https://example.com/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>springMVC实现restful风格</title>
      <link>https://example.com/p/springmvc%E5%AE%9E%E7%8E%B0restful%E9%A3%8E%E6%A0%BC/</link>
      <pubDate>Thu, 21 Oct 2021 21:51:22 +0800</pubDate>
      
      <guid>https://example.com/p/springmvc%E5%AE%9E%E7%8E%B0restful%E9%A3%8E%E6%A0%BC/</guid>
      <description>1、REST的概念 REST为“Representational State Transfer”的缩写，中文释义为“表现层状态转换”，REST不是一种标准，而是一种设计风格。是目前最流行的一种互联网软件架构风格。它倡导结构清晰、符合标准、易于理解、扩展方便的Web架构体系，主张严格按照HTTP协议中定义的规范设计结构严谨的Web应用架构体系。由于REST所倡导的理念让Web应用更易于开发和维护，更加优雅简洁，所以正得到越来越多网站的采用。
  资源（Resources）：网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的存在。可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的 URI 。要获取这个资源，访问它的URI就可以，因此 URI 即为每一个资源的独一无二的识别符。
  表现层（Representation）：把资源具体呈现出来的形式，叫做它的表现层（Representation）。比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式。
  状态转化
（State Transfer）：每发出一个请求，就代表了客户端和服务器的一次交互过程。HTTP协议，是一个无状态协议，即所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生“状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是 “表现层状态转化”。
具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：
 GET 用来获取资源 POST 用来新建资源 PUT 用来更新资源 DELETE 用来删除资源       HTTP方法名 使用场景 资源操作 是否幂等 是否安全     GET 从服务器取出资源（一项或多项） SELECT 是 是   POST 在服务器新建一个资源 INSERT 否 否   PUT 在服务器更新资源（客户端提供完整资源数据） UPDATE 是 否   DELETE 从服务器删除资源 DELETE 是 否     幂等性：对同一REST接口的多次访问，得到的资源状态是相同的。 安全性：对该REST接口访问，不会使服务器端资源的状态发生改变。   RESTful：就是符合REST原则的架构方式即可称为RESTful。</description>
    </item>
    
    <item>
      <title>SpringMvc静态资源过滤</title>
      <link>https://example.com/p/springmvc%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%BF%87%E6%BB%A4/</link>
      <pubDate>Thu, 21 Oct 2021 20:07:06 +0800</pubDate>
      
      <guid>https://example.com/p/springmvc%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%BF%87%E6%BB%A4/</guid>
      <description>配置DispatcherServlet 在进行Spring MVC的配置时，通常会配置一个dispatcher-servlet.xml用于处理对应的URL。web.xml中配置如下：
&amp;lt;!--springmvc默认拦截器拦截请求--&amp;gt; &amp;lt;servlet&amp;gt; &amp;lt;servlet-name&amp;gt;SpringMVC&amp;lt;/servlet-name&amp;gt; &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;classpath:dispatcher-servlet.xml&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;!--tomcat启动时立即初始化拦截器--&amp;gt; &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt; &amp;lt;/servlet&amp;gt; &amp;lt;servlet-mapping&amp;gt; &amp;lt;!-- url-pattern拦截地址的区别 / 会匹配url请求/index等 ,也会匹配静态资源*.js,*.html等, 不会匹配*.jsp文件。 /* 会匹配url请求/index等 ,也会匹配静态资源*.js,*.html等, 会匹配*.jsp文件。 在实际开发中可能遇到 *.do、*.cation 等拦截代后缀的请求 --&amp;gt; &amp;lt;servlet-name&amp;gt;SpringMVC&amp;lt;/servlet-name&amp;gt; &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt; &amp;lt;!-- 只拦截.do请求 &amp;lt;url-pattern&amp;gt;*.do&amp;lt;/url-pattern&amp;gt; --&amp;gt; &amp;lt;/servlet-mapping&amp;gt; 优雅 REST 风格的 URL 不希望带 .html 或 .do 等后缀，而如果将 DispatcherServlet 请求映射配置为&amp;quot;/&amp;quot;，则Spring MVC将捕获Web容器所有的请求，静态资源的请求找不到对应处理器将导致错误。
springMvc过滤静态资源文件 1、使用Tomcat的defaultServlet来处理静态文件 web.xml里添加如下的配置
&amp;lt;!--在springmvc拦截所有请求之前放行所有静态资源文件--&amp;gt; &amp;lt;!--每一个&amp;lt;url-pattern&amp;gt;代表一种静态资源文件--&amp;gt; &amp;lt;servlet-mapping&amp;gt; &amp;lt;servlet-name&amp;gt;default&amp;lt;/servlet-name&amp;gt; &amp;lt;url-pattern&amp;gt;*.html&amp;lt;/url-pattern&amp;gt; &amp;lt;url-pattern&amp;gt;*.css&amp;lt;/url-pattern&amp;gt; &amp;lt;url-pattern&amp;gt;*.js&amp;lt;/url-pattern&amp;gt; &amp;lt;url-pattern&amp;gt;*.ico&amp;lt;/url-pattern&amp;gt; &amp;lt;url-pattern&amp;gt;*.jpg&amp;lt;/url-pattern&amp;gt; &amp;lt;url-pattern&amp;gt;*.png&amp;lt;/url-pattern&amp;gt; &amp;lt;url-pattern&amp;gt;*.gif&amp;lt;/url-pattern&amp;gt; &amp;lt;/servlet-mapping&amp;gt;  要写在DispatcherServlet的前面， 让defaultServlet先拦截，这个就不会进入Spring了，我想性能是最好的吧。
 Tomcat, Jetty, JBoss, and GlassFish 默认 Servlet的名字 &amp;ndash; &amp;ldquo;default&amp;rdquo; Google App Engine 默认 Servlet的名字 &amp;ndash; &amp;ldquo;_ah_default&amp;rdquo; Resin 默认 Servlet的名字 &amp;ndash; &amp;ldquo;resin-file&amp;rdquo; WebLogic 默认 Servlet的名字 &amp;ndash; &amp;ldquo;FileServlet&amp;rdquo; WebSphere 默认 Servlet的名字 &amp;ndash; &amp;ldquo;SimpleFileServlet&amp;rdquo;   2、使用&amp;lt;mvc:resources&amp;gt;标签 在dispatcher-servlet.</description>
    </item>
    
    <item>
      <title>Java中的Date和Mysql中的datetime</title>
      <link>https://example.com/p/java%E4%B8%AD%E7%9A%84date%E5%92%8Cmysql%E4%B8%AD%E7%9A%84datetime/</link>
      <pubDate>Tue, 19 Oct 2021 21:16:55 +0800</pubDate>
      
      <guid>https://example.com/p/java%E4%B8%AD%E7%9A%84date%E5%92%8Cmysql%E4%B8%AD%E7%9A%84datetime/</guid>
      <description>java中的date 1、java.sql.date   格式为``2016-02-01` 是针对SQL语句使用的，它只包含日期而没有时间部分 一般是在数据库的时间字段   2、java.util.date   格式为 Wed Oct 20 15:02:35 CST 2021 在除SQL语句外的情况下面使用 一般是日常日期字段   sqlDate和UtilDate 1、java.util.Date 是 java.sql.Date 的父类 2、相互转化 java.sql.Date sqlDate=new Java.sql.Date(); java.util.Date utilDate=new java.util.Date (sqlDate.getTime()); 3、继承关系  java.lang.Object -&amp;gt; java.util.Date -&amp;gt; java.sql.Date
 4、 使用环境   java.sql.Date主要是用于sql中！ java.util.Date一般的环境下都可以使用！    5、转化 SimpleDateFormat bartDateFormat = new SimpleDateFormat(&amp;#34;yyyy-MM-dd&amp;#34;); String dateStringToParse = &amp;#34;2007-7-12&amp;#34;; //utilDate to sqlDate  try { //使用符合格式的字符串构建一个utilDate  java.</description>
    </item>
    
    <item>
      <title>Mybatis报错解决合集</title>
      <link>https://example.com/p/mybatis%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E5%90%88%E9%9B%86/</link>
      <pubDate>Tue, 19 Oct 2021 19:43:35 +0800</pubDate>
      
      <guid>https://example.com/p/mybatis%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E5%90%88%E9%9B%86/</guid>
      <description>根报错 Cause: com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure org.apache.ibatis.exceptions.PersistenceException: ### Error querying database. Cause: com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure The last packet successfully received from the server was 128 milliseconds ago. The last packet sent successfully to the server was 125 milliseconds ago. ### The error may exist in com/xxgc/mybatis/mapper/MoneyMapper.java (best guess) ### The error may involve com.xxgc.mybatis.mapper.MoneyMapper.selectMoneyAndUser_COUNT ### The error occurred while executing a query ### Cause: com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure The last packet successfully received from the server was 128 milliseconds ago.</description>
    </item>
    
    <item>
      <title>Jackson使用</title>
      <link>https://example.com/p/jackson%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 19 Oct 2021 14:48:39 +0800</pubDate>
      
      <guid>https://example.com/p/jackson%E4%BD%BF%E7%94%A8/</guid>
      <description>maven引入依赖 &amp;lt;!-- object to json Gson是Google所维护，功能全。 JackSon是Spring的御用工具，和Spring无缝集成，提供灵活的定制化开发的注解。 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jackson-databind&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.13.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; jackson-databind 依赖 jackson-core 和 jackson-annotations，可以只显示地添加jackson-databind依赖，jackson-core 和 jackson-annotations 也随之添加到 Java 项目工程中。
创建 ObjectMapper Jackson 最常用的 API 就是基于&amp;quot;对象绑定&amp;quot; 的 ObjectMapper：
 ObjectMapper可以从字符串，流或文件中解析JSON，并创建表示已解析的JSON的Java对象。 将JSON解析为Java对象也称为从JSON反序列化Java对象。 ObjectMapper也可以从Java对象创建JSON。 从Java对象生成JSON也称为将Java对象序列化为JSON。 Object映射器可以将JSON解析为自定义的类的对象，也可以解析置JSON树模型的对象。  之所以称为ObjectMapper是因为它将JSON映射到Java对象（反序列化），或者将Java对象映射到JSON（序列化）。
将 java Object转化为 json 字符串 ObjectMapper objectMapper = new ObjectMapper(); String json = objectMapper.writeValueAsString(要转化为json的对象); System.out.println(json);//打印转化后的json对象 参考</description>
    </item>
    
    <item>
      <title>Mysql索引</title>
      <link>https://example.com/p/mysql%E7%B4%A2%E5%BC%95/</link>
      <pubDate>Sat, 02 Oct 2021 11:39:05 +0800</pubDate>
      
      <guid>https://example.com/p/mysql%E7%B4%A2%E5%BC%95/</guid>
      <description>优点   索引大大减小了服务器需要扫描的数据量
  索引可以帮助服务器避免排序和临时表
  索引可以将随机IO变成顺序IO
  索引对于InnoDB（对索引支持行级锁）非常重要，因为它可以让查询锁更少的元组。在MySQL5.1和更新的版本中，InnoDB可以在服务器端过滤掉行后就释放锁，但在早期的MySQL版本中，InnoDB直到事务提交时才会解锁。对不需要的元组的加锁，会增加锁的开销，降低并发性。 InnoDB仅对需要访问的元组加锁，而索引能够减少InnoDB访问的元组数。但是只有在存储引擎层过滤掉那些不需要的数据才能达到这种目的。一旦索引不允许InnoDB那样做（即索引达不到过滤的目的），MySQL服务器只能对InnoDB返回的数据进行WHERE操作，此时，已经无法避免对那些元组加锁了。如果查询不能使用索引，MySQL会进行全表扫描，并锁住每一个元组，不管是否真正需要。
关于InnoDB、索引和锁：InnoDB在二级索引上使用共享锁（读锁），但访问主键索引需要排他锁（写锁）
  缺点  虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存索引文件。 建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。 如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。 对于非常小的表，大部分情况下简单的全表扫描更高效；  索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句。因此应该只为最经常查询和最经常排序的数据列建立索引。
MySQL里同一个数据表里的索引总数限制为16个。
索引的分类 在一个表中，主键索引只能有一个，唯一索引可以有多个。
 主键索引（PRIMARY KEY）  唯一的标识，主键不可重复，只能有一个列作为主键   唯一索引（UNIQUE KEY）  避免重读的列出现，唯一索引可以重复，多个列都可以标识为唯一索引   常规索引（KEY / INDEX）  默认的，通过index或key关键字来设置   全文索引（FULLTEXT）  在特定的数据库引擎下采用，之前只有MYISAM有 快速定位数据    基础语法
-- 索引的使用 -- 方式1：在创建表的时候给字段增加索引 -- 方式2：表创建完毕后，增加索引 -- 显示所有的索引信息 SHOWINDEXFROM`student`-- 增加一个全文索引：格式：索引类型 索引名（列名），主键索引只要有索引名就行了 ALTERTABLE`school`.`student`ADDFULLTEXTINDEX`StudentName`(`StudentName`)-- 删除索引 DROPINDEX索引名ON表名-- EXPLAIN分析sql执行的情况 EXPLAINSELECT*FROM`student`;-- 非全文索引 EXPLAINSELECT*FROM`student`WHEREMATCH(`StudentName`)AGAINST(&amp;#39;郭&amp;#39;)-- 通过全文索引进行查找 创建表结构 CREATETABLE`demo`.</description>
    </item>
    
    <item>
      <title>Mysql存储过程</title>
      <link>https://example.com/p/mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Wed, 29 Sep 2021 17:06:44 +0800</pubDate>
      
      <guid>https://example.com/p/mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</guid>
      <description>什么是存储过程 是一种在数据库中存储复杂程序，以便外部调用的一种数据库对象 存储过程思想上很简单，就是数据库SQL语言层面的代码封装与重用。
优点  可封装，并隐藏复杂的商业逻辑。 并可以接受参数，可以有返回值。 存储过程无法使用 SELECT 指令来运行，因为它是子程序，与查看表，数据表或用户定义函数不同。 存储过程可以用在数据检验，强制实行商业逻辑等。  缺点  存储过程，往往定制化于特定的数据库上，因为支持的编程语言不同。当切换到其他厂商的数据库系统时，需要重写原有的存储过程。 存储过程的性能调校与撰写，受限于各种数据库系统。  声明一个存储过程 DELIMITER$$CREATE-- 声明一个储存过程 PROCEDURE 库名.函数名(参数) -- in：这个参数是一个传入值 -- out：这个参数是个返回值 -- outin：表示这个参数既是输入值，也是返回值（使用时需要传入的是变量，而不是一个确切的数值） PROCEDURE`demo`.</description>
    </item>
    
    <item>
      <title>Mysql函数</title>
      <link>https://example.com/p/mysql%E5%87%BD%E6%95%B0/</link>
      <pubDate>Tue, 28 Sep 2021 23:11:13 +0800</pubDate>
      
      <guid>https://example.com/p/mysql%E5%87%BD%E6%95%B0/</guid>
      <description>什么是函数？ 函数类似于Java方法，可以传值，也有返回值，配合查询做一些复杂计算。
创建一个自定义函数 DELIMITER$$CREATE/*函数 库+函数名(参数名 类型)*/FUNCTION`demo`.`usermoney`(numberINT)/*返回值类型(varchar类型需要指定长度)*/RETURNSINT/*开始*/BEGIN/*返回 要执行的sql语句*/RETURN(number*100);/*结束*/END$$DELIMITER;函数的使用 select之后接函数名(参数)，与mysql内置函数使用方法一致
SELECTusermoney(`u_money`)FROM`users`在函数中创建变量 变量的声明需要放在要执行的sql语句的头部
/*创建一个变量 使用 DECLARE 关键字*/DECLAREnewmenberVARCHAR(30)DEFAULT&amp;#34;普通用户&amp;#34;;mysql内置常用函数 MySQL 数值型函数    函数名称 作 用     ABS 求绝对值   SQRT 求二次方根   MOD 求余数   CEIL 和 CEILING 两个函数功能相同，都是返回不小于参数的最小整数，即向上取整   FLOOR 向下取整，返回值转化为一个BIGINT   RAND 生成一个0~1之间的随机数，传入整数参数是，用来产生重复序列   ROUND 对所传参数进行四舍五入   SIGN 返回参数的符号   POW 和 POWER 两个函数的功能相同，都是所传参数的次方的结果值   SIN 求正弦值   ASIN 求反正弦值，与函数 SIN 互为反函数   COS 求余弦值   ACOS 求反余弦值，与函数 COS 互为反函数   TAN 求正切值   ATAN 求反正切值，与函数 TAN 互为反函数   COT 求余切值    MySQL 字符串函数    函数名称 作 用     LENGTH 计算字符串长度函数，返回字符串的字节长度   CONCAT 合并字符串函数，返回结果为连接参数产生的字符串，参数可以使一个或多个   INSERT 替换字符串函数   LOWER 将字符串中的字母转换为小写   UPPER 将字符串中的字母转换为大写   LEFT 从左侧字截取符串，返回字符串左边的若干个字符   RIGHT 从右侧字截取符串，返回字符串右边的若干个字符   TRIM 删除字符串左右两侧的空格   REPLACE 字符串替换函数，返回替换后的新字符串   SUBSTRING 截取字符串，返回从指定位置开始的指定长度的字符换   REVERSE 字符串反转（逆序）函数，返回与原始字符串顺序相反的字符串    MySQL 日期和时间函数    函数名称 作 用     CURDATE 和 CURRENT_DATE 两个函数作用相同，返回当前系统的日期值   CURTIME 和 CURRENT_TIME 两个函数作用相同，返回当前系统的时间值   NOW 和 SYSDATE 两个函数作用相同，返回当前系统的日期和时间值   UNIX_TIMESTAMP 获取UNIX时间戳函数，返回一个以 UNIX 时间戳为基础的无符号整数   FROM_UNIXTIME 将 UNIX 时间戳转换为时间格式，与UNIX_TIMESTAMP互为反函数   MONTH 获取指定日期中的月份   MONTHNAME 获取指定日期中的月份英文名称   DAYNAME 获取指定曰期对应的星期几的英文名称   DAYOFWEEK 获取指定日期对应的一周的索引位置值   WEEK 获取指定日期是一年中的第几周，返回值的范围是否为 0〜52 或 1〜53   DAYOFYEAR 获取指定曰期是一年中的第几天，返回值范围是1~366   DAYOFMONTH 获取指定日期是一个月中是第几天，返回值范围是1~31   YEAR 获取年份，返回值范围是 1970〜2069   TIME_TO_SEC 将时间参数转换为秒数   SEC_TO_TIME 将秒数转换为时间，与TIME_TO_SEC 互为反函数   DATE_ADD 和 ADDDATE 两个函数功能相同，都是向日期添加指定的时间间隔   DATE_SUB 和 SUBDATE 两个函数功能相同，都是向日期减去指定的时间间隔   ADDTIME 时间加法运算，在原始时间上添加指定的时间   SUBTIME 时间减法运算，在原始时间上减去指定的时间   DATEDIFF 获取两个日期之间间隔，返回参数 1 减去参数 2 的值   DATE_FORMAT 格式化指定的日期，根据参数返回指定格式的值   WEEKDAY 获取指定日期在一周内的对应的工作日索引    MySQL 聚合函数    函数名称 作用     MAX 查询指定列的最大值   MIN 查询指定列的最小值   COUNT 统计查询结果的行数   SUM 求和，返回指定列的总和   AVG 求平均值，返回指定列数据的平均值    MySQL 流程控制函数    函数名称 作用     IF 判断，流程控制   IFNULL 判断是否为空   CASE 搜索语句    </description>
    </item>
    
    <item>
      <title>Mysql事件</title>
      <link>https://example.com/p/mysql%E4%BA%8B%E4%BB%B6/</link>
      <pubDate>Mon, 27 Sep 2021 20:01:36 +0800</pubDate>
      
      <guid>https://example.com/p/mysql%E4%BA%8B%E4%BB%B6/</guid>
      <description>什么是事件？ 是MySQL5.1新增的事件也叫做定时任务，事件调度器,是一组SQL集，用来执行定时任务，跟触发器很像，都是被动执行的，事件由时间触发执行，而触发器是由事件（增删改）触发执行；
查看事件是否开启  SHOW VARIABLES LIKE &#39;event_scheduler&#39;;
开启事件:SET GLOBAL event_scheduler = ON/1; SET @@global.event_scheduler = ON/1;
关闭事件:SET GLOBAL event_scheduler = OFF/0; SET @@global.event_scheduler = OFF/0;
 查看事件  查看当前所在数据库的事件:
SHOW EVENTS; SHOW PROCESSLIST; 
查看数据库中所有的事件:
SELECT * FROM mysql.event;
 事件的控制  临时关闭/打开事件 ALTER EVENT 事件名 DISABLE/ENABLE; 删除事件 DROP EVENT 事件名;
 定时执行事件 DELIMITER$$/*创建定时事件*/CREATEEVENT`demo`.`comm`/*指定时间执行*/ONSCHEDULEAT&amp;#39;2021-09-27 16:34:00&amp;#39;/*完成时不保留启用 执行完成之后删除事件*/ONCOMPLETIONNOTPRESERVEENABLEDOBEGINUPDATE`commodity`SET`c_number`=1;END$$DELIMITER;循环执行事件 DELIMITER$$/*创建事件*/CREATEEVENT`demo`.`addmoeny`/*循环执行 间隔时间为1天*/ONSCHEDULEEVERY&amp;#39;1&amp;#39;DAY/*SECOND(秒)*//*循环的开始时间*/STARTS&amp;#39;2021-09-27 00:00:00&amp;#39;/*循环的结束时间*/ENDS&amp;#39;2022-04-29 00:00:00&amp;#39;/*完成时不保留启用*/ONCOMPLETIONNOTPRESERVEENABLE/*开始*/DOBEGINUPDATEmyuserSET`u_money`=`u_money`+10;/*结束*/END$$DELIMITER;</description>
    </item>
    
    <item>
      <title>Mysql主从数据库不同步问题</title>
      <link>https://example.com/p/mysql%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8D%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 27 Sep 2021 19:55:16 +0800</pubDate>
      
      <guid>https://example.com/p/mysql%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8D%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/</guid>
      <description>数据库主从异常问题不同步问题 数据库主从异常问题
场景描述：在使用web功能时发现刚添加的数据在列表中没有展示，或者有时候展示有时候不展示（多个从库时出现）
如何查找问题：  这时我们已经怀疑可能从库延迟了，我们需要确认下是延迟问题还是同步中断
我们需要链接到从库执行命令：
show slave status\G
来查看从库同步情况
 同步中断问题  如果Slave_IO_Running （负责与主机的io通信）
Slave_SQL_Running （负责自己的slave mysql进程）
这两个参数如果有一个是no的，说明同步已经中断了。
这时我们需要去看Last_Errno(错误码) Last_Error（错误信息），来确定什么原因导致的错误。
接下来我们可以通过以下命令跳过错误，让同步正常执行
/*停止同步*/stopslave/*设置跳过错误*/setglobalsql_slave_skip_counter=1;/*开始同步*/startslave 同步延迟问题  当我们发现Master_Log_File参数和Relay_Master_Log_File参数不一致或者Read_Master_Log_Pos和Relay_Log_Pos参数相差很大时，这表明从库延迟了
  这时我们先确认是主库导致的还是从库自身导致的，我们可以通过查看服务器负载来定位问题，使用命令top和iotop来分别查看cpu和io的使用情况
  定位到具体服务器后，在数据库中执行show full processlist来查看当前查询语句中执行时间较长的语句，定位后再做优化就可以了，有时可能慢sql已经执行完了，
  我们使用命令看不到慢sql，那我们就需要到mysql慢日志中去查看最近产生的慢日志，对慢sql进行优化
 </description>
    </item>
    
    <item>
      <title>Mysql主从数据库配置</title>
      <link>https://example.com/p/mysql%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Sun, 26 Sep 2021 21:02:53 +0800</pubDate>
      
      <guid>https://example.com/p/mysql%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE/</guid>
      <description>说明： 在项目部署到生产环境时，会有很多不可抗力的因素，数据库会出现崩溃停止运行数据丢失，数据对不上的问题，这个时候就需要两个数据库同步运行，来确保一个数据库崩溃另一个能马上顶上。
部署步骤： 在windows下部署: 配置文件位于mysql的安装目录下
在linux下部署: 配置文件位于/etc/my.cnf (不同linux发行版可能会有所不同)
配置主库    停止主库的mysql进程
net stop mysql1
  配置my.ini文件
#主数据库端ID号 server_id=1#开启二进制日志 log-bin=mysql-bin#需要复制的数据库名，如果复制多个数据库，重复设置这个选项即可(或者多个库用逗号隔开) #binlog-do-db = db #不需要复制的库，和上项同理 #binlog-ignore-db=mysql #将从服务器从主服务器收到的更新记入到从服务器自己的二进制日志文件中 #log-slave-updates #控制binlog的写入频率。每执行多少次事务写入一次(这个参数性能消耗很大，但可减小MySQL崩溃造成的损失) #sync_binlog = 1 #这个参数一般用在主主同步中，用来错开自增值, 防止键值冲突 #auto_increment_offset = 1 #这个参数一般用在主主同步中，用来错开自增值, 防止键值冲突 #auto_increment_increment = 1 #二进制日志自动删除的天数，默认值为0,表示“没有自动删除”，启动时和二进制日志循环时可能删除 #expire_logs_days = 7 #将函数复制到slave #log_bin_trust_function_creators = 1   保存修改后的配置，重启mysql服务
net start mysql
  登陆到主机的数据库，并建立一个用户给从库连接使用
允许所有ip连接GRANTREPLICATIONSLAVEON*.*TO&amp;#39;myslave&amp;#39;@&amp;#39;%&amp;#39;IDENTIFIEDBY&amp;#39;123456&amp;#39;;指定ip的做法GRANTREPLICATIONSLAVEON*.*TOmyslave@&amp;#39;192.168.41.0/255.255.255.0&amp;#39;IDENTIFIEDBY&amp;#39;123456&amp;#39;;  myslave是用户名
  123456密码是用户对应的密码
  192.168.41.0是ip地址
    更新数据库权限</description>
    </item>
    
    <item>
      <title>Mysql视图</title>
      <link>https://example.com/p/mysql%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Sun, 26 Sep 2021 20:56:53 +0800</pubDate>
      
      <guid>https://example.com/p/mysql%E8%A7%86%E5%9B%BE/</guid>
      <description>什么是视图？ mysql的视图的5.0.1版本之后开始提供的。 视图（View）是一种虚拟存在的表，并不在数据库中实际存在，视图中的数据会在使用视图时动态生成。
/*创建视图*/CREATE/*视图算法*//*[ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] 视图定义者 [DEFINER = { user | CURRENT_USER }] sql的安全性 [SQL SECURITY { DEFINER | INVOKER }]*//*数据库+视图名字*/VIEW`demo`.`statisticsview`AS/*要使用哪些数据生成视图*/(SELECTCOUNT(*)ASusers,SUM(`f_quota`)ASflowersFROM`user`,`flowers`WHERE`f_mapping_user`=`u_id`);查询视图 和普通的表查询一样，使用SELECT 即可</description>
    </item>
    
    <item>
      <title>Mysql事务</title>
      <link>https://example.com/p/mysql%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Thu, 23 Sep 2021 14:04:12 +0800</pubDate>
      
      <guid>https://example.com/p/mysql%E4%BA%8B%E5%8A%A1/</guid>
      <description>事务
  是什么是事务？ 事务就是一个完整的业务逻辑。
 举例： 假如张三向李四转账100元。
​	1）张三账户扣100元
​	2）李四的账户加100元
以上操作就是一个最小工作单元，要么同时成功要么同时失败，不可拆分。
   事务支持
 只有 INSERT DELETE UPDATE 以上三种语句和事务有关系。
   事务是如何实现同时成功或同时失败？
   &amp;gt; InnoDB存储引擎；提供一组用来记录事务性活动日志文件。 &amp;gt; &amp;gt; 提交事务： &amp;gt; &amp;gt; ​	清空事务性活动日志文件，并彻底把数据持久化到表中。 &amp;gt; &amp;gt; 回滚事务： &amp;gt; &amp;gt; ​	按文件进行回滚操作，并清空事务性活动日志文件。   如何提交事务，回滚事务？
 提交事务： COMMIT 语句
回滚事务： ROLLBACK 语句
关闭默认提交： START TRANSACTION
   事务包括4个特性
 A：原子性
​	说明事务是最小工作单元，不可再分。
C：一致性
​	所有任务要求，在同一事务当中，所有操作必须同时成功，同时失败。</description>
    </item>
    
    <item>
      <title>Mysql触发器</title>
      <link>https://example.com/p/mysql%E8%A7%A6%E5%8F%91%E5%99%A8/</link>
      <pubDate>Thu, 23 Sep 2021 13:31:02 +0800</pubDate>
      
      <guid>https://example.com/p/mysql%E8%A7%A6%E5%8F%91%E5%99%A8/</guid>
      <description>触发器的概念：
​	触发器是一种特殊的存储过程，不同于存储过程，触发器是通过事件触发执行，而不是手动调用执行的。 什么事触发事件？ 触发器（trigger），是指表中内容发生改变（增、删、改）时，系统会自动触发并执行的事件。 作用： 1、可以在触发时，校验或转换数据，保证数据安全。 2、触发器发生错误时，前面用户执行成功的操作会被回滚。 &amp;hellip;
表结构 CREATEDATABASEdemo;USE`demo`;CREATETABLE`user`(`u_id`BIGINT(18)NOTNULLAUTO_INCREMENTCOMMENT&amp;#39;用户id&amp;#39;,`u_name`VARCHAR(15)NOTNULLCOMMENT&amp;#39;用户名&amp;#39;,`u_sex`CHAR(1)NOTNULLDEFAULT&amp;#39;男&amp;#39;COMMENT&amp;#39;性别&amp;#39;,`u_createtime`DATETIMENOTNULLCOMMENT&amp;#39;创建时间&amp;#39;,`u_eff`INT(1)NOTNULLDEFAULT&amp;#39;1&amp;#39;COMMENT&amp;#39;有效&amp;#39;,PRIMARYKEY(`u_id`))CREATETABLE`flowers`(`f_id`BIGINT(18)NOTNULLAUTO_INCREMENTCOMMENT&amp;#39;花呗表id&amp;#39;,`f_credit_points`INT(4)NOTNULLCOMMENT&amp;#39;信用积分&amp;#39;,`f_quota`INT(5)NOTNULLCOMMENT&amp;#39;花呗额度&amp;#39;,`f_mapping_user`BIGINT(18)NOTNULLCOMMENT&amp;#39;用户id&amp;#39;,PRIMARYKEY(`f_id`))创建触发器 DELIMITER$$/*自定义结束符号*//*创建*/CREATE/*TRIGGER 触发器*//*库名+触发器名*//*BEFORE/AFTER 在sql之前执行还是之后执行*//*INSERT/UPDATE/DELETE触发条件*/TRIGGER`demo`.`userflowers`AFTERINSERT/*作用于哪个表*/ON`demo`.`user`/*每行都受影响，都执行，行级触发器*/FOREACHROWBEGIN/*触发执行的语句*/INSERTINTO`flowers`(`f_credit_points`,`f_quota`,`f_mapping_user`)VALUE(100,1000,new.u_id);END$$DELIMITER;执行语句 INSERTINTO`user`(`u_name`,`u_sex`,`u_createtime`)VALUE(&amp;#34;张三&amp;#34;,&amp;#34;女&amp;#34;,&amp;#34;2021-09-23 09:34:00&amp;#34;);1.   new和old的使用       INSERT 没有old只有new new表示将要插入或者已经插入的数据   UPDATE 既有old也有new old表示更新之前的数据 new表示更新之后的数据   DELETE 没有new只有old old表示删除前或已经被删除的数据    触发器条件使用if elseif else DELIMITER$$CREATETRIGGER`demo`.`userupdate`AFTERUPDATEON`demo`.`user`FOREACHROWBEGIN/*判断是否有效字段变为0*/IFnew.`u_eff`=0THEN/*删除花呗*/DELETEFROM`flowers`WHERE`f_mapping_user`=new.u_id;ELSEIFnew.`u_eff`=1THEN/*添加花呗*/INSERTINTO`flowers`(`f_credit_points`,`f_quota`,`f_mapping_user`)VALUE(100,1000,new.u_id);ELSE/*其它情况*/ENDIF;END$$DELIMITER;变量的使用 DELIMITER$$USE`demo`$$DROPTRIGGER/*!50032 IF EXISTS */`userflowers`$$CREATE/*!50017 DEFINER = &amp;#39;root&amp;#39;@&amp;#39;localhost&amp;#39; */TRIGGER`userflowers`AFTERINSERTON`user`FOREACHROWBEGIN/*触发执行的语句*/INSERTINTO`flowers`(`f_credit_points`,`f_quota`,`f_mapping_user`)VALUE(100,1000,new.u_id);/* 用户变量：以@开始，形式为 @变量名 用户变量只针对当前客户端生效 全局变量：定义方式 set GLOBAL 变量名，或者 set @@global.变量名 对所有客户端生效，但是具有super权限才可以设置全局变量 */SELECTCOUNT(*)FROMUSERINTO@num;UPDATE`statistics`SET`users`=@numWHEREs_id=1;END;$$DELIMITER;</description>
    </item>
    
    <item>
      <title>Spring07 AOP使用</title>
      <link>https://example.com/p/spring07-aop%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sat, 11 Sep 2021 17:48:58 +0800</pubDate>
      
      <guid>https://example.com/p/spring07-aop%E4%BD%BF%E7%94%A8/</guid>
      <description>AOP  什么是AOP  AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。
 Aop在Spring中的作用  提供声明式事务；允许用户自定义切面
以下名词需要了解下：
 横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 &amp;hellip;. 切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。 通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。 目标（Target）：被通知对象。 代理（Proxy）：向目标对象应用通知之后创建的对象。 切入点（PointCut）：切面通知 执行的 “地点”的定义。 连接点（JointPoint）：与切入点匹配的执行点。  SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice:
 前置增强 BeforeAdvice 代表前置增强，因为spring只支持方法级的增强，所以MethodBeforeAdvice 是目前可用前置增强，表示在目标方法执行前实施增强。 后置增强 AfterAdvice 代表后增强，表示目标方法在执行后实施增强 环绕增强 MethodInterceptor 代表环绕增强，表示目标方法执行前后实施增强 异常抛出增强 ThrowsAdvice 代表抛出异常增强，表示目标方法抛出异常后实施增强 引介增强 IntroductionInterceptor 代表引介增强，表示在目标类中添加一些新的方法和属性  即 Aop 在 不改变原有代码的情况下 , 去增加新的功能 .
 使用Spring实现Aop  【重点】使用AOP织入，需要导入一个依赖包！
&amp;lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.aspectj&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;aspectjweaver&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.9.4&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 第一种方式</description>
    </item>
    
    <item>
      <title>Spring06 动/静态代理</title>
      <link>https://example.com/p/spring06-%E5%8A%A8/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/</link>
      <pubDate>Sat, 11 Sep 2021 17:48:54 +0800</pubDate>
      
      <guid>https://example.com/p/spring06-%E5%8A%A8/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/</guid>
      <description>代理模式 为什么要学习代理模式，因为AOP的底层机制就是动态代理！
代理模式：
 静态代理 动态代理   静态代理  静态代理角色分析
  抽象角色 : 一般使用接口或者抽象类来实现
  真实角色 : 被代理的角色
  代理角色 : 代理真实角色 ; 代理真实角色后 , 一般会做一些附属的操作 .
  客户 : 使用代理角色来进行一些操作 .
  代码实现
Rent . java 即抽象角色
//抽象角色：租房 public interface Rent { public void rent(); } Host . java 即真实角色
//真实角色: 房东，房东要出租房子 public class Host implements Rent{ public void rent() { System.out.println(&amp;#34;房屋出租&amp;#34;); } } Proxy .</description>
    </item>
    
    <item>
      <title>Spring05 使用注解开发</title>
      <link>https://example.com/p/spring05-%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/</link>
      <pubDate>Sat, 11 Sep 2021 17:48:51 +0800</pubDate>
      
      <guid>https://example.com/p/spring05-%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/</guid>
      <description>使用注解开发  说明  在spring4之后，想要使用注解形式，必须得要引入aop的包
`spring-aop
在配置文件当中，还得要引入一个context约束
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:context=&amp;#34;http://www.springframework.org/schema/context&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&amp;#34;&amp;gt; &amp;lt;/beans&amp;gt;  Bean的实现  我们之前都是使用 bean 的标签进行bean注入，但是实际开发中，我们一般都会使用注解！
1、配置扫描哪些包下的注解
&amp;lt;!--指定注解扫描包--&amp;gt; &amp;lt;context:component-scan base-package=&amp;#34;com.kuang.pojo&amp;#34;/&amp;gt; 2、在指定包下编写类，增加注解
@Component(&amp;#34;user&amp;#34;) // 相当于配置文件中 &amp;lt;bean id=&amp;#34;user&amp;#34; class=&amp;#34;当前注解的类&amp;#34;/&amp;gt; public class User { public String name = &amp;#34;秦疆&amp;#34;; } 3、测试
@Test public void test(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&amp;#34;beans.xml&amp;#34;); User user = (User) applicationContext.getBean(&amp;#34;user&amp;#34;); System.out.println(user.name); }  属性注入  使用注解注入属性
1、可以不用提供set方法，直接在直接名上添加@value(&amp;ldquo;值&amp;rdquo;)
@Component(&amp;#34;user&amp;#34;) // 相当于配置文件中 &amp;lt;bean id=&amp;#34;user&amp;#34; class=&amp;#34;当前注解的类&amp;#34;/&amp;gt; public class User { @Value(&amp;#34;秦疆&amp;#34;) // 相当于配置文件中 &amp;lt;property name=&amp;#34;name&amp;#34; value=&amp;#34;秦疆&amp;#34;/&amp;gt;  public String name; } 2、如果提供了set方法，在set方法上添加@value(&amp;ldquo;值&amp;rdquo;);</description>
    </item>
    
    <item>
      <title>Spring04 自动装配</title>
      <link>https://example.com/p/spring04-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</link>
      <pubDate>Sat, 11 Sep 2021 17:48:33 +0800</pubDate>
      
      <guid>https://example.com/p/spring04-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</guid>
      <description>Bean的自动装配  自动装配说明   自动装配是使用spring满足bean依赖的一种方法 spring会在应用上下文中为某个bean寻找其依赖的bean。  Spring中bean有三种装配机制，分别是：
 在xml中显式配置； 在java中显式配置； 隐式的bean发现机制和自动装配。  这里我们主要讲第三种：自动化的装配bean。
Spring的自动装配需要从两个角度来实现，或者说是两个操作：
 组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean； 自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC/DI；  组件扫描和自动装配组合发挥巨大威力，使得显示的配置降低到最少。
**不推荐使用xml配置 , 而使用注解 **
 测试环境搭建  1、新建一个项目
2、新建两个实体类，Cat Dog 都有一个叫的方法
public class Cat { public void shout() { System.out.println(&amp;#34;miao~&amp;#34;); } } public class Dog { public void shout() { System.out.println(&amp;#34;wang~&amp;#34;); } } 3、新建一个用户类 User
public class User { private Cat cat; private Dog dog; private String str; } 4、编写Spring配置文件</description>
    </item>
    
    <item>
      <title>Spring03 依赖注入(DI)</title>
      <link>https://example.com/p/spring03-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5di/</link>
      <pubDate>Sat, 11 Sep 2021 17:41:44 +0800</pubDate>
      
      <guid>https://example.com/p/spring03-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5di/</guid>
      <description>Dependency Injection  概念   依赖注入（Dependency Injection,DI）。 依赖 : 指Bean对象的创建依赖于容器 . Bean对象的依赖资源 . 注入 : 指Bean对象所依赖的资源 , 由容器来设置和装配 .   构造器注入  我们在之前的案例已经讲过了
 Set 注入 （重点）  要求被注入的属性 , 必须有set方法 , set方法的方法名由set + 属性首字母大写 , 如果属性是boolean类型 , 没有set方法 , 是 is .
测试pojo类 :
Address.java
public class Address { private String address; public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } } Student.</description>
    </item>
    
    <item>
      <title>Spring02 快速上手</title>
      <link>https://example.com/p/spring02-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</link>
      <pubDate>Sat, 11 Sep 2021 17:23:33 +0800</pubDate>
      
      <guid>https://example.com/p/spring02-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</guid>
      <description>HelloSpring  导入Jar包  注 : spring 需要导入commons-logging进行日志记录 . 我们利用maven , 他会自动下载对应的依赖项 .
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.1.10.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;  编写代码  1、编写一个Hello实体类
public class Hello { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } public void show(){ System.out.println(&amp;#34;Hello,&amp;#34;+ name ); } } 2、编写我们的spring文件 , 这里我们命名为beans.xml
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&amp;#34;&amp;gt; &amp;lt;!--bean就是java对象 , 由Spring创建和管理--&amp;gt; &amp;lt;bean id=&amp;#34;hello&amp;#34; class=&amp;#34;com.kuang.pojo.Hello&amp;#34;&amp;gt; &amp;lt;property name=&amp;#34;name&amp;#34; value=&amp;#34;Spring&amp;#34;/&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;/beans&amp;gt; 3、我们可以去进行测试了 .</description>
    </item>
    
    <item>
      <title>记一次 Hugo 安装</title>
      <link>https://example.com/p/%E8%AE%B0%E4%B8%80%E6%AC%A1-hugo-%E5%AE%89%E8%A3%85/</link>
      <pubDate>Fri, 10 Sep 2021 13:37:10 +0800</pubDate>
      
      <guid>https://example.com/p/%E8%AE%B0%E4%B8%80%E6%AC%A1-hugo-%E5%AE%89%E8%A3%85/</guid>
      <description>Hugo 简介 Hugo是由Steve Francis基于Go语言开发的静态网站构建工具。
为什么选择Hexo  编译文章生成速度快 Hugo的官方文档写的非常好，部署简洁。 前两者部署时需要安装很多依赖，而hugo可以直接提供二进制文件运行，甚至不需要root权限。 颜值相对较高  安装 官方安装教程(推荐)
Mac安装   安装 brew
ruby -e &amp;#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;#34;   运行brew命令进行安装hugo
brew install hugo 如果 Homebrew 工作正常，您应该会看到类似于以下内容的内容：
==&amp;gt; Downloading https://homebrew.bintray.com/bottles/hugo-0.21.sierra.bottle.tar.gz ######################################################################### 100.0% ==&amp;gt; Pouring hugo-0.21.sierra.bottle.tar.gz 🍺 /usr/local/Cellar/hugo/0.21: 32 files, 17.4MB   创建新站点 hugo new site quickstart 添加主题 有关要考虑的主题列表，请参阅themes.gohugo.io。本快速入门使用漂亮的Ananke 主题。
首先，从 GitHub 下载主题并将其添加到您网站的themes目录中：
cd quickstart git init git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke 然后，将主题添加到站点配置中：
echo theme = \&amp;#34;ananke\&amp;#34; &amp;gt;&amp;gt; config.</description>
    </item>
    
    <item>
      <title>Filter和Listener</title>
      <link>https://example.com/p/filter%E5%92%8Clistener/</link>
      <pubDate>Tue, 11 May 2021 15:29:19 +0800</pubDate>
      
      <guid>https://example.com/p/filter%E5%92%8Clistener/</guid>
      <description>Filter和Listener FIlter 指过滤器  概念   生活中的过滤器:空气过滤器 净水器 web中的过滤器:当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能 过滤器的一些功能: 一般用于完整通用的操作：  比如登录验证 统一编码设置 敏感字符过滤     快速入门:
  步骤:
 定义一个类 实现Filter接口， 复写方法 配置拦截资源: 注解配置 @WebFilter(&amp;quot;/*&amp;quot;) web.xml配置    @WebFilter(&amp;#34;/*&amp;#34;) public class FilterDemo implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(&amp;#34;执行了filter&amp;#34;); chain.doFilter(request, response); } }     过滤器细节
  web.xml
  &amp;lt;filter&amp;gt; &amp;lt;filter-name&amp;gt;demo1&amp;lt;/filter-name&amp;gt; &amp;lt;filter-class&amp;gt;com.</description>
    </item>
    
    <item>
      <title>MySQL中的数据类型</title>
      <link>https://example.com/p/mysql%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Tue, 11 May 2021 15:29:19 +0800</pubDate>
      
      <guid>https://example.com/p/mysql%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>MySQL中的数据类型 MySQL支持多种数据类型，主要有数值类型、日期/时间类型和字符串类型。
数值类型 数值类型包括：
  整数类型：TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT
  浮点数类型有FLOAT和DOUBLE
  定点小数类型DECIMAL
  日期/时间类型：包括YEAR、TIME、DATE、DATATIME和TIMESTAMP。
  字符串类型：CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET等。字符串类型又分为文本字符串和二进制字符串。
  整数类型 数值型数据类型主要用来存储数字，不同的数据类型提供不同的取值范围，可以存储的值的范围越大，其所需要的存储空间也会越大。整数类型的字段可以添加AUTO_INCREMENT自增约束条件。
   类型名称 存储需求（B）     TINYINT tinyint 1   SMALLINT smallint 2   MEDIUMINT mediumint 3   INT 4   BIGINT 8    需要注意的是，在设计数据库的时候，在实体类中long型的变量对应BIGINT,INT对应int类型的成员变量。
例：
CREATE TABLE tb_emp1( id INT(11), name VARCHAR(25). deptId INT(11), salary FLOAT ); id字段的数据类型为INT（11），“11”表示该数据类型指定的显示宽度，指定能显示的数值中数字的个数。</description>
    </item>
    
    <item>
      <title>Spring01 概述及IOC理论推导</title>
      <link>https://example.com/p/spring01-%E6%A6%82%E8%BF%B0%E5%8F%8Aioc%E7%90%86%E8%AE%BA%E6%8E%A8%E5%AF%BC/</link>
      <pubDate>Tue, 11 May 2021 15:29:19 +0800</pubDate>
      
      <guid>https://example.com/p/spring01-%E6%A6%82%E8%BF%B0%E5%8F%8Aioc%E7%90%86%E8%AE%BA%E6%8E%A8%E5%AF%BC/</guid>
      <description>Spring介绍  简介  Spring : 春天 &amp;mdash;&amp;gt;给软件行业带来了春天
2002年，Rod Jahnson首次推出了Spring框架雏形interface21框架。
2004年3月24日，Spring框架以interface21框架为基础，经过重新设计，发布了1.0正式版。
很难想象Rod Johnson的学历 , 他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学。
Spring理念 : 使现有技术更加实用 . 本身就是一个大杂烩 , 整合现有的框架技术
官网 : http://spring.io/
官方下载地址 : https://repo.spring.io/libs-release-local/org/springframework/spring/
GitHub : https://github.com/spring-projects
 优点    Spring是一个开源免费的框架 , 容器 .
  Spring是一个轻量级的框架 , 非侵入式的 .
  控制反转 IoC , 面向切面 Aop
  对事物的支持 , 对框架的支持
  一句话概括：
Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）。
 组成  Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式 .</description>
    </item>
    
    <item>
      <title>SpringMvc替换传统MVC</title>
      <link>https://example.com/p/springmvc%E6%9B%BF%E6%8D%A2%E4%BC%A0%E7%BB%9Fmvc/</link>
      <pubDate>Tue, 11 May 2021 15:29:19 +0800</pubDate>
      
      <guid>https://example.com/p/springmvc%E6%9B%BF%E6%8D%A2%E4%BC%A0%E7%BB%9Fmvc/</guid>
      <description>web开发模式  DAO层 对数据库的增删改查 web层 界面（jsp）加控制器（servlrt） service层 执行多个或一个dao层操作，并将其组合成一个完整的业务逻辑 控制层 使用servlet进行控制 数据访问层 使用DAO、Hibernate、JDBC等技术实现对数据库的增删改查 javaBean 用于封装数据  MVC M模型（model） 模型就是 包括 dao，bean
V 视图（view） 视图jsp，用于向用户展示模型中的数据
C 控制（controller） 控制器负责将 模型 中的 数据 显示在不同的 显示层 之中
早期MVC模式（mode1） 模式一：将显示层、控制层、数据层的操作同意交给jsp或者JavaBean来处理
前端用户请求 -&amp;gt; jsp -&amp;gt; javaBean -&amp;gt; 数据库jsp和html、java类（javaBean）高度耦合。
早期MVC模式（mode2） 模式二：以servlet为主展开，由servlet接收客户端的请求，根据请求调用对应的JavaBean或其他程序，最后将要现实的结果交给jsp完成。
前端用户请求 -&amp;gt; jsp -&amp;gt; servlet -&amp;gt; javaBean -&amp;gt; 数据库SpringMVC 用户请求 -&amp;gt; Spring控制器 -&amp;gt; 夹带事务的模型（业务层，数据访问层）-&amp;gt;数据库传统模型层被拆分为（业务层和数据访问层）
 需要的jar包 spring-web-*.jar spring-webmvc-*.jar    修改web.xml中的
&amp;lt;servlet&amp;gt; &amp;lt;servlet-name&amp;gt;dispatcher&amp;lt;/servlet-name&amp;gt; &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt; &amp;lt;/servlet&amp;gt; &amp;lt;servlet-mapping&amp;gt; &amp;lt;servlet-name&amp;gt;dispatcher&amp;lt;/servlet-name&amp;gt; &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt; &amp;lt;/servlet-mapping&amp;gt;   将拦截地址改为/拦截所有请求，并交给SpringMVC的后台控制器来完成</description>
    </item>
    
    <item>
      <title>使用EL表达式</title>
      <link>https://example.com/p/%E4%BD%BF%E7%94%A8el%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Tue, 11 May 2021 15:29:19 +0800</pubDate>
      
      <guid>https://example.com/p/%E4%BD%BF%E7%94%A8el%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>EL（Expression Language） JSP表达式语言（EL）使得访问存储在JavaBean中的数据变得非常简单。JSP EL既可以用来创建算术表达式也可以用来创建逻辑表达式。在JSP EL表达式内可以使用整型数，浮点数，字符串，常量true、false，还有null。
一个简单的语法 ${expr} {expr} 其中，expr指的是表达式。在JSP EL中通用的操作符是 . 和 {} 。这两个操作符允许您通过内嵌的JSP对象访问各种各样的JavaBean属性。
&amp;lt;jsp:setProperty name=&amp;quot;box&amp;quot; property=&amp;quot;perimeter&amp;quot; name=&amp;quot;box&amp;quot; property=&amp;quot;perimeter&amp;quot; value=&amp;quot;${2*box.width+2*box.height}&amp;quot;/&amp;gt;value=&amp;quot;${2*box.width+2*box.height}&amp;quot;/&amp;gt; 当JSP编译器在属性中见到&amp;quot;${}&amp;ldquo;格式后，它会产生代码来计算这个表达式，并且产生一个替代品来代替表达式的值。
您也可以在标签的模板文本中使用表达式语言。比如jsp:text标签简单地将其主体中的文本插入到JSP输出中：
&amp;lt;jsp:text&amp;gt; &amp;lt;h1&amp;gt;Hello JSP!&amp;lt;/h1&amp;gt;&amp;lt;h1&amp;gt;Hello JSP!&amp;lt;/h1&amp;gt; &amp;lt;/jsp:text&amp;gt;&amp;lt;/jsp:text&amp;gt; 现在，在jsp:text标签主体中使用表达式，就像这样：
&amp;lt;jsp:text&amp;gt; Box Perimeter is: ${2*box.width + 2*box.height} &amp;lt;/jsp:text&amp;gt;&amp;lt;/jsp:text&amp;gt; 在EL表达式中可以使用圆括号来组织子表达式。比如${(1 + 2) * 3}等于9，但是${1 + (2 * 3)} 等于7。
想要停用对EL表达式的评估的话，需要使用page指令将isELIgnored属性值设为true：
&amp;lt;%@ page isELIgnored =&amp;quot;true|false&amp;quot; %&amp;gt; 这样，EL表达式就会被忽略。若设为false，则容器将会计算EL表达式。
 EL中的基础操作符 EL表达式支持大部分Java所提供的算术和逻辑操作符：
   操作符 描述     . 访问一个Bean属性或者一个映射条目   [] 访问一个数组或者链表的元素   ( ) 组织一个子表达式以改变优先级   + 加   - 减或负   * 乘   / or div 除   % or mod 取模   == or eq 测试是否相等   !</description>
    </item>
    
    <item>
      <title>数据库数据分页</title>
      <link>https://example.com/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E5%88%86%E9%A1%B5/</link>
      <pubDate>Tue, 11 May 2021 15:29:19 +0800</pubDate>
      
      <guid>https://example.com/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E5%88%86%E9%A1%B5/</guid>
      <description>数据库分页   在DAO中提供方法
  public List&amp;lt;Hero&amp;gt; list(int start, int count) start表示开始的个数，count表示取多少条 比如 list(0, 5) ， 即表示第一页，每页有5条数据 比如 list(5, 5) ， 即表示第二页，每页有5条数据   修改HeroListServlet
  int start = 0; int count = 5; List&amp;lt;Hero&amp;gt; heros = new HeroDAO().list(start, count);   下一页
HeroListServlet : 通过参数获取start，如果浏览器没有传递参数，就设置为0。 根据start，计算next. next的值就是start+count. 然后把next传递给listHero.jsp
listHero.jsp 在最后面增加一个超链
&amp;lt;a href=&amp;quot;?start=${next}&amp;quot;&amp;gt;[下一页]&amp;lt;/a&amp;gt;
start=${next} 从服务器传递过来的next值
  上一页
HeroListServlet: 根据start，计算pre. pre的值就是start-count. 然后把pre传递给listHero.jsp
listHero.jsp 在下一页前增加一个超链
&amp;lt;a href=&amp;quot;?start=${pre}&amp;quot;&amp;gt;[上一页]&amp;lt;/a&amp;gt;
start=${pre} 从服务器传递过来的pre值</description>
    </item>
    
  </channel>
</rss>
