<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on ybakiame&#39; Blog</title>
    <link>https://example.com/post/</link>
    <description>Recent content in Posts on ybakiame&#39; Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 17 Dec 2021 11:59:29 +0800</lastBuildDate><atom:link href="https://example.com/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ssm整合swagger</title>
      <link>https://example.com/p/ssm%E6%95%B4%E5%90%88swagger/</link>
      <pubDate>Fri, 17 Dec 2021 11:59:29 +0800</pubDate>
      
      <guid>https://example.com/p/ssm%E6%95%B4%E5%90%88swagger/</guid>
      <description>ssm工程中使用swagger 鉴于网络上大部分都是springboot的整合教程，这里记录一下配置和踩坑的相关问题。
官方文档地址 springfox-doc
官方演示demo springfox-demos
pom中导入依赖   swagger2
&amp;lt;!-- swagger --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;springfox-swagger2&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.9.2&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;springfox-swagger-ui&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.9.2&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;   swagger3 笔者喜欢使用最新版本，所以选择了swagger3。 如果你的项目中没有依赖冲突，请删除 exclusions标签中的排除项。 若是tomcat无法启动请查看项目依赖冲突，推荐使用idea插件 maven helper 。
&amp;lt;!-- swagger --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;springfox-swagger2&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.0.0&amp;lt;/version&amp;gt; &amp;lt;!--排除有冲突的依赖--&amp;gt; &amp;lt;exclusions&amp;gt; &amp;lt;exclusion&amp;gt; &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt; &amp;lt;/exclusion&amp;gt; &amp;lt;exclusion&amp;gt; &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jackson-annotations&amp;lt;/artifactId&amp;gt; &amp;lt;/exclusion&amp;gt; &amp;lt;exclusion&amp;gt; &amp;lt;groupId&amp;gt;com.fasterxml&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;classmate&amp;lt;/artifactId&amp;gt; &amp;lt;/exclusion&amp;gt; &amp;lt;exclusion&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-aop&amp;lt;/artifactId&amp;gt; &amp;lt;/exclusion&amp;gt; &amp;lt;exclusion&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-beans&amp;lt;/artifactId&amp;gt; &amp;lt;/exclusion&amp;gt; &amp;lt;exclusion&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt; &amp;lt;/exclusion&amp;gt; &amp;lt;/exclusions&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;springfox-swagger-ui&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.</description>
    </item>
    
    <item>
      <title>JS前端(CryptoJS)和Java后端的AES加密和解密</title>
      <link>https://example.com/p/js%E5%89%8D%E7%AB%AFcryptojs%E5%92%8Cjava%E5%90%8E%E7%AB%AF%E7%9A%84aes%E5%8A%A0%E5%AF%86%E5%92%8C%E8%A7%A3%E5%AF%86/</link>
      <pubDate>Mon, 15 Nov 2021 23:33:18 +0800</pubDate>
      
      <guid>https://example.com/p/js%E5%89%8D%E7%AB%AFcryptojs%E5%92%8Cjava%E5%90%8E%E7%AB%AF%E7%9A%84aes%E5%8A%A0%E5%AF%86%E5%92%8C%E8%A7%A3%E5%AF%86/</guid>
      <description>JS前端(CryptoJS)和Java后端的AES加密和解密 前端 下载、配置和使用 crypto-js 克隆或下载crypto-js 主要使用 crypto-js.js 和 aes.js
配置 crypto-js 引入 crypto-js.js 和 aes.js &amp;lt;script src=&amp;#34;js/crypto-js/crypto-js.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;#34;js/crypto-js/aes.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; 创建加密js myCrypto.js // AES 加密，AES-128, AES-192, AES-256  // AES-128: key和iv都是16个字节，16*8=128bit  // AES-192: key和iv都是24个字节，24*8=128bit  // AES-256: key和iv都是32个字节，32*8=128bit  // iv 似乎一般都是纯数字  // 例如：AES_encrypt_CBC(&amp;#39;需要加密的内容&amp;#39;, &amp;#39;1234567890123456&amp;#39;, &amp;#39;1234567890654321&amp;#39;);  function AES_CBC_encrypt(message, key, iv) { // utf8字符串—&amp;gt;WordArray对象，WordArray是一个保存32位整数的数组，相当于转成了二进制  let keyHex = CryptoJS.enc.Utf8.parse(key); //  let ivHex = CryptoJS.enc.Utf8.parse(iv); let messageHex = CryptoJS.enc.Utf8.parse(message); let encrypted = CryptoJS.</description>
    </item>
    
    <item>
      <title>Stringbuffer</title>
      <link>https://example.com/p/stringbuffer/</link>
      <pubDate>Mon, 15 Nov 2021 13:24:27 +0800</pubDate>
      
      <guid>https://example.com/p/stringbuffer/</guid>
      <description>使用 Stringbuffer 代替 字符串连接 String是在Java中最常用的类。特别是在 Web 应用程序中，它被广泛用于生成和格式化 HTML 内容。
String被设计为不可变的；为了修改一个 String，您必须创建一个新 String对象。因此，字符串连接可能会导致在构造 String最终对象之前创建许多中间对象 String。
StringBuffer是 的可变伴生类 String；它允许您修改 String. 因此，StringBuffer通常比 String需要连接时更有效。
如果在多个语句中重复附加到一个字符串，请使用 StringBuffer 而不是字符串连接 对 String重复使用“+=”操作代价高昂。
例如：
String s = new String(); [do some work ...] s += s1; [do some more work...] s += s2; 用 StringBuffer 替换上面的字符串连接：
StringBuffer strbuf = new StringBuffer(); [do some work ...] strbuf.append(s1); [so some more work ...] strbuf.append(s2); String s = strbuf.toString(); 如果连接在一个语句内，则使用 String 或 StringBuffer String并 StringBuffer在某些情况下执行相同的操作；所以你不需要 StringBuffer直接使用。</description>
    </item>
    
    <item>
      <title>Druid 连接池的简单配置</title>
      <link>https://example.com/p/druid-%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 15 Nov 2021 12:44:01 +0800</pubDate>
      
      <guid>https://example.com/p/druid-%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/</guid>
      <description>#url=jdbc:mysql://localhost:3306/demo druid.url=jdbc:mysql://localhost:3306/mysql?serverTimezone=UTC #这个可以缺省的，会根据url自动识别 druid.driverClassName=com.mysql.cj.jdbc.Driver druid.username=root druid.password=12345678 ##初始连接数，默认0 druid.initialSize=10 #最大连接数，默认8 druid.maxActive=30 #最小闲置数 druid.minIdle=10 #获取连接的最大等待时间，单位毫秒 druid.maxWait=2000 #缓存PreparedStatement，默认false druid.poolPreparedStatements=true #缓存PreparedStatement的最大数量，默认-1（不缓存）。大于0时会自动开启缓存PreparedStatement，所以可以省略上一句设置 druid.maxOpenPreparedStatements=20 </description>
    </item>
    
    <item>
      <title>Mybatis 使用druid连接池</title>
      <link>https://example.com/p/mybatis-%E4%BD%BF%E7%94%A8druid%E8%BF%9E%E6%8E%A5%E6%B1%A0/</link>
      <pubDate>Mon, 15 Nov 2021 12:39:17 +0800</pubDate>
      
      <guid>https://example.com/p/mybatis-%E4%BD%BF%E7%94%A8druid%E8%BF%9E%E6%8E%A5%E6%B1%A0/</guid>
      <description>mybatis使用Druid连接池 在 util包下新建一个 DruidDataSourceFactory类
package com.edu.util; import com.alibaba.druid.pool.DruidDataSource; import org.apache.ibatis.datasource.DataSourceFactory; import org.apache.ibatis.datasource.pooled.PooledDataSourceFactory; import javax.sql.DataSource; import java.sql.SQLException; import java.util.Properties; //public class DruidDataSourceFactory extends PooledDataSourceFactory { // public DruidDataSourceFactory() { // this.dataSource = new DruidDataSource(); // } //}  public class DruidDataSourceFactory implements DataSourceFactory { private Properties props; @Override public DataSource getDataSource() { DruidDataSource dds = new DruidDataSource(); dds.setDriverClassName(this.props.getProperty(&amp;#34;driver&amp;#34;)); dds.setUrl(this.props.getProperty(&amp;#34;url&amp;#34;)); dds.setUsername(this.props.getProperty(&amp;#34;username&amp;#34;)); dds.setPassword(this.props.getProperty(&amp;#34;password&amp;#34;)); // 其他配置可以根据MyBatis主配置文件进行配置  try { dds.init(); } catch (SQLException e) { e.</description>
    </item>
    
    <item>
      <title>Java 字符串拼接内存解析</title>
      <link>https://example.com/p/java-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Mon, 15 Nov 2021 12:05:08 +0800</pubDate>
      
      <guid>https://example.com/p/java-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90/</guid>
      <description>Java 字符串(String)拼接内存解析 **String str1 = “Hello”;**字符串常量池中没有&amp;quot;Hello&amp;quot;，则创建一个字符串并把地址值返回给str1
**String str2 = “Hello”;**字符串常量池中存在&amp;quot;Hello&amp;quot;，则创将该字符串的地址值返回给str2
String str3 = new string( “Hello”);
str3指向对象的地址，对象中的值指向字符串常量池中已有的字符串
 https://img-blog.csdnimg.cn/20200413102918926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2w4Mjc4OTM2Mjg=,size_16,color_FFFFFF,t_70 
String str4 = “Hello” + “World”;
直接拼接成&amp;quot;HelloWorld&amp;quot;,字符串常量池中没有&amp;quot;HelloWorld&amp;quot;，则在字符串常量池中创建一个字符串并把地址值返回给str4
 https://img-blog.csdnimg.cn/20200413115906695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2w4Mjc4OTM2Mjg=,size_16,color_FFFFFF,t_70 
String str5 = “World”;
字符串常量池中没有&amp;quot;World&amp;quot;，则创建一个字符串并把地址值返回给str5
**String str6 = str1 + str5;**编译器对字符串加号做了优化，它会用StringBuffer的append方法进行追加。等效于：str6 = new StringBuffer(str1 ).append( str5).toString();拼接好后，字符串常量池中有&amp;quot;HelloWorld&amp;quot;，str6产生的对象的内容指向字符串常量池中&amp;quot;HelloWorld&amp;quot;的地址
 https://img-blog.csdnimg.cn/20200413121213984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2w4Mjc4OTM2Mjg=,size_16,color_FFFFFF,t_70 
String str7 = (str3 + str5).intern（）;
 https://img-blog.csdnimg.cn/2020041312450961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2w4Mjc4OTM2Mjg=,size_16,color_FFFFFF,t_70 
Person p1 = new Person(“张三”,18);
Person p2 = new Person(“张三”,20);
 https://img-blog.csdnimg.cn/20200413125737157.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2w4Mjc4OTM2Mjg=,size_16,color_FFFFFF,t_70</description>
    </item>
    
    <item>
      <title>使用notion搭建个人blog</title>
      <link>https://example.com/p/%E4%BD%BF%E7%94%A8notion%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAblog/</link>
      <pubDate>Mon, 15 Nov 2021 11:56:52 +0800</pubDate>
      
      <guid>https://example.com/p/%E4%BD%BF%E7%94%A8notion%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAblog/</guid>
      <description>使用notion搭建blog 为什么使用notion 现在建博客的工具有很多很多。
如果想要一个静态博客，你可以选择hugo、jekyll、hexo搭配github page实现。
如果想要一个动态博客，又没有什么基础，那你可以选择WordPress，网上教程一大把。
不过我采用的是notion＋github，并托管到vercel。
使用notion基于以下几点考虑：
 notion支持全平台(Windows、网页、Mac、ios、安卓)。可以随时随地地码字 页面简洁美观，功能强大。特别是database功能，非常方便管理，同时支持多种views展示 支持Markdown语法  使用到的工具：  notion 账号 github 账号 vercel 账号 git node.js vscode  使用模版 nextjs-notion-starter-kit   fork 或 clone 项目
  使用命令行克隆
git clone https://github.com/transitive-bullshit/nextjs-notion-starter-kit.git   使用Github Desktop或者vscode克隆
    修改 site.config.js
两个选项
// 获取你要分享的notion page的id (必须)  rootNotionPageId: &amp;#39;78fc5a4b88d74b0e824e29407e9f1ec1&amp;#39;, // 生成网站的基础信息 (必须)  name: &amp;#39;Transitive Bullshit&amp;#39;,//名称  domain: &amp;#39;transitivebullsh.it&amp;#39;,//域名可不填  author: &amp;#39;Travis Fischer&amp;#39;,//作者   安装node.</description>
    </item>
    
    <item>
      <title>Springmvc 中文乱码</title>
      <link>https://example.com/p/springmvc-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</link>
      <pubDate>Thu, 11 Nov 2021 11:18:56 +0800</pubDate>
      
      <guid>https://example.com/p/springmvc-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</guid>
      <description>Springmvc 中的中文乱码 解决POST请求中文乱码问题  encoding是设置的request乱码问题，forceEncoding是设置的response乱码问题
 &amp;lt;filter&amp;gt; &amp;lt;filter-name&amp;gt;CharacterEncodingFilter&amp;lt;/filter-name&amp;gt; &amp;lt;filter-class&amp;gt;org.springframework.web.filter.CharacterEncodingFilter&amp;lt;/filter-class&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;encoding&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;UTF-8&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;!--spring5之后就不需要配置forceEncoding了--&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;forceEncoding&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;true&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;/filter&amp;gt; &amp;lt;filter-mapping&amp;gt; &amp;lt;filter-name&amp;gt;CharacterEncodingFilter&amp;lt;/filter-name&amp;gt; &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt; &amp;lt;/filter-mapping&amp;gt; 解决Get乱码 修改tomcat配置文件编码
&amp;lt;!--ISO8859-1是tomcat默认编码，需要将tomcat编码改为utf-8--&amp;gt; &amp;lt;ConnectorURIEncoding=&amp;#34;utf-8&amp;#34; connectionTimeout=&amp;#34;20000&amp;#34; port=&amp;#34;8080&amp;#34; protocol=&amp;#34;HTTP/1.1&amp;#34; redirectPort=&amp;#34;8443&amp;#34;/&amp;gt; 狂神推荐的大神过滤器 package com.zhang.filter; import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletRequestWrapper; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.UnsupportedEncodingException; import java.util.Map; /** * 解决get和post请求，全部乱码的过滤器 */ public class GenericEncodingFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws IOException, ServletException { //处理response的字符编码  HttpServletResponse myResponse = (HttpServletResponse)response; //转型为与协议相关对象  HttpServletRequest httpServletRequest = (HttpServletRequest)request; //对request包装增强  HttpServletRequest myRequest = new MyRequest(httpServletRequest); filterChain.</description>
    </item>
    
    <item>
      <title>MyBatis07 缓存</title>
      <link>https://example.com/p/mybatis07-%E7%BC%93%E5%AD%98/</link>
      <pubDate>Tue, 09 Nov 2021 09:58:40 +0800</pubDate>
      
      <guid>https://example.com/p/mybatis07-%E7%BC%93%E5%AD%98/</guid>
      <description>mybatis缓存 简介 1、什么是缓存 [ Cache ]？
 存在内存中的临时数据。 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。  2、为什么使用缓存？
 减少和数据库的交互次数，减少系统开销，提高系统效率。  3、什么样的数据能使用缓存？
 经常查询并且不经常改变的数据。  Mybatis缓存   MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。
  MyBatis系统中默认定义了两级缓存：一级缓存和二级缓存
   默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存） 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存    一级缓存 一级缓存也叫本地缓存：
 与数据库同一次会话期间查询到的数据会放在本地缓存中。 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；  注意：
必须保证多次查询中间，不能有任何的增删改操作，否则缓存数据会清空。
1、在mybatis中加入日志，方便测试结果
2、编写接口方法
//根据id查询用户 User queryUserById(@Param(&amp;#34;id&amp;#34;) int id); 3、接口对应的Mapper文件
&amp;lt;select id=&amp;#34;queryUserById&amp;#34; resultType=&amp;#34;user&amp;#34;&amp;gt; select * from user where id = #{id} &amp;lt;/select&amp;gt; 4、测试
@Test public void testQueryUserById(){ SqlSession session = MybatisUtils.</description>
    </item>
    
    <item>
      <title>MyBatis06 动态SQL</title>
      <link>https://example.com/p/mybatis06-%E5%8A%A8%E6%80%81sql/</link>
      <pubDate>Tue, 09 Nov 2021 09:57:49 +0800</pubDate>
      
      <guid>https://example.com/p/mybatis06-%E5%8A%A8%E6%80%81sql/</guid>
      <description>动态SQL 介绍 什么是动态SQL：动态SQL指的是根据不同的查询条件 , 生成不同的Sql语句.
官网描述： MyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。 虽然在以前使用动态 SQL 并非一件易事，但正是 MyBatis 提供了可以被用在任意 SQL 映射语句中的强大的动态 SQL 语言得以改进这种情形。 动态 SQL 元素和 JSTL 或基于类似 XML 的文本处理器相似。在 MyBatis 之前的版本中，有很多元素需要花时间了解。MyBatis 3 大大精简了元素种类，现在只需学习原来一半的元素便可。MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。 ------------------------------- - if - choose (when, otherwise) - trim (where, set) - foreach ------------------------------- 我们之前写的 SQL 语句都比较简单，如果有比较复杂的业务，我们需要写复杂的 SQL 语句，往往需要拼接，而拼接 SQL ，稍微不注意，由于引号，空格等缺失可能都会导致错误。
那么怎么去解决这个问题呢？这就要使用 mybatis 动态SQL，通过 if, choose, when, otherwise, trim, where, set, foreach等标签，可组合成非常灵活的SQL语句，从而在提高 SQL 语句的准确性的同时，也大大提高了开发人员的效率。</description>
    </item>
    
    <item>
      <title>MyBatis05 一对多和多对一处理</title>
      <link>https://example.com/p/mybatis05-%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%92%8C%E5%A4%9A%E5%AF%B9%E4%B8%80%E5%A4%84%E7%90%86/</link>
      <pubDate>Tue, 09 Nov 2021 09:56:14 +0800</pubDate>
      
      <guid>https://example.com/p/mybatis05-%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%92%8C%E5%A4%9A%E5%AF%B9%E4%B8%80%E5%A4%84%E7%90%86/</guid>
      <description>一对多和多对一处理 多对一的处理 多对一的理解：
 多个学生对应一个老师 如果对于学生这边，就是一个多对一的现象，即从学生这边关联一个老师！  CREATETABLE`teacher`(`id`INT(10)NOTNULL,`name`VARCHAR(30)DEFAULTNULL,PRIMARYKEY(`id`))ENGINE=INNODBDEFAULTCHARSET=utf8INSERTINTOteacher(`id`,`name`)VALUES(1,&amp;#39;张老师&amp;#39;);CREATETABLE`student`(`id`INT(10)NOTNULL,`name`VARCHAR(30)DEFAULTNULL,`tid`INT(10)DEFAULTNULL,PRIMARYKEY(`id`),KEY`fktid`(`tid`),CONSTRAINT`fktid`FOREIGNKEY(`tid`)REFERENCES`teacher`(`id`))ENGINE=INNODBDEFAULTCHARSET=utf8INSERTINTO`student`(`id`,`name`,`tid`)VALUES(&amp;#39;1&amp;#39;,&amp;#39;小明&amp;#39;,&amp;#39;1&amp;#39;);INSERTINTO`student`(`id`,`name`,`tid`)VALUES(&amp;#39;2&amp;#39;,&amp;#39;小红&amp;#39;,&amp;#39;1&amp;#39;);INSERTINTO`student`(`id`,`name`,`tid`)VALUES(&amp;#39;3&amp;#39;,&amp;#39;小张&amp;#39;,&amp;#39;1&amp;#39;);INSERTINTO`student`(`id`,`name`,`tid`)VALUES(&amp;#39;4&amp;#39;,&amp;#39;小李&amp;#39;,&amp;#39;1&amp;#39;);INSERTINTO`student`(`id`,`name`,`tid`)VALUES(&amp;#39;5&amp;#39;,&amp;#39;小王&amp;#39;,&amp;#39;1&amp;#39;);搭建测试环境 1、IDEA安装Lombok插件
2、引入Maven依赖
&amp;lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.16.10&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 3、在代码中增加注解
@Data //GET,SET,ToString，有参，无参构造 public class Teacher { private int id; private String name; } @Data public class Student { private int id; private String name; //多个学生可以是同一个老师，即多对一  private Teacher teacher; } 4、编写实体类对应的Mapper接口 【两个】
 无论有没有需求，都应该写上，以备后来之需！  public interface StudentMapper { } public interface TeacherMapper { } 5、编写Mapper接口对应的 mapper.xml配置文件 【两个】
 无论有没有需求，都应该写上，以备后来之需！  &amp;lt;?</description>
    </item>
    
    <item>
      <title>MyBatis04 使用注解开发</title>
      <link>https://example.com/p/mybatis04-%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/</link>
      <pubDate>Tue, 09 Nov 2021 09:55:20 +0800</pubDate>
      
      <guid>https://example.com/p/mybatis04-%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/</guid>
      <description>使用注解开发 面向接口编程  大家之前都学过面向对象编程，也学习过接口，但在真正的开发中，很多时候我们会选择面向接口编程 根本原因 : 解耦 , 可拓展 , 提高复用 , 分层开发中 , 上层不用管具体的实现 , 大家都遵守共同的标准 , 使得开发变得容易 , 规范性更好 在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的,对系统设计人员来讲就不那么重要了； 而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。  关于接口的理解   接口从更深层次的理解，应是定义（规范，约束）与实现（名实分离的原则）的分离。
  接口的本身反映了系统设计人员对系统的抽象理解。
  接口应有两类：
   第一类是对一个个体的抽象，它可对应为一个抽象体(abstract class)； 第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface）；    一个体有可能有多个抽象面。抽象体与抽象面是有区别的。
  三个面向区别   面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性及方法 .
  面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现 .
  接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题.更多的体现就是对系统整体的架构
  利用注解开发   mybatis最初配置信息是基于 XML ,映射语句(SQL)也是定义在 XML 中的。而到MyBatis 3提供了新的基于注解的配置。不幸的是，Java 注解的的表达力和灵活性十分有限。最强大的 MyBatis 映射并不能用注解来构建</description>
    </item>
    
    <item>
      <title>MyBatis03 ResultMap及分页</title>
      <link>https://example.com/p/mybatis03-resultmap%E5%8F%8A%E5%88%86%E9%A1%B5/</link>
      <pubDate>Tue, 09 Nov 2021 09:53:47 +0800</pubDate>
      
      <guid>https://example.com/p/mybatis03-resultmap%E5%8F%8A%E5%88%86%E9%A1%B5/</guid>
      <description>ResultMap 查询为null问题 要解决的问题：属性名和字段名不一致
环境：新建一个项目，将之前的项目拷贝过来
1、查看之前的数据库的字段名
id name pwd
2、Java中的实体类设计
public class User { private int id; //id  private String name; //姓名  private String password; //密码和数据库不一样！ } 3、接口
//根据id查询用户 User selectUserById(int id); 4、mapper映射文件
&amp;lt;select id=&amp;#34;selectUserById&amp;#34; resultType=&amp;#34;user&amp;#34;&amp;gt; select * from user where id = #{id} &amp;lt;/select&amp;gt; 5、测试
@Test public void testSelectUserById() { SqlSession session = MybatisUtils.getSession(); //获取SqlSession连接  UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.selectUserById(1); System.out.println(user); session.close(); } 结果:</description>
    </item>
    
    <item>
      <title>MyBatis02 增删改查</title>
      <link>https://example.com/p/mybatis02-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</link>
      <pubDate>Tue, 09 Nov 2021 09:52:53 +0800</pubDate>
      
      <guid>https://example.com/p/mybatis02-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</guid>
      <description>CRUD操作  SQL语句返回值类型。【完整的类名或者别名】 传入SQL语句的参数类型 。【万能的Map，可以多尝试使用】 命名空间中唯一的标识符 接口中的方法名与映射文件中的SQL语句ID 一一对应 id parameterType resultType  select 标签  id 相应dao层方法 parameterType 传入参数类型 resultType 返回对象  需求：根据id查询用户
1、在UserMapper中添加对应方法
public interface UserMapper { //根据id查询用户  User selectUserById(int id); } 2、在UserMapper.xml中添加Select语句
&amp;lt;select id=&amp;#34;selectUserById&amp;#34; resultType=&amp;#34;com.xxgc.pojo.User&amp;#34;&amp;gt; select * from user where id = #{id} &amp;lt;/select&amp;gt; 3、测试类中测试
@Test public void tsetSelectUserById() { SqlSession session = MybatisUtils.getSession(); //获取SqlSession连接  UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.selectUserById(1); System.out.println(user); session.close(); } insert 标签 需求：给数据库增加一个用户</description>
    </item>
    
    <item>
      <title>mybatis3 教师笔记</title>
      <link>https://example.com/p/mybatis3-%E6%95%99%E5%B8%88%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 09 Nov 2021 09:52:53 +0800</pubDate>
      
      <guid>https://example.com/p/mybatis3-%E6%95%99%E5%B8%88%E7%AC%94%E8%AE%B0/</guid>
      <description>一、Mybatis 3的学习  MyBatis logo 
 mybatisplus 
1.1 什么是Mybatis MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。
官网：https://mybatis.org/mybatis-3/zh/index.html
用来学习最新的API
中文网：http://www.mybatis.cn/
用来查看使用技巧
1.2 Mybatis的历史 原是apache的一个开源项目iBatis，2010年6月这个项目由apache迁移到了google code，随着开发团队转投Google code旗下，ibatis3.x正式更名为Mybatis，代码于2013年11月迁移到Github。
1.3 Mybatis的优势  基于sql语句编程，使用灵活，sql与程序代码的解耦 与JDBC相比减少50%代码，减少大量冗余代码，不需要手动开关连接 只要支持jdbc的数据库都支持Mybatis 与spring集成 支持面向对象编程，对象与ORM表映射  二、Mybaits环境搭建 2.1 创建数据库和表 /* SQLyog Ultimate v12.09 (64 bit) MySQL - 5.5.54 : Database - mybatis ********************************************************************* *//*!40101 SET NAMES utf8 */;/*!40101 SET SQL_MODE=&amp;#39;&amp;#39;*/;/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;/*!</description>
    </item>
    
    <item>
      <title>MyBatis01 环境配置</title>
      <link>https://example.com/p/mybatis01-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Tue, 09 Nov 2021 09:50:26 +0800</pubDate>
      
      <guid>https://example.com/p/mybatis01-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</guid>
      <description>MyBatis简介 什么是MyBatis   MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。
  MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集的过程
  MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 实体类 【Plain Old Java Objects,普通的 Java对象】映射成数据库中的记录。
  Mybatis的历史   MyBatis 本是apache的一个开源项目ibatis, 2010年这个项目由apache 迁移到了google code，并且改名为MyBatis 。
  2013年11月迁移到Github .
  Mybatis官方文档 : http://www.mybatis.org/mybatis-3/zh/index.html
  GitHub : https://github.com/mybatis/mybatis-3
  持久化 持久化是将程序数据在持久状态和瞬时状态间转换的机制。
 即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。 JDBC就是一种持久化机制。文件IO也是一种持久化机制。  为什么需要持久化服务呢？那是由于内存本身的缺陷引起的
 内存断电后数据会丢失，但有一些对象是无论如何都不能丢失的，比如银行账号等，遗憾的是，人们还无法保证内存永不掉电。 内存过于昂贵，与硬盘、光盘等外存相比。所以即使对象不需要永久保存，也会因为内存的容量限制不能一直呆在内存中，需要持久化来缓存到外存。  持久层 什么是持久层？
 完成持久化工作的代码块 . &amp;mdash;-&amp;gt; dao层 【DAO (Data Access Object) 数据访问对象】 大多数情况下特别是企业级应用，数据持久化往往也就意味着将内存中的数据保存到磁盘上加以固化，而持久化的实现过程则大多通过各种关系数据库来完成。 不过这里有一个字需要特别强调，也就是所谓的“层”。对于应用系统而言，数据持久功能大多是必不可少的组成部分。也就是说，我们的系统中，已经天然的具备了“持久层”概念？也许是，但也许实际情况并非如此。之所以要独立出一个“持久层”的概念,而不是“持久模块”，“持久单元”，也就意味着，我们的系统架构中，应该有一个相对独立的逻辑层面，专注于数据持久化逻辑的实现.</description>
    </item>
    
    <item>
      <title>SpringMVC08 拦截器与文件上传下载</title>
      <link>https://example.com/p/springmvc08-%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B8%8E%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/</link>
      <pubDate>Tue, 09 Nov 2021 09:43:55 +0800</pubDate>
      
      <guid>https://example.com/p/springmvc08-%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B8%8E%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/</guid>
      <description>拦截器以及文件的上传和下载 拦截器 概述 SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。
**过滤器与拦截器的区别：**拦截器是AOP思想的具体应用。
过滤器
 servlet规范中的一部分，任何java web工程都可以使用 在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截  拦截器
 拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用 拦截器只会拦截访问的控制器方法， 如果访问的是jsp/html/css/image/js是不会进行拦截的  自定义拦截器 那如何实现拦截器呢？
想要自定义拦截器，必须实现 HandlerInterceptor 接口。
1、新建一个Moudule ， springmvc-07-Interceptor ， 添加web支持
2、配置web.xml 和 springmvc-servlet.xml 文件
3、编写一个拦截器
package com.kuang.interceptor; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class MyInterceptor implements HandlerInterceptor { //在请求处理的方法之前执行  //如果返回true执行下一个拦截器  //如果返回false就不执行下一个拦截器  public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception { System.out.println(&amp;#34;------------处理前------------&amp;#34;); return true; } //在请求处理方法执行之后执行  public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception { System.</description>
    </item>
    
    <item>
      <title>SpringMVC07 Ajax研究</title>
      <link>https://example.com/p/springmvc07-ajax%E7%A0%94%E7%A9%B6/</link>
      <pubDate>Tue, 09 Nov 2021 09:43:00 +0800</pubDate>
      
      <guid>https://example.com/p/springmvc07-ajax%E7%A0%94%E7%A9%B6/</guid>
      <description>Ajax研究 简介   AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。
  AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。
  Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。
  在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。Google Suggest能够自动帮你完成搜索单词。
  Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。
  就和国内百度的搜索框一样!
  传统的网页(即不用ajax技术的网页)，想要更新内容或者提交一个表单，都需要重新加载整个网页。
  使用ajax技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。
  使用Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的Web用户界面。
  伪造Ajax 我们可以使用前端的一个标签来伪造一个ajax的样子。iframe标签
1、新建一个module ：sspringmvc-06-ajax ， 导入web支持！
2、编写一个 ajax-frame.html 使用 iframe 测试，感受下效果
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;kuangshen&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34;&amp;gt; window.</description>
    </item>
    
    <item>
      <title>SpringMVC06 Json交互处理</title>
      <link>https://example.com/p/springmvc06-json%E4%BA%A4%E4%BA%92%E5%A4%84%E7%90%86/</link>
      <pubDate>Tue, 09 Nov 2021 09:42:10 +0800</pubDate>
      
      <guid>https://example.com/p/springmvc06-json%E4%BA%A4%E4%BA%92%E5%A4%84%E7%90%86/</guid>
      <description>Json 什么是JSON？  JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。 采用完全独立于编程语言的文本格式来存储和表示数据。 简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。  在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式：
 对象表示为键值对，数据由逗号分隔 花括号保存对象 方括号保存数组  JSON 键值对是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 &amp;quot;&amp;quot; 包裹，使用冒号 : 分隔，然后紧接着值：
{&amp;#34;name&amp;#34;: &amp;#34;QinJiang&amp;#34;} {&amp;#34;age&amp;#34;: &amp;#34;3&amp;#34;} {&amp;#34;sex&amp;#34;: &amp;#34;男&amp;#34;} 很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解：
JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。
var obj = {a: &amp;#39;Hello&amp;#39;, b: &amp;#39;World&amp;#39;}; //这是一个对象，注意键名也是可以使用引号包裹的 var json = &amp;#39;{&amp;#34;a&amp;#34;: &amp;#34;Hello&amp;#34;, &amp;#34;b&amp;#34;: &amp;#34;World&amp;#34;}&amp;#39;; //这是一个 JSON 字符串，本质是一个字符串 JSON 和 JavaScript 对象互转</description>
    </item>
    
    <item>
      <title>SpringMVC05 整合SSM框架</title>
      <link>https://example.com/p/springmvc05-%E6%95%B4%E5%90%88ssm%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Tue, 09 Nov 2021 09:40:59 +0800</pubDate>
      
      <guid>https://example.com/p/springmvc05-%E6%95%B4%E5%90%88ssm%E6%A1%86%E6%9E%B6/</guid>
      <description>整合SSM框架 数据库环境 创建一个存放书籍数据的数据库表
CREATEDATABASE`ssmbuild`;USE`ssmbuild`;DROPTABLEIFEXISTS`books`;CREATETABLE`books`(`bookID`INT(10)NOTNULLAUTO_INCREMENTCOMMENT&amp;#39;书id&amp;#39;,`bookName`VARCHAR(100)NOTNULLCOMMENT&amp;#39;书名&amp;#39;,`bookCounts`INT(11)NOTNULLCOMMENT&amp;#39;数量&amp;#39;,`detail`VARCHAR(200)NOTNULLCOMMENT&amp;#39;描述&amp;#39;,KEY`bookID`(`bookID`))ENGINE=INNODBDEFAULTCHARSET=utf8INSERTINTO`books`(`bookID`,`bookName`,`bookCounts`,`detail`)VALUES(1,&amp;#39;Java&amp;#39;,1,&amp;#39;从入门到放弃&amp;#39;),(2,&amp;#39;MySQL&amp;#39;,10,&amp;#39;从删库到跑路&amp;#39;),(3,&amp;#39;Linux&amp;#39;,5,&amp;#39;从进门到进牢&amp;#39;);基本环境搭建 1、新建一Maven项目！ssmbuild ， 添加web的支持
2、导入相关的pom依赖！
&amp;lt;dependencies&amp;gt; &amp;lt;!--Junit--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--数据库驱动--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.1.47&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 数据库连接池 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.mchange&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;c3p0&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.9.5.2&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--Servlet - JSP --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;servlet-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.5&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.servlet.jsp&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jsp-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.2&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jstl&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.2&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--Mybatis--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.5.2&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis-spring&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.0.2&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--Spring--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.1.9.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-jdbc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.1.9.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; 3、Maven资源过滤设置</description>
    </item>
    
    <item>
      <title>SpringMVC04 数据处理及跳转</title>
      <link>https://example.com/p/springmvc04-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%8F%8A%E8%B7%B3%E8%BD%AC/</link>
      <pubDate>Tue, 09 Nov 2021 09:40:04 +0800</pubDate>
      
      <guid>https://example.com/p/springmvc04-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%8F%8A%E8%B7%B3%E8%BD%AC/</guid>
      <description>数据处理及跳转 跳转 ModelAndView 设置ModelAndView对象 , 根据view的名称 , 和视图解析器跳到指定的页面 .
页面 : {视图解析器前缀} + viewName +{视图解析器后缀}
&amp;lt;!-- 视图解析器 --&amp;gt; &amp;lt;bean class=&amp;#34;org.springframework.web.servlet.view.InternalResourceViewResolver&amp;#34; id=&amp;#34;internalResourceViewResolver&amp;#34;&amp;gt; &amp;lt;!-- 前缀 --&amp;gt; &amp;lt;property name=&amp;#34;prefix&amp;#34; value=&amp;#34;/WEB-INF/jsp/&amp;#34; /&amp;gt; &amp;lt;!-- 后缀 --&amp;gt; &amp;lt;property name=&amp;#34;suffix&amp;#34; value=&amp;#34;.jsp&amp;#34; /&amp;gt; &amp;lt;/bean&amp;gt; 对应的controller类
public class ControllerTest1 implements Controller { public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponsehttpServletResponse) throws Exception { //返回一个模型视图对象  ModelAndView mv = new ModelAndView(); mv.addObject(&amp;#34;msg&amp;#34;,&amp;#34;ControllerTest1&amp;#34;); mv.setViewName(&amp;#34;test&amp;#34;); return mv; } } ServletAPI 通过设置ServletAPI , 不需要视图解析器 .
1、通过HttpServletResponse进行输出</description>
    </item>
    
    <item>
      <title>SpringMVC03 RestFul和控制器</title>
      <link>https://example.com/p/springmvc03-restful%E5%92%8C%E6%8E%A7%E5%88%B6%E5%99%A8/</link>
      <pubDate>Tue, 09 Nov 2021 09:39:07 +0800</pubDate>
      
      <guid>https://example.com/p/springmvc03-restful%E5%92%8C%E6%8E%A7%E5%88%B6%E5%99%A8/</guid>
      <description>RestFul和控制器 控制器Controller   控制器复杂提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。
  控制器负责解析用户的请求并将其转换为一个模型。
  在Spring MVC中一个控制器类可以包含多个方法
  在Spring MVC中，对于Controller的配置方式有很多种
  实现Controller接口 Controller是一个接口，在org.springframework.web.servlet.mvc包下，接口中只有一个方法；
  编写一个Controller类，ControllerTest1
//定义控制器 //注意点：不要导错包，实现Controller接口，重写方法； public class ControllerTest1 implements Controller { //处理请求且返回一个模型与视图对象  public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponsehttpServletResponse) throws Exception { //返回一个模型视图对象  ModelAndView mv = new ModelAndView(); mv.addObject(&amp;#34;msg&amp;#34;,&amp;#34;Test1Controller&amp;#34;); mv.setViewName(&amp;#34;test&amp;#34;); return mv; } }   编写完毕后，去Spring配置文件中注册请求的bean；name对应请求路径，class对应处理请求的类
&amp;lt;bean name=&amp;#34;/t1&amp;#34; class=&amp;#34;com.xxgc.controller.ControllerTest1&amp;#34;/&amp;gt;   编写前端test.jsp，注意在WEB-INF/jsp目录下编写，对应我们的视图解析器
&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;jsp&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; ${msg} &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;   配置Tomcat运行测试，我这里没有项目发布名配置的就是一个 / ，所以请求不用加项目名，OK！</description>
    </item>
    
    <item>
      <title>SpringMVC02 配置springMVC</title>
      <link>https://example.com/p/springmvc02-%E9%85%8D%E7%BD%AEspringmvc/</link>
      <pubDate>Tue, 09 Nov 2021 09:38:02 +0800</pubDate>
      
      <guid>https://example.com/p/springmvc02-%E9%85%8D%E7%BD%AEspringmvc/</guid>
      <description>配置springMVC 配置版 新建一个Moudle ， springmvc-02-hello ， 添加web的支持！
确定导入了SpringMVC 的依赖！
配置web.xml，注册DispatcherServlet &amp;lt;!DOCTYPE web-app PUBLIC &amp;#34;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&amp;#34; &amp;#34;http://java.sun.com/dtd/web-app_2_3.dtd&amp;#34; &amp;gt; &amp;lt;web-app&amp;gt; &amp;lt;display-name&amp;gt;Archetype Created Web Application&amp;lt;/display-name&amp;gt; &amp;lt;!--1.注册DispatcherServlet--&amp;gt; &amp;lt;servlet&amp;gt; &amp;lt;servlet-name&amp;gt;springmvc&amp;lt;/servlet-name&amp;gt; &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt; &amp;lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;classpath:springmvc-servlet.xml&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;!--启动级别-1--&amp;gt; &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt; &amp;lt;/servlet&amp;gt; &amp;lt;!--/ 匹配所有的请求；（不包括.jsp）--&amp;gt; &amp;lt;!--/* 匹配所有的请求；（包括.jsp）--&amp;gt; &amp;lt;servlet-mapping&amp;gt; &amp;lt;servlet-name&amp;gt;springmvc&amp;lt;/servlet-name&amp;gt; &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt; &amp;lt;/servlet-mapping&amp;gt; &amp;lt;/web-app&amp;gt; 编写SpringMVC 的 配置文件 名称：springmvc-servlet.xml : [servletname]-servlet.xml
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt;&amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&amp;#34;&amp;gt; &amp;lt;/beans&amp;gt; 添加 处理映射器 &amp;lt;bean class=&amp;#34;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&amp;#34;/&amp;gt; 添加 处理器适配器 &amp;lt;bean class=&amp;#34;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&amp;#34;/&amp;gt; 添加 视图解析器 &amp;lt;!</description>
    </item>
    
    <item>
      <title>SpringMVC01 什么是SpringMVC</title>
      <link>https://example.com/p/springmvc01-%E4%BB%80%E4%B9%88%E6%98%AFspringmvc/</link>
      <pubDate>Tue, 09 Nov 2021 09:36:36 +0800</pubDate>
      
      <guid>https://example.com/p/springmvc01-%E4%BB%80%E4%B9%88%E6%98%AFspringmvc/</guid>
      <description>什么是SpringMVC 回顾MVC 什么是MVC  MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。 是将业务逻辑、数据、显示分离的方法来组织代码。 MVC主要作用是降低了视图与业务逻辑间的双向偶合。 MVC不是一种设计模式，MVC是一种架构模式。当然不同的MVC存在差异。  **Model（模型）：**数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。
**View（视图）：**负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。
**Controller（控制器）：**接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。
最典型的MVC就是JSP + servlet + javabean的模式。
Model1时代  在web早期的开发中，通常采用的都是Model1。 Model1中，主要分为两层，视图层和模型层。  Model1优点：架构简单，比较适合小型项目开发；
Model1缺点：JSP职责不单一，职责过重，不便于维护；
Model2时代 Model2把一个项目分成三部分，包括视图、控制、模型。
 用户发请求 Servlet接收请求数据，并调用对应的业务逻辑方法 业务处理完毕，返回更新后的数据给servlet servlet转向到JSP，由JSP来渲染页面 响应给前端更新后的页面  职责分析： Controller：控制器
 取得表单数据 调用业务逻辑 转向指定的页面  Model：模型
 业务逻辑 保存数据的状态  View：视图
 显示页面  Model2这样不仅提高的代码的复用率与项目的扩展性，且大大降低了项目的维护成本。Model 1模式的实现比较简单，适用于快速开发小规模项目，Model1中JSP页面身兼View和Controller两种角色，将控制逻辑和表现逻辑混杂在一起，从而导致代码的重用性非常低，增加了应用的扩展性和维护的难度。Model2消除了Model1的缺点。
回顾Servlet   新建一个Maven工程当做父工程！pom依赖！
&amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.1.9.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.</description>
    </item>
    
    <item>
      <title>Spring08 整合MyBatis</title>
      <link>https://example.com/p/spring08-%E6%95%B4%E5%90%88mybatis/</link>
      <pubDate>Tue, 09 Nov 2021 09:28:49 +0800</pubDate>
      
      <guid>https://example.com/p/spring08-%E6%95%B4%E5%90%88mybatis/</guid>
      <description>整合MyBatis
 步骤  1、导入相关jar包
junit
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; mybatis
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.5.2&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; mysql-connector-java
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.1.47&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; spring相关
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.1.10.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-jdbc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.1.10.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; aspectJ AOP 织入器
&amp;lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.aspectj&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;aspectjweaver&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.9.4&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; mybatis-spring整合包 【重点】
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis-spring&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.0.2&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 配置Maven静态资源过滤问题！
&amp;lt;build&amp;gt; &amp;lt;resources&amp;gt; &amp;lt;resource&amp;gt; &amp;lt;directory&amp;gt;src/main/java&amp;lt;/directory&amp;gt; &amp;lt;includes&amp;gt; &amp;lt;include&amp;gt;**/*.properties&amp;lt;/include&amp;gt; &amp;lt;include&amp;gt;**/*.xml&amp;lt;/include&amp;gt; &amp;lt;/includes&amp;gt; &amp;lt;filtering&amp;gt;true&amp;lt;/filtering&amp;gt; &amp;lt;/resource&amp;gt; &amp;lt;/resources&amp;gt; &amp;lt;/build&amp;gt; 2、编写配置文件
3、代码实现
 回忆MyBatis  编写pojo实体类</description>
    </item>
    
    <item>
      <title>Spring09 声明式事务</title>
      <link>https://example.com/p/spring09-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Tue, 09 Nov 2021 09:27:01 +0800</pubDate>
      
      <guid>https://example.com/p/spring09-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1/</guid>
      <description>声明式事务 回顾事务  事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！ 事务管理是企业级应用程序开发中必备技术，用来确保数据的完整性和一致性。  事务就是把一系列的动作当成一个独立的工作单元，这些动作要么全部完成，要么全部不起作用。
事务四个属性ACID 原子性（atomicity）  事务是原子性操作，由一系列动作组成，事务的原子性确保动作要么全部完成，要么完全不起作用  一致性（consistency）  一旦所有事务动作完成，事务就要被提交。数据和资源处于一种满足业务规则的一致性状态中  隔离性（isolation）  可能多个事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏  持久性（durability）  事务一旦完成，无论系统发生什么错误，结果都不会受到影响。通常情况下，事务的结果被写到持久化存储器中  测试 将上面的代码拷贝到一个新项目中
在之前的案例中，我们给userDao接口新增两个方法，删除和增加用户；
//添加一个用户 int addUser(User user); //根据id删除用户 int deleteUser(int id); mapper文件，我们故意把 deletes 写错，测试！
&amp;lt;insert id=&amp;#34;addUser&amp;#34; parameterType=&amp;#34;com.kuang.pojo.User&amp;#34;&amp;gt; insert into user (id,name,pwd) values (#{id},#{name},#{pwd}) &amp;lt;/insert&amp;gt; &amp;lt;delete id=&amp;#34;deleteUser&amp;#34; parameterType=&amp;#34;int&amp;#34;&amp;gt; deletes from user where id = #{id} &amp;lt;/delete&amp;gt; 编写接口的实现类，在实现类中，我们去操作一波
public class UserDaoImpl extends SqlSessionDaoSupport implements UserMapper { //增加一些操作  public List&amp;lt;User&amp;gt; selectUser() { User user = new User(4,&amp;#34;小明&amp;#34;,&amp;#34;123456&amp;#34;); UserMapper mapper = getSqlSession().</description>
    </item>
    
    <item>
      <title>API返回值去除为NULL的字段</title>
      <link>https://example.com/p/api%E8%BF%94%E5%9B%9E%E5%80%BC%E5%8E%BB%E9%99%A4%E4%B8%BAnull%E7%9A%84%E5%AD%97%E6%AE%B5/</link>
      <pubDate>Sat, 06 Nov 2021 18:40:41 +0800</pubDate>
      
      <guid>https://example.com/p/api%E8%BF%94%E5%9B%9E%E5%80%BC%E5%8E%BB%E9%99%A4%E4%B8%BAnull%E7%9A%84%E5%AD%97%E6%AE%B5/</guid>
      <description>API返回值去除为NULL的字段 简介 在前后端分离的微服务时代，后端API需要良好的规范。本篇主要将一个数据返回时的一个小技巧&amp;ndash; 过滤为空字段 解决痛点：将有效解决数据传输过程中的流量浪费。
组件简介 Jackson ObjectMapper 通过自定义配置该组件可以选择性序列化返回的JSON。
官方解释 Spring MVC（客户端和服务器端）用于HttpMessageConverters在HTTP交换中协商内容转换。如果Jackson在类路径上，您已经获得了提供的默认转换器Jackson2ObjectMapperBuilder，其中一个实例是为您自动配置的。 Spring Boot还具有一些功能，可以更轻松地自定义此行为。
实战代码 创建配置类 首先创建一个配置类，加入定义为：JacksonConfig
代码清单 import com.fasterxml.jackson.annotation.JsonInclude; import com.fasterxml.jackson.databind.ObjectMapper; import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Primary; import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder; /** * @author ybakiame * @description 返回json空值去掉null和&amp;#34;&amp;#34; * * 注解 @Configuration 注入后可自动配置 */ @Configuration public class JacksonConfig { @Bean @Primary @ConditionalOnMissingBean(ObjectMapper.class) public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) { ObjectMapper objectMapper = builder.createXmlMapper(false).build(); objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); return objectMapper; } } 关键点：objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); 通过该方法对mapper对象进行设置，所有序列化的对象都将按改规则进行系列化。 其中枚举属性：JsonInclude.Include.NON_NULL有以下选择：</description>
    </item>
    
    <item>
      <title>Maven项目xml过滤</title>
      <link>https://example.com/p/maven%E9%A1%B9%E7%9B%AExml%E8%BF%87%E6%BB%A4/</link>
      <pubDate>Tue, 26 Oct 2021 22:14:13 +0800</pubDate>
      
      <guid>https://example.com/p/maven%E9%A1%B9%E7%9B%AExml%E8%BF%87%E6%BB%A4/</guid>
      <description>在 pom.xml 中添加
&amp;lt;build&amp;gt; &amp;lt;!--在进行模块化开发打jar包时，maven会将非java文件过滤掉，例如xml,properties等配置文件。--&amp;gt; &amp;lt;resources&amp;gt; &amp;lt;resource&amp;gt; &amp;lt;directory&amp;gt;src/main/java&amp;lt;/directory&amp;gt; &amp;lt;includes&amp;gt; &amp;lt;include&amp;gt;**/*.properties&amp;lt;/include&amp;gt; &amp;lt;include&amp;gt;**/*.xml&amp;lt;/include&amp;gt; &amp;lt;/includes&amp;gt; &amp;lt;filtering&amp;gt;false&amp;lt;/filtering&amp;gt; &amp;lt;/resource&amp;gt; &amp;lt;resource&amp;gt; &amp;lt;directory&amp;gt;src/main/resources&amp;lt;/directory&amp;gt; &amp;lt;includes&amp;gt; &amp;lt;include&amp;gt;**/*.properties&amp;lt;/include&amp;gt; &amp;lt;include&amp;gt;**/*.xml&amp;lt;/include&amp;gt; &amp;lt;/includes&amp;gt; &amp;lt;filtering&amp;gt;false&amp;lt;/filtering&amp;gt; &amp;lt;/resource&amp;gt; &amp;lt;/resources&amp;gt; &amp;lt;/build&amp;gt; </description>
    </item>
    
    <item>
      <title>Mybatis Generator使用</title>
      <link>https://example.com/p/mybatis-generator%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 26 Oct 2021 19:34:24 +0800</pubDate>
      
      <guid>https://example.com/p/mybatis-generator%E4%BD%BF%E7%94%A8/</guid>
      <description>mybatis-generator 官网：https://mybatis.org/generator/
github储存库：https://github.com/mybatis/generator
什么是 mybatis-generator  MyBatis Generator (MBG) 是 MyBatis MyBatis的代码生成器。它将为所有版本的 MyBatis 生成代码。它将内省一个数据库表（或多个表）并生成可用于访问表的工件。这减少了设置对象和配置文件以与数据库表交互的初始麻烦。MBG 试图对大量简单的 CRUD（创建、检索、更新、删除）的数据库操作产生重大影响。您仍然需要为连接查询或存储过程编写 SQL 和对象代码。
 功能  MBG 生成不同风格和不同语言的代码，这取决于它的配置方式。例如，MBG 可以生成 Java 或 Kotlin 代码。MBG 可以生成与 MyBatis3 兼容的 XML - 尽管现在被认为是 MBG 的遗留用途。生成代码的较新样式不需要 XML。
根据它的配置方式，MyBatis Generator 可能会生成：
  与表结构匹配的 Java 或 Kotlin 类。这可能包括：
 匹配表主键的类（如果有主键） 匹配表的非主键字段的类（BLOB 字段除外） 一个包含表的 BLOB 字段的类（如果表有 BLOB 字段） 启用动态选择、更新和删除的类  这些类之间有适当的继承关系。请注意，生成器可以配置为生成不同类型的 POJO 层次结构 - 例如，如果您愿意，您可以选择为每个表生成单个域对象。
  在某些情况下，MBG 会生成 MyBatis3 Compatible SQL Map XML Files。MBG 为配置中的每个表上的简单 CRUD 函数生成 SQL。生成的 SQL 语句包括：</description>
    </item>
    
    <item>
      <title>Java命名规范参考</title>
      <link>https://example.com/p/java%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E5%8F%82%E8%80%83/</link>
      <pubDate>Sat, 23 Oct 2021 22:26:26 +0800</pubDate>
      
      <guid>https://example.com/p/java%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E5%8F%82%E8%80%83/</guid>
      <description>Java命名规范参考！ 文章摘自https://www.cnblogs.com/liqiangchn/p/12000361.html
简洁清爽的代码风格应该是大多数工程师所期待的。在工作中笔者常常因为起名字而纠结，夸张点可以说是编程5分钟，命名两小时！究竟为什么命名成为了工作中的拦路虎。
每个公司都有不同的标准，目的是为了保持统一，减少沟通成本，提升团队研发效能。所以本文中是笔者结合阿里巴巴开发规范，以及工作中的见闻针对Java领域相关命名进行整理和总结，仅供参考。
Java中的命名规范 好的命名能体现出代码的特征，含义或者是用途，让阅读者可以根据名称的含义快速厘清程序的脉络。不同语言中采用的命名形式大相径庭，Java中常用到的命名形式共有三种，既首字母大写的UpperCamelCase，首字母小写的lowerCamelCase以及全部大写的并用下划线分割单词的UPPER_CAMEL_UNSER_SCORE。通常约定，类一般采用大驼峰命名，方法和局部变量使用小驼峰命名，而大写下划线命名通常是常量和枚举中使用。
   类型 约束 例     项目名 全部小写，多个单词用中划线分隔‘-’ spring-cloud   包名 全部小写 com.alibaba.fastjson   类名 单词首字母大写 Feature, ParserConfig,DefaultFieldDeserializer   变量名 首字母小写，多个单词组成时，除首个单词，其他单词首字母都要大写 password, userName   常量名 全部大写，多个单词，用&#39;_&amp;lsquo;分隔 CACHE_EXPIRED_TIME   方法 同变量 read(), readObject(), getById()    包命名 包名统一使用小写，点分隔符之间有且仅有一个自然语义的英文单词或者多个单词自然连接到一块（如 springframework，deepspace不需要使用任何分割）。包名统一使用单数形式，如果类命有复数含义，则可以使用复数形式。
包名的构成可以分为以下几四部分【前缀】 【发起者名】【项目名】【模块名】。常见的前缀可以分为以下几种：
   前缀名 例 含义     indi（或onem ） indi.发起者名.项目名.模块名.…… 个体项目，指个人发起，但非自己独自完成的项目，可公开或私有项目，copyright主要属于发起者。   pers pers.</description>
    </item>
    
    <item>
      <title>springMVC实现restful风格</title>
      <link>https://example.com/p/springmvc%E5%AE%9E%E7%8E%B0restful%E9%A3%8E%E6%A0%BC/</link>
      <pubDate>Thu, 21 Oct 2021 21:51:22 +0800</pubDate>
      
      <guid>https://example.com/p/springmvc%E5%AE%9E%E7%8E%B0restful%E9%A3%8E%E6%A0%BC/</guid>
      <description>1、REST的概念 REST为“Representational State Transfer”的缩写，中文释义为“表现层状态转换”，REST不是一种标准，而是一种设计风格。是目前最流行的一种互联网软件架构风格。它倡导结构清晰、符合标准、易于理解、扩展方便的Web架构体系，主张严格按照HTTP协议中定义的规范设计结构严谨的Web应用架构体系。由于REST所倡导的理念让Web应用更易于开发和维护，更加优雅简洁，所以正得到越来越多网站的采用。
  资源（Resources）：网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的存在。可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的 URI 。要获取这个资源，访问它的URI就可以，因此 URI 即为每一个资源的独一无二的识别符。
  表现层（Representation）：把资源具体呈现出来的形式，叫做它的表现层（Representation）。比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式。
  状态转化
（State Transfer）：每发出一个请求，就代表了客户端和服务器的一次交互过程。HTTP协议，是一个无状态协议，即所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生“状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是 “表现层状态转化”。
具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：
 GET 用来获取资源 POST 用来新建资源 PUT 用来更新资源 DELETE 用来删除资源       HTTP方法名 使用场景 资源操作 是否幂等 是否安全     GET 从服务器取出资源（一项或多项） SELECT 是 是   POST 在服务器新建一个资源 INSERT 否 否   PUT 在服务器更新资源（客户端提供完整资源数据） UPDATE 是 否   DELETE 从服务器删除资源 DELETE 是 否     幂等性：对同一REST接口的多次访问，得到的资源状态是相同的。 安全性：对该REST接口访问，不会使服务器端资源的状态发生改变。   RESTful：就是符合REST原则的架构方式即可称为RESTful。</description>
    </item>
    
    <item>
      <title>SpringMvc静态资源过滤</title>
      <link>https://example.com/p/springmvc%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%BF%87%E6%BB%A4/</link>
      <pubDate>Thu, 21 Oct 2021 20:07:06 +0800</pubDate>
      
      <guid>https://example.com/p/springmvc%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%BF%87%E6%BB%A4/</guid>
      <description>配置DispatcherServlet 在进行Spring MVC的配置时，通常会配置一个dispatcher-servlet.xml用于处理对应的URL。web.xml中配置如下：
&amp;lt;!--springmvc默认拦截器拦截请求--&amp;gt; &amp;lt;servlet&amp;gt; &amp;lt;servlet-name&amp;gt;SpringMVC&amp;lt;/servlet-name&amp;gt; &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;classpath:dispatcher-servlet.xml&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;!--tomcat启动时立即初始化拦截器--&amp;gt; &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt; &amp;lt;/servlet&amp;gt; &amp;lt;servlet-mapping&amp;gt; &amp;lt;!-- url-pattern拦截地址的区别 / 会匹配url请求/index等 ,也会匹配静态资源*.js,*.html等, 不会匹配*.jsp文件。 /* 会匹配url请求/index等 ,也会匹配静态资源*.js,*.html等, 会匹配*.jsp文件。 在实际开发中可能遇到 *.do、*.cation 等拦截代后缀的请求 --&amp;gt; &amp;lt;servlet-name&amp;gt;SpringMVC&amp;lt;/servlet-name&amp;gt; &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt; &amp;lt;!-- 只拦截.do请求 &amp;lt;url-pattern&amp;gt;*.do&amp;lt;/url-pattern&amp;gt; --&amp;gt; &amp;lt;/servlet-mapping&amp;gt; 优雅 REST 风格的 URL 不希望带 .html 或 .do 等后缀，而如果将 DispatcherServlet 请求映射配置为&amp;quot;/&amp;quot;，则Spring MVC将捕获Web容器所有的请求，静态资源的请求找不到对应处理器将导致错误。
springMvc过滤静态资源文件 1、使用Tomcat的defaultServlet来处理静态文件 web.xml里添加如下的配置
&amp;lt;!--在springmvc拦截所有请求之前放行所有静态资源文件--&amp;gt; &amp;lt;!--每一个&amp;lt;url-pattern&amp;gt;代表一种静态资源文件--&amp;gt; &amp;lt;servlet-mapping&amp;gt; &amp;lt;servlet-name&amp;gt;default&amp;lt;/servlet-name&amp;gt; &amp;lt;url-pattern&amp;gt;*.html&amp;lt;/url-pattern&amp;gt; &amp;lt;url-pattern&amp;gt;*.css&amp;lt;/url-pattern&amp;gt; &amp;lt;url-pattern&amp;gt;*.js&amp;lt;/url-pattern&amp;gt; &amp;lt;url-pattern&amp;gt;*.ico&amp;lt;/url-pattern&amp;gt; &amp;lt;url-pattern&amp;gt;*.jpg&amp;lt;/url-pattern&amp;gt; &amp;lt;url-pattern&amp;gt;*.png&amp;lt;/url-pattern&amp;gt; &amp;lt;url-pattern&amp;gt;*.gif&amp;lt;/url-pattern&amp;gt; &amp;lt;/servlet-mapping&amp;gt;  要写在DispatcherServlet的前面， 让defaultServlet先拦截，这个就不会进入Spring了，我想性能是最好的吧。
 Tomcat, Jetty, JBoss, and GlassFish 默认 Servlet的名字 &amp;ndash; &amp;ldquo;default&amp;rdquo; Google App Engine 默认 Servlet的名字 &amp;ndash; &amp;ldquo;_ah_default&amp;rdquo; Resin 默认 Servlet的名字 &amp;ndash; &amp;ldquo;resin-file&amp;rdquo; WebLogic 默认 Servlet的名字 &amp;ndash; &amp;ldquo;FileServlet&amp;rdquo; WebSphere 默认 Servlet的名字 &amp;ndash; &amp;ldquo;SimpleFileServlet&amp;rdquo;   2、使用&amp;lt;mvc:resources&amp;gt;标签 在dispatcher-servlet.</description>
    </item>
    
    <item>
      <title>Java中的Date和Mysql中的datetime</title>
      <link>https://example.com/p/java%E4%B8%AD%E7%9A%84date%E5%92%8Cmysql%E4%B8%AD%E7%9A%84datetime/</link>
      <pubDate>Tue, 19 Oct 2021 21:16:55 +0800</pubDate>
      
      <guid>https://example.com/p/java%E4%B8%AD%E7%9A%84date%E5%92%8Cmysql%E4%B8%AD%E7%9A%84datetime/</guid>
      <description>java中的date 1、java.sql.date   格式为``2016-02-01` 是针对SQL语句使用的，它只包含日期而没有时间部分 一般是在数据库的时间字段   2、java.util.date   格式为 Wed Oct 20 15:02:35 CST 2021 在除SQL语句外的情况下面使用 一般是日常日期字段   sqlDate和UtilDate 1、java.util.Date 是 java.sql.Date 的父类 2、相互转化 java.sql.Date sqlDate=new Java.sql.Date(); java.util.Date utilDate=new java.util.Date (sqlDate.getTime()); 3、继承关系  java.lang.Object -&amp;gt; java.util.Date -&amp;gt; java.sql.Date
 4、 使用环境   java.sql.Date主要是用于sql中！ java.util.Date一般的环境下都可以使用！    5、转化 SimpleDateFormat bartDateFormat = new SimpleDateFormat(&amp;#34;yyyy-MM-dd&amp;#34;); String dateStringToParse = &amp;#34;2007-7-12&amp;#34;; //utilDate to sqlDate  try { //使用符合格式的字符串构建一个utilDate  java.</description>
    </item>
    
    <item>
      <title>Mybatis报错解决合集</title>
      <link>https://example.com/p/mybatis%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E5%90%88%E9%9B%86/</link>
      <pubDate>Tue, 19 Oct 2021 19:43:35 +0800</pubDate>
      
      <guid>https://example.com/p/mybatis%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E5%90%88%E9%9B%86/</guid>
      <description>根报错 Cause: com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure org.apache.ibatis.exceptions.PersistenceException: ### Error querying database. Cause: com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure The last packet successfully received from the server was 128 milliseconds ago. The last packet sent successfully to the server was 125 milliseconds ago. ### The error may exist in com/xxgc/mybatis/mapper/MoneyMapper.java (best guess) ### The error may involve com.xxgc.mybatis.mapper.MoneyMapper.selectMoneyAndUser_COUNT ### The error occurred while executing a query ### Cause: com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure The last packet successfully received from the server was 128 milliseconds ago.</description>
    </item>
    
    <item>
      <title>jackson</title>
      <link>https://example.com/p/jackson/</link>
      <pubDate>Tue, 19 Oct 2021 14:48:39 +0800</pubDate>
      
      <guid>https://example.com/p/jackson/</guid>
      <description>jackson maven引入依赖 &amp;lt;!-- object to json Gson是Google所维护，功能全。 JackSon是Spring的御用工具，和Spring无缝集成，提供灵活的定制化开发的注解。 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jackson-databind&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.13.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; jackson-databind 依赖 jackson-core 和 jackson-annotations，可以只显示地添加jackson-databind依赖，jackson-core 和 jackson-annotations 也随之添加到 Java 项目工程中。
创建 ObjectMapper Jackson 最常用的 API 就是基于&amp;quot;对象绑定&amp;quot; 的 ObjectMapper：
 ObjectMapper可以从字符串，流或文件中解析JSON，并创建表示已解析的JSON的Java对象。 将JSON解析为Java对象也称为从JSON反序列化Java对象。 ObjectMapper也可以从Java对象创建JSON。 从Java对象生成JSON也称为将Java对象序列化为JSON。 Object映射器可以将JSON解析为自定义的类的对象，也可以解析置JSON树模型的对象。  之所以称为ObjectMapper是因为它将JSON映射到Java对象（反序列化），或者将Java对象映射到JSON（序列化）。
将 java Object转化为 json 字符串 ObjectMapper objectMapper = new ObjectMapper(); String json = objectMapper.writeValueAsString(要转化为json的对象); System.out.println(json);//打印转化后的json对象 参考</description>
    </item>
    
    <item>
      <title>java 反射</title>
      <link>https://example.com/p/java-%E5%8F%8D%E5%B0%84/</link>
      <pubDate>Tue, 19 Oct 2021 14:48:39 +0800</pubDate>
      
      <guid>https://example.com/p/java-%E5%8F%8D%E5%B0%84/</guid>
      <description>Java反射 什么是反射？ 反射就是Reflection，Java的反射是指程序在运行期可以拿到一个对象的所有信息。通过Class实例获取class信息的方法称为反射（Reflection）。
如何获取一个class的Class实例？有三个方法： 方法一：直接通过一个class的静态变量class获取：
Class cls = String.class; 方法二：如果我们有一个实例变量，可以通过该实例变量提供的getClass()方法获取：
String s = &amp;#34;Hello&amp;#34;; Class cls = s.getClass(); 方法三：如果知道一个class的完整类名，可以通过静态方法Class.forName()获取：
Class cls = Class.forName(&amp;#34;java.lang.String&amp;#34;); 注意Class实例和instanceof的差别： Integer n = new Integer(123); boolean b1 = n instanceof Integer; // true，因为n是Integer类型 boolean b2 = n instanceof Number; // true，因为n是Number类型的子类  boolean b3 = n.getClass() == Integer.class; // true，因为n.getClass()返回Integer.class boolean b4 = n.getClass() == Number.class; // false，因为Integer.class!=Number.class 用instanceof不但匹配指定类型，还匹配指定类型的子类。而用==判断class实例可以精确地判断数据类型，但不能作子类型比较。
通常情况下，我们应该用instanceof判断数据类型，因为面向抽象编程的时候，我们不关心具体的子类型。只有在需要精确判断一个类型是不是某个class的时候，我们才使用==判断class实例。
因为反射的目的是为了获得某个实例的信息。因此，可以通过Object.getClass()方法获取的class`信息：
动态加载 JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。例如：
// Main.java public class Main { public static void main(String[] args) { if (args.</description>
    </item>
    
    <item>
      <title>java 注解</title>
      <link>https://example.com/p/java-%E6%B3%A8%E8%A7%A3/</link>
      <pubDate>Tue, 19 Oct 2021 14:48:39 +0800</pubDate>
      
      <guid>https://example.com/p/java-%E6%B3%A8%E8%A7%A3/</guid>
      <description>Java注解 什么是注解（Annotation）？注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”：
使用注解 // this is a component: @Resource(&amp;quot;hello&amp;quot;) public class Hello { @Inject int n; @PostConstruct public void hello(@Param String name) { System.out.println(name); } @Override public String toString() { return &amp;quot;Hello&amp;quot;; } } 注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。
注解的作用 从JVM的角度看，注解本身对代码逻辑没有任何影响，如何使用注解完全由工具决定。
Java的注解可以分为三类：
第一类是由编译器使用的注解，例如：
 @Override：让编译器检查该方法是否正确地实现了覆写； @SuppressWarnings：告诉编译器忽略此处代码产生的警告。  这类注解不会被编译进入.class文件，它们在编译后就被编译器扔掉了。
第二类是由工具处理.class文件使用的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入.class文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。
第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了@PostConstruct的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。
定义一个注解时，还可以定义配置参数。配置参数可以包括：
 所有基本类型； String； 枚举类型； 基本类型、String、Class以及枚举的数组。  因为配置参数必须是常量，所以，上述限制保证了注解在定义时就已经确定了每个参数的值。
注解的配置参数可以有默认值，缺少某个配置参数时将使用默认值。
此外，大部分注解会有一个名为value的配置参数，对此参数赋值，可以只写常量，相当于省略了value参数。
如果只写注解，相当于全部使用默认值。
举个栗子，对以下代码：
public class Hello { @Check(min=0, max=100, value=55) public int n; @Check(value=99) public int p; @Check(99) // @Check(value=99) public int x; @Check public int y; } @Check就是一个注解。第一个@Check(min=0, max=100, value=55)明确定义了三个参数，第二个@Check(value=99)只定义了一个value参数，它实际上和@Check(99)是完全一样的。最后一个@Check表示所有参数都使用默认值。</description>
    </item>
    
    <item>
      <title>java 笔记</title>
      <link>https://example.com/p/java-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 19 Oct 2021 14:48:39 +0800</pubDate>
      
      <guid>https://example.com/p/java-%E7%AC%94%E8%AE%B0/</guid>
      <description>：java语言的概述 计算机语言分为：编译型和解释型 图形化界面（GUI）和命令行方式。  DOS命令 dir,md,rd,cd,cd..,cd /,del,exit,ipconfig,ping   语言的进化：  第一代：机器语言 第二代：汇编语言 第三代：高级语言   Java语言的特征： JDK、PATH环境变量、classpath  JDK: PATH:WINDOWS操作系统在执行命令时所要搜索的路径。 CLASSPATH:JVM虚拟机，查找类的路径。   public class HelloWorld{  	public static void main(String[] args){
	System.out.println(&amp;ldquo;HelloWorld&amp;rdquo;);
	}
}
6.1.源文件扩展名”java”,编译以后生成文件的扩展名class
6.2一个源文件里面只能有一个public类，其他类个数不限。如果源文件中包含public类，文件名必须同public类名保持一致。
6.3java程序的入口是main()方法。不去main（）方法的写法是“较为”固定。
6.4java语音是严格区分大小写。
6.5java语音的语句是以“;”(半角状态的分号)
6.6语句使用｛｝括起，成对出现。
  Javac 和java
  注释：
 //:单行注释 /* */ :多行注释（多行注释不能够嵌套） /** */:文档注释 javadoc -d 文件目录名 源文件名.java    如何查看API.
  ：基本语法：</description>
    </item>
    
    <item>
      <title>Mysql索引</title>
      <link>https://example.com/p/mysql%E7%B4%A2%E5%BC%95/</link>
      <pubDate>Sat, 02 Oct 2021 11:39:05 +0800</pubDate>
      
      <guid>https://example.com/p/mysql%E7%B4%A2%E5%BC%95/</guid>
      <description>优点   索引大大减小了服务器需要扫描的数据量
  索引可以帮助服务器避免排序和临时表
  索引可以将随机IO变成顺序IO
  索引对于InnoDB（对索引支持行级锁）非常重要，因为它可以让查询锁更少的元组。在MySQL5.1和更新的版本中，InnoDB可以在服务器端过滤掉行后就释放锁，但在早期的MySQL版本中，InnoDB直到事务提交时才会解锁。对不需要的元组的加锁，会增加锁的开销，降低并发性。 InnoDB仅对需要访问的元组加锁，而索引能够减少InnoDB访问的元组数。但是只有在存储引擎层过滤掉那些不需要的数据才能达到这种目的。一旦索引不允许InnoDB那样做（即索引达不到过滤的目的），MySQL服务器只能对InnoDB返回的数据进行WHERE操作，此时，已经无法避免对那些元组加锁了。如果查询不能使用索引，MySQL会进行全表扫描，并锁住每一个元组，不管是否真正需要。
关于InnoDB、索引和锁：InnoDB在二级索引上使用共享锁（读锁），但访问主键索引需要排他锁（写锁）
  缺点  虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存索引文件。 建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。 如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。 对于非常小的表，大部分情况下简单的全表扫描更高效；  索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句。因此应该只为最经常查询和最经常排序的数据列建立索引。
MySQL里同一个数据表里的索引总数限制为16个。
索引的分类 在一个表中，主键索引只能有一个，唯一索引可以有多个。
 主键索引（PRIMARY KEY）  唯一的标识，主键不可重复，只能有一个列作为主键   唯一索引（UNIQUE KEY）  避免重读的列出现，唯一索引可以重复，多个列都可以标识为唯一索引   常规索引（KEY / INDEX）  默认的，通过index或key关键字来设置   全文索引（FULLTEXT）  在特定的数据库引擎下采用，之前只有MYISAM有 快速定位数据    基础语法
-- 索引的使用 -- 方式1：在创建表的时候给字段增加索引 -- 方式2：表创建完毕后，增加索引 -- 显示所有的索引信息 SHOWINDEXFROM`student`-- 增加一个全文索引：格式：索引类型 索引名（列名），主键索引只要有索引名就行了 ALTERTABLE`school`.`student`ADDFULLTEXTINDEX`StudentName`(`StudentName`)-- 删除索引 DROPINDEX索引名ON表名-- EXPLAIN分析sql执行的情况 EXPLAINSELECT*FROM`student`;-- 非全文索引 EXPLAINSELECT*FROM`student`WHEREMATCH(`StudentName`)AGAINST(&amp;#39;郭&amp;#39;)-- 通过全文索引进行查找 创建表结构 CREATETABLE`demo`.</description>
    </item>
    
    <item>
      <title>Mysql存储过程</title>
      <link>https://example.com/p/mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Wed, 29 Sep 2021 17:06:44 +0800</pubDate>
      
      <guid>https://example.com/p/mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</guid>
      <description>什么是存储过程 是一种在数据库中存储复杂程序，以便外部调用的一种数据库对象 存储过程思想上很简单，就是数据库SQL语言层面的代码封装与重用。
优点  可封装，并隐藏复杂的商业逻辑。 并可以接受参数，可以有返回值。 存储过程无法使用 SELECT 指令来运行，因为它是子程序，与查看表，数据表或用户定义函数不同。 存储过程可以用在数据检验，强制实行商业逻辑等。  缺点  存储过程，往往定制化于特定的数据库上，因为支持的编程语言不同。当切换到其他厂商的数据库系统时，需要重写原有的存储过程。 存储过程的性能调校与撰写，受限于各种数据库系统。  声明一个存储过程 DELIMITER$$CREATE-- 声明一个储存过程 PROCEDURE 库名.函数名(参数) -- in：这个参数是一个传入值 -- out：这个参数是个返回值 -- outin：表示这个参数既是输入值，也是返回值（使用时需要传入的是变量，而不是一个确切的数值） PROCEDURE`demo`.</description>
    </item>
    
    <item>
      <title>Mysql函数</title>
      <link>https://example.com/p/mysql%E5%87%BD%E6%95%B0/</link>
      <pubDate>Tue, 28 Sep 2021 23:11:13 +0800</pubDate>
      
      <guid>https://example.com/p/mysql%E5%87%BD%E6%95%B0/</guid>
      <description>什么是函数？ 函数类似于Java方法，可以传值，也有返回值，配合查询做一些复杂计算。
创建一个自定义函数 DELIMITER$$CREATE/*函数 库+函数名(参数名 类型)*/FUNCTION`demo`.`usermoney`(numberINT)/*返回值类型(varchar类型需要指定长度)*/RETURNSINT/*开始*/BEGIN/*返回 要执行的sql语句*/RETURN(number*100);/*结束*/END$$DELIMITER;函数的使用 select之后接函数名(参数)，与mysql内置函数使用方法一致
SELECTusermoney(`u_money`)FROM`users`在函数中创建变量 变量的声明需要放在要执行的sql语句的头部
/*创建一个变量 使用 DECLARE 关键字*/DECLAREnewmenberVARCHAR(30)DEFAULT&amp;#34;普通用户&amp;#34;;mysql内置常用函数 MySQL 数值型函数    函数名称 作 用     ABS 求绝对值   SQRT 求二次方根   MOD 求余数   CEIL 和 CEILING 两个函数功能相同，都是返回不小于参数的最小整数，即向上取整   FLOOR 向下取整，返回值转化为一个BIGINT   RAND 生成一个0~1之间的随机数，传入整数参数是，用来产生重复序列   ROUND 对所传参数进行四舍五入   SIGN 返回参数的符号   POW 和 POWER 两个函数的功能相同，都是所传参数的次方的结果值   SIN 求正弦值   ASIN 求反正弦值，与函数 SIN 互为反函数   COS 求余弦值   ACOS 求反余弦值，与函数 COS 互为反函数   TAN 求正切值   ATAN 求反正切值，与函数 TAN 互为反函数   COT 求余切值    MySQL 字符串函数    函数名称 作 用     LENGTH 计算字符串长度函数，返回字符串的字节长度   CONCAT 合并字符串函数，返回结果为连接参数产生的字符串，参数可以使一个或多个   INSERT 替换字符串函数   LOWER 将字符串中的字母转换为小写   UPPER 将字符串中的字母转换为大写   LEFT 从左侧字截取符串，返回字符串左边的若干个字符   RIGHT 从右侧字截取符串，返回字符串右边的若干个字符   TRIM 删除字符串左右两侧的空格   REPLACE 字符串替换函数，返回替换后的新字符串   SUBSTRING 截取字符串，返回从指定位置开始的指定长度的字符换   REVERSE 字符串反转（逆序）函数，返回与原始字符串顺序相反的字符串    MySQL 日期和时间函数    函数名称 作 用     CURDATE 和 CURRENT_DATE 两个函数作用相同，返回当前系统的日期值   CURTIME 和 CURRENT_TIME 两个函数作用相同，返回当前系统的时间值   NOW 和 SYSDATE 两个函数作用相同，返回当前系统的日期和时间值   UNIX_TIMESTAMP 获取UNIX时间戳函数，返回一个以 UNIX 时间戳为基础的无符号整数   FROM_UNIXTIME 将 UNIX 时间戳转换为时间格式，与UNIX_TIMESTAMP互为反函数   MONTH 获取指定日期中的月份   MONTHNAME 获取指定日期中的月份英文名称   DAYNAME 获取指定曰期对应的星期几的英文名称   DAYOFWEEK 获取指定日期对应的一周的索引位置值   WEEK 获取指定日期是一年中的第几周，返回值的范围是否为 0〜52 或 1〜53   DAYOFYEAR 获取指定曰期是一年中的第几天，返回值范围是1~366   DAYOFMONTH 获取指定日期是一个月中是第几天，返回值范围是1~31   YEAR 获取年份，返回值范围是 1970〜2069   TIME_TO_SEC 将时间参数转换为秒数   SEC_TO_TIME 将秒数转换为时间，与TIME_TO_SEC 互为反函数   DATE_ADD 和 ADDDATE 两个函数功能相同，都是向日期添加指定的时间间隔   DATE_SUB 和 SUBDATE 两个函数功能相同，都是向日期减去指定的时间间隔   ADDTIME 时间加法运算，在原始时间上添加指定的时间   SUBTIME 时间减法运算，在原始时间上减去指定的时间   DATEDIFF 获取两个日期之间间隔，返回参数 1 减去参数 2 的值   DATE_FORMAT 格式化指定的日期，根据参数返回指定格式的值   WEEKDAY 获取指定日期在一周内的对应的工作日索引    MySQL 聚合函数    函数名称 作用     MAX 查询指定列的最大值   MIN 查询指定列的最小值   COUNT 统计查询结果的行数   SUM 求和，返回指定列的总和   AVG 求平均值，返回指定列数据的平均值    MySQL 流程控制函数    函数名称 作用     IF 判断，流程控制   IFNULL 判断是否为空   CASE 搜索语句    </description>
    </item>
    
    <item>
      <title>Mysql事件</title>
      <link>https://example.com/p/mysql%E4%BA%8B%E4%BB%B6/</link>
      <pubDate>Mon, 27 Sep 2021 20:01:36 +0800</pubDate>
      
      <guid>https://example.com/p/mysql%E4%BA%8B%E4%BB%B6/</guid>
      <description>什么是事件？ 是MySQL5.1新增的事件也叫做定时任务，事件调度器,是一组SQL集，用来执行定时任务，跟触发器很像，都是被动执行的，事件由时间触发执行，而触发器是由事件（增删改）触发执行；
查看事件是否开启  SHOW VARIABLES LIKE &#39;event_scheduler&#39;;
开启事件:SET GLOBAL event_scheduler = ON/1; SET @@global.event_scheduler = ON/1;
关闭事件:SET GLOBAL event_scheduler = OFF/0; SET @@global.event_scheduler = OFF/0;
 查看事件  查看当前所在数据库的事件:
SHOW EVENTS; SHOW PROCESSLIST; 
查看数据库中所有的事件:
SELECT * FROM mysql.event;
 事件的控制  临时关闭/打开事件 ALTER EVENT 事件名 DISABLE/ENABLE; 删除事件 DROP EVENT 事件名;
 定时执行事件 DELIMITER$$/*创建定时事件*/CREATEEVENT`demo`.`comm`/*指定时间执行*/ONSCHEDULEAT&amp;#39;2021-09-27 16:34:00&amp;#39;/*完成时不保留启用 执行完成之后删除事件*/ONCOMPLETIONNOTPRESERVEENABLEDOBEGINUPDATE`commodity`SET`c_number`=1;END$$DELIMITER;循环执行事件 DELIMITER$$/*创建事件*/CREATEEVENT`demo`.`addmoeny`/*循环执行 间隔时间为1天*/ONSCHEDULEEVERY&amp;#39;1&amp;#39;DAY/*SECOND(秒)*//*循环的开始时间*/STARTS&amp;#39;2021-09-27 00:00:00&amp;#39;/*循环的结束时间*/ENDS&amp;#39;2022-04-29 00:00:00&amp;#39;/*完成时不保留启用*/ONCOMPLETIONNOTPRESERVEENABLE/*开始*/DOBEGINUPDATEmyuserSET`u_money`=`u_money`+10;/*结束*/END$$DELIMITER;</description>
    </item>
    
    <item>
      <title>Mysql主从数据库不同步问题</title>
      <link>https://example.com/p/mysql%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8D%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 27 Sep 2021 19:55:16 +0800</pubDate>
      
      <guid>https://example.com/p/mysql%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8D%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/</guid>
      <description>数据库主从异常问题不同步问题 数据库主从异常问题
场景描述：在使用web功能时发现刚添加的数据在列表中没有展示，或者有时候展示有时候不展示（多个从库时出现）
如何查找问题：  这时我们已经怀疑可能从库延迟了，我们需要确认下是延迟问题还是同步中断
我们需要链接到从库执行命令：
show slave status\G
来查看从库同步情况
 同步中断问题  如果Slave_IO_Running （负责与主机的io通信）
Slave_SQL_Running （负责自己的slave mysql进程）
这两个参数如果有一个是no的，说明同步已经中断了。
这时我们需要去看Last_Errno(错误码) Last_Error（错误信息），来确定什么原因导致的错误。
接下来我们可以通过以下命令跳过错误，让同步正常执行
/*停止同步*/stopslave/*设置跳过错误*/setglobalsql_slave_skip_counter=1;/*开始同步*/startslave 同步延迟问题  当我们发现Master_Log_File参数和Relay_Master_Log_File参数不一致或者Read_Master_Log_Pos和Relay_Log_Pos参数相差很大时，这表明从库延迟了
  这时我们先确认是主库导致的还是从库自身导致的，我们可以通过查看服务器负载来定位问题，使用命令top和iotop来分别查看cpu和io的使用情况
  定位到具体服务器后，在数据库中执行show full processlist来查看当前查询语句中执行时间较长的语句，定位后再做优化就可以了，有时可能慢sql已经执行完了，
  我们使用命令看不到慢sql，那我们就需要到mysql慢日志中去查看最近产生的慢日志，对慢sql进行优化
 </description>
    </item>
    
    <item>
      <title>Mysql主从数据库配置</title>
      <link>https://example.com/p/mysql%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Sun, 26 Sep 2021 21:02:53 +0800</pubDate>
      
      <guid>https://example.com/p/mysql%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE/</guid>
      <description>说明： 在项目部署到生产环境时，会有很多不可抗力的因素，数据库会出现崩溃停止运行数据丢失，数据对不上的问题，这个时候就需要两个数据库同步运行，来确保一个数据库崩溃另一个能马上顶上。
部署步骤： 在windows下部署: 配置文件位于mysql的安装目录下
在linux下部署: 配置文件位于/etc/my.cnf (不同linux发行版可能会有所不同)
配置主库    停止主库的mysql进程
net stop mysql1
  配置my.ini文件
#主数据库端ID号 server_id=1#开启二进制日志 log-bin=mysql-bin#需要复制的数据库名，如果复制多个数据库，重复设置这个选项即可(或者多个库用逗号隔开) #binlog-do-db = db #不需要复制的库，和上项同理 #binlog-ignore-db=mysql #将从服务器从主服务器收到的更新记入到从服务器自己的二进制日志文件中 #log-slave-updates #控制binlog的写入频率。每执行多少次事务写入一次(这个参数性能消耗很大，但可减小MySQL崩溃造成的损失) #sync_binlog = 1 #这个参数一般用在主主同步中，用来错开自增值, 防止键值冲突 #auto_increment_offset = 1 #这个参数一般用在主主同步中，用来错开自增值, 防止键值冲突 #auto_increment_increment = 1 #二进制日志自动删除的天数，默认值为0,表示“没有自动删除”，启动时和二进制日志循环时可能删除 #expire_logs_days = 7 #将函数复制到slave #log_bin_trust_function_creators = 1   保存修改后的配置，重启mysql服务
net start mysql
  登陆到主机的数据库，并建立一个用户给从库连接使用
允许所有ip连接GRANTREPLICATIONSLAVEON*.*TO&amp;#39;myslave&amp;#39;@&amp;#39;%&amp;#39;IDENTIFIEDBY&amp;#39;123456&amp;#39;;指定ip的做法GRANTREPLICATIONSLAVEON*.*TOmyslave@&amp;#39;192.168.41.0/255.255.255.0&amp;#39;IDENTIFIEDBY&amp;#39;123456&amp;#39;;  myslave是用户名
  123456密码是用户对应的密码
  192.168.41.0是ip地址
    更新数据库权限</description>
    </item>
    
    <item>
      <title>Mysql视图</title>
      <link>https://example.com/p/mysql%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Sun, 26 Sep 2021 20:56:53 +0800</pubDate>
      
      <guid>https://example.com/p/mysql%E8%A7%86%E5%9B%BE/</guid>
      <description>什么是视图？ mysql的视图的5.0.1版本之后开始提供的。 视图（View）是一种虚拟存在的表，并不在数据库中实际存在，视图中的数据会在使用视图时动态生成。
/*创建视图*/CREATE/*视图算法*//*[ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] 视图定义者 [DEFINER = { user | CURRENT_USER }] sql的安全性 [SQL SECURITY { DEFINER | INVOKER }]*//*数据库+视图名字*/VIEW`demo`.`statisticsview`AS/*要使用哪些数据生成视图*/(SELECTCOUNT(*)ASusers,SUM(`f_quota`)ASflowersFROM`user`,`flowers`WHERE`f_mapping_user`=`u_id`);查询视图 和普通的表查询一样，使用SELECT 即可</description>
    </item>
    
    <item>
      <title>Mysql事务</title>
      <link>https://example.com/p/mysql%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Thu, 23 Sep 2021 14:04:12 +0800</pubDate>
      
      <guid>https://example.com/p/mysql%E4%BA%8B%E5%8A%A1/</guid>
      <description>事务
  是什么是事务？ 事务就是一个完整的业务逻辑。
 举例： 假如张三向李四转账100元。
​	1）张三账户扣100元
​	2）李四的账户加100元
以上操作就是一个最小工作单元，要么同时成功要么同时失败，不可拆分。
   事务支持
 只有 INSERT DELETE UPDATE 以上三种语句和事务有关系。
   事务是如何实现同时成功或同时失败？
   &amp;gt; InnoDB存储引擎；提供一组用来记录事务性活动日志文件。 &amp;gt; &amp;gt; 提交事务： &amp;gt; &amp;gt; ​	清空事务性活动日志文件，并彻底把数据持久化到表中。 &amp;gt; &amp;gt; 回滚事务： &amp;gt; &amp;gt; ​	按文件进行回滚操作，并清空事务性活动日志文件。   如何提交事务，回滚事务？
 提交事务： COMMIT 语句
回滚事务： ROLLBACK 语句
关闭默认提交： START TRANSACTION
   事务包括4个特性
 A：原子性
​	说明事务是最小工作单元，不可再分。
C：一致性
​	所有任务要求，在同一事务当中，所有操作必须同时成功，同时失败。</description>
    </item>
    
    <item>
      <title>Mysql触发器</title>
      <link>https://example.com/p/mysql%E8%A7%A6%E5%8F%91%E5%99%A8/</link>
      <pubDate>Thu, 23 Sep 2021 13:31:02 +0800</pubDate>
      
      <guid>https://example.com/p/mysql%E8%A7%A6%E5%8F%91%E5%99%A8/</guid>
      <description>触发器的概念：
​	触发器是一种特殊的存储过程，不同于存储过程，触发器是通过事件触发执行，而不是手动调用执行的。 什么事触发事件？ 触发器（trigger），是指表中内容发生改变（增、删、改）时，系统会自动触发并执行的事件。 作用： 1、可以在触发时，校验或转换数据，保证数据安全。 2、触发器发生错误时，前面用户执行成功的操作会被回滚。 &amp;hellip;
表结构 CREATEDATABASEdemo;USE`demo`;CREATETABLE`user`(`u_id`BIGINT(18)NOTNULLAUTO_INCREMENTCOMMENT&amp;#39;用户id&amp;#39;,`u_name`VARCHAR(15)NOTNULLCOMMENT&amp;#39;用户名&amp;#39;,`u_sex`CHAR(1)NOTNULLDEFAULT&amp;#39;男&amp;#39;COMMENT&amp;#39;性别&amp;#39;,`u_createtime`DATETIMENOTNULLCOMMENT&amp;#39;创建时间&amp;#39;,`u_eff`INT(1)NOTNULLDEFAULT&amp;#39;1&amp;#39;COMMENT&amp;#39;有效&amp;#39;,PRIMARYKEY(`u_id`))CREATETABLE`flowers`(`f_id`BIGINT(18)NOTNULLAUTO_INCREMENTCOMMENT&amp;#39;花呗表id&amp;#39;,`f_credit_points`INT(4)NOTNULLCOMMENT&amp;#39;信用积分&amp;#39;,`f_quota`INT(5)NOTNULLCOMMENT&amp;#39;花呗额度&amp;#39;,`f_mapping_user`BIGINT(18)NOTNULLCOMMENT&amp;#39;用户id&amp;#39;,PRIMARYKEY(`f_id`))创建触发器 DELIMITER$$/*自定义结束符号*//*创建*/CREATE/*TRIGGER 触发器*//*库名+触发器名*//*BEFORE/AFTER 在sql之前执行还是之后执行*//*INSERT/UPDATE/DELETE触发条件*/TRIGGER`demo`.`userflowers`AFTERINSERT/*作用于哪个表*/ON`demo`.`user`/*每行都受影响，都执行，行级触发器*/FOREACHROWBEGIN/*触发执行的语句*/INSERTINTO`flowers`(`f_credit_points`,`f_quota`,`f_mapping_user`)VALUE(100,1000,new.u_id);END$$DELIMITER;执行语句 INSERTINTO`user`(`u_name`,`u_sex`,`u_createtime`)VALUE(&amp;#34;张三&amp;#34;,&amp;#34;女&amp;#34;,&amp;#34;2021-09-23 09:34:00&amp;#34;);1.   new和old的使用       INSERT 没有old只有new new表示将要插入或者已经插入的数据   UPDATE 既有old也有new old表示更新之前的数据 new表示更新之后的数据   DELETE 没有new只有old old表示删除前或已经被删除的数据    触发器条件使用if elseif else DELIMITER$$CREATETRIGGER`demo`.`userupdate`AFTERUPDATEON`demo`.`user`FOREACHROWBEGIN/*判断是否有效字段变为0*/IFnew.`u_eff`=0THEN/*删除花呗*/DELETEFROM`flowers`WHERE`f_mapping_user`=new.u_id;ELSEIFnew.`u_eff`=1THEN/*添加花呗*/INSERTINTO`flowers`(`f_credit_points`,`f_quota`,`f_mapping_user`)VALUE(100,1000,new.u_id);ELSE/*其它情况*/ENDIF;END$$DELIMITER;变量的使用 DELIMITER$$USE`demo`$$DROPTRIGGER/*!50032 IF EXISTS */`userflowers`$$CREATE/*!50017 DEFINER = &amp;#39;root&amp;#39;@&amp;#39;localhost&amp;#39; */TRIGGER`userflowers`AFTERINSERTON`user`FOREACHROWBEGIN/*触发执行的语句*/INSERTINTO`flowers`(`f_credit_points`,`f_quota`,`f_mapping_user`)VALUE(100,1000,new.u_id);/* 用户变量：以@开始，形式为 @变量名 用户变量只针对当前客户端生效 全局变量：定义方式 set GLOBAL 变量名，或者 set @@global.变量名 对所有客户端生效，但是具有super权限才可以设置全局变量 */SELECTCOUNT(*)FROMUSERINTO@num;UPDATE`statistics`SET`users`=@numWHEREs_id=1;END;$$DELIMITER;</description>
    </item>
    
    <item>
      <title>Spring07 AOP使用</title>
      <link>https://example.com/p/spring07-aop%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sat, 11 Sep 2021 17:48:58 +0800</pubDate>
      
      <guid>https://example.com/p/spring07-aop%E4%BD%BF%E7%94%A8/</guid>
      <description>AOP  什么是AOP  AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。
 Aop在Spring中的作用  提供声明式事务；允许用户自定义切面
以下名词需要了解下：
  切面(Aspect)： Aspect 声明类似于 Java 中的类声明，事务管理是AOP一个最典型的应用。在AOP中，切面一般使用 @Aspect 注解来使用，在XML 中，可以使用 &amp;lt;aop:aspect&amp;gt; 来定义一个切面。
  连接点(Join Point): 一个在程序执行期间的某一个操作，就像是执行一个方法或者处理一个异常。在Spring AOP中，一个连接点就代表了一个方法的执行。
  通知(Advice):在切面中(类)的某个连接点(方法出)采取的动作，会有四种不同的通知方式： around(环绕通知)，before(前置通知)，after(后置通知)， exception(异常通知)，return(返回通知)。许多AOP框架（包括Spring）将建议把通知作为为拦截器，并在连接点周围维护一系列拦截器。
  切入点(Pointcut):表示一组连接点，通知与切入点表达式有关，并在切入点匹配的任何连接点处运行(例如执行具有特定名称的方法)。由切入点表达式匹配的连接点的概念是AOP的核心，Spring默认使用AspectJ切入点表达式语言。
  介绍(Introduction): introduction可以为原有的对象增加新的属性和方法。例如，你可以使用introduction使bean实现IsModified接口，以简化缓存。
  目标对象(Target Object): 由一个或者多个切面代理的对象。也被称为&amp;quot;切面对象&amp;quot;。由于Spring AOP是使用运行时代理实现的，因此该对象始终是代理对象。
  AOP代理(AOP proxy): 由AOP框架创建的对象，在Spring框架中，AOP代理对象有两种：JDK动态代理和CGLIB代理
  织入(Weaving): 是指把增强应用到目标对象来创建新的代理对象的过程，它(例如 AspectJ 编译器)可以在编译时期，加载时期或者运行时期完成。与其他纯Java AOP框架一样，Spring AOP在运行时进行织入。
Spring AOP 中通知的分类  前置通知(Before Advice): 在目标方法被调用前调用通知功能；相关的类org.springframework.aop.MethodBeforeAdvice 后置通知(After Advice): 在目标方法被调用之后调用通知功能；相关的类org.</description>
    </item>
    
    <item>
      <title>Spring06 动/静态代理</title>
      <link>https://example.com/p/spring06-%E5%8A%A8/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/</link>
      <pubDate>Sat, 11 Sep 2021 17:48:54 +0800</pubDate>
      
      <guid>https://example.com/p/spring06-%E5%8A%A8/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/</guid>
      <description>代理模式 为什么要学习代理模式，因为AOP的底层机制就是动态代理！
代理模式：
 静态代理 动态代理   静态代理  静态代理角色分析
  抽象角色 : 一般使用接口或者抽象类来实现
  真实角色 : 被代理的角色
  代理角色 : 代理真实角色 ; 代理真实角色后 , 一般会做一些附属的操作 .
  客户 : 使用代理角色来进行一些操作 .
  代码实现
Rent . java 即抽象角色
//抽象角色：租房 public interface Rent { public void rent(); } Host . java 即真实角色
//真实角色: 房东，房东要出租房子 public class Host implements Rent{ public void rent() { System.out.println(&amp;#34;房屋出租&amp;#34;); } } Proxy .</description>
    </item>
    
    <item>
      <title>Spring05 使用注解开发</title>
      <link>https://example.com/p/spring05-%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/</link>
      <pubDate>Sat, 11 Sep 2021 17:48:51 +0800</pubDate>
      
      <guid>https://example.com/p/spring05-%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/</guid>
      <description>使用注解开发  说明  在spring4之后，想要使用注解形式，必须得要引入aop的包
`spring-aop
在配置文件当中，还得要引入一个context约束
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:context=&amp;#34;http://www.springframework.org/schema/context&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&amp;#34;&amp;gt; &amp;lt;/beans&amp;gt;  Bean的实现  我们之前都是使用 bean 的标签进行bean注入，但是实际开发中，我们一般都会使用注解！
1、配置扫描哪些包下的注解
&amp;lt;!--指定注解扫描包--&amp;gt; &amp;lt;context:component-scan base-package=&amp;#34;com.kuang.pojo&amp;#34;/&amp;gt; 2、在指定包下编写类，增加注解
@Component(&amp;#34;user&amp;#34;) // 相当于配置文件中 &amp;lt;bean id=&amp;#34;user&amp;#34; class=&amp;#34;当前注解的类&amp;#34;/&amp;gt; public class User { public String name = &amp;#34;秦疆&amp;#34;; } 3、测试
@Test public void test(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&amp;#34;beans.xml&amp;#34;); User user = (User) applicationContext.getBean(&amp;#34;user&amp;#34;); System.out.println(user.name); }  属性注入  使用注解注入属性
1、可以不用提供set方法，直接在直接名上添加@value(&amp;ldquo;值&amp;rdquo;)
@Component(&amp;#34;user&amp;#34;) // 相当于配置文件中 &amp;lt;bean id=&amp;#34;user&amp;#34; class=&amp;#34;当前注解的类&amp;#34;/&amp;gt; public class User { @Value(&amp;#34;秦疆&amp;#34;) // 相当于配置文件中 &amp;lt;property name=&amp;#34;name&amp;#34; value=&amp;#34;秦疆&amp;#34;/&amp;gt;  public String name; } 2、如果提供了set方法，在set方法上添加@value(&amp;ldquo;值&amp;rdquo;);</description>
    </item>
    
    <item>
      <title>Spring04 自动装配</title>
      <link>https://example.com/p/spring04-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</link>
      <pubDate>Sat, 11 Sep 2021 17:48:33 +0800</pubDate>
      
      <guid>https://example.com/p/spring04-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</guid>
      <description>Bean的自动装配  自动装配说明   自动装配是使用spring满足bean依赖的一种方法 spring会在应用上下文中为某个bean寻找其依赖的bean。  Spring中bean有三种装配机制，分别是：
 在xml中显式配置； 在java中显式配置； 隐式的bean发现机制和自动装配。  这里我们主要讲第三种：自动化的装配bean。
Spring的自动装配需要从两个角度来实现，或者说是两个操作：
 组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean； 自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC/DI；  组件扫描和自动装配组合发挥巨大威力，使得显示的配置降低到最少。
**不推荐使用xml配置 , 而使用注解 **
 测试环境搭建  1、新建一个项目
2、新建两个实体类，Cat Dog 都有一个叫的方法
public class Cat { public void shout() { System.out.println(&amp;#34;miao~&amp;#34;); } } public class Dog { public void shout() { System.out.println(&amp;#34;wang~&amp;#34;); } } 3、新建一个用户类 User
public class User { private Cat cat; private Dog dog; private String str; } 4、编写Spring配置文件</description>
    </item>
    
    <item>
      <title>Spring03 依赖注入(DI)</title>
      <link>https://example.com/p/spring03-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5di/</link>
      <pubDate>Sat, 11 Sep 2021 17:41:44 +0800</pubDate>
      
      <guid>https://example.com/p/spring03-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5di/</guid>
      <description>Dependency Injection  概念   依赖注入（Dependency Injection,DI）。 依赖 : 指Bean对象的创建依赖于容器 . Bean对象的依赖资源 . 注入 : 指Bean对象所依赖的资源 , 由容器来设置和装配 .   构造器注入  我们在之前的案例已经讲过了
 Set 注入 （重点）  要求被注入的属性 , 必须有set方法 , set方法的方法名由set + 属性首字母大写 , 如果属性是boolean类型 , 没有set方法 , 是 is .
测试pojo类 :
Address.java
public class Address { private String address; public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } } Student.</description>
    </item>
    
    <item>
      <title>Spring02 快速上手</title>
      <link>https://example.com/p/spring02-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</link>
      <pubDate>Sat, 11 Sep 2021 17:23:33 +0800</pubDate>
      
      <guid>https://example.com/p/spring02-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</guid>
      <description>HelloSpring  导入Jar包  注 : spring 需要导入commons-logging进行日志记录 . 我们利用maven , 他会自动下载对应的依赖项 .
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.1.10.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;  编写代码  1、编写一个Hello实体类
public class Hello { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } public void show(){ System.out.println(&amp;#34;Hello,&amp;#34;+ name ); } } 2、编写我们的spring文件 , 这里我们命名为beans.xml
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&amp;#34;&amp;gt; &amp;lt;!--bean就是java对象 , 由Spring创建和管理--&amp;gt; &amp;lt;bean id=&amp;#34;hello&amp;#34; class=&amp;#34;com.kuang.pojo.Hello&amp;#34;&amp;gt; &amp;lt;property name=&amp;#34;name&amp;#34; value=&amp;#34;Spring&amp;#34;/&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;/beans&amp;gt; 3、我们可以去进行测试了 .</description>
    </item>
    
    <item>
      <title>记一次 Hugo 安装</title>
      <link>https://example.com/p/%E8%AE%B0%E4%B8%80%E6%AC%A1-hugo-%E5%AE%89%E8%A3%85/</link>
      <pubDate>Fri, 10 Sep 2021 13:37:10 +0800</pubDate>
      
      <guid>https://example.com/p/%E8%AE%B0%E4%B8%80%E6%AC%A1-hugo-%E5%AE%89%E8%A3%85/</guid>
      <description>Hugo 简介 Hugo是由Steve Francis基于Go语言开发的静态网站构建工具。
为什么选择Hexo  编译文章生成速度快 Hugo的官方文档写的非常好，部署简洁。 前两者部署时需要安装很多依赖，而hugo可以直接提供二进制文件运行，甚至不需要root权限。 颜值相对较高  安装 官方安装教程(推荐)
Mac安装   安装 brew
ruby -e &amp;#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;#34;   运行brew命令进行安装hugo
brew install hugo 如果 Homebrew 工作正常，您应该会看到类似于以下内容的内容：
==&amp;gt; Downloading https://homebrew.bintray.com/bottles/hugo-0.21.sierra.bottle.tar.gz ######################################################################### 100.0% ==&amp;gt; Pouring hugo-0.21.sierra.bottle.tar.gz 🍺 /usr/local/Cellar/hugo/0.21: 32 files, 17.4MB   创建新站点 hugo new site quickstart 添加主题 有关要考虑的主题列表，请参阅themes.gohugo.io。本快速入门使用漂亮的Ananke 主题。
首先，从 GitHub 下载主题并将其添加到您网站的themes目录中：
cd quickstart git init git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke 然后，将主题添加到站点配置中：
echo theme = \&amp;#34;ananke\&amp;#34; &amp;gt;&amp;gt; config.</description>
    </item>
    
    <item>
      <title>Filter和Listener</title>
      <link>https://example.com/p/filter%E5%92%8Clistener/</link>
      <pubDate>Tue, 11 May 2021 15:29:19 +0800</pubDate>
      
      <guid>https://example.com/p/filter%E5%92%8Clistener/</guid>
      <description>Filter和Listener FIlter 指过滤器  概念   生活中的过滤器:空气过滤器 净水器 web中的过滤器:当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能 过滤器的一些功能: 一般用于完整通用的操作：  比如登录验证 统一编码设置 敏感字符过滤     快速入门:
  步骤:
 定义一个类 实现Filter接口， 复写方法 配置拦截资源: 注解配置 @WebFilter(&amp;quot;/*&amp;quot;) web.xml配置    @WebFilter(&amp;#34;/*&amp;#34;) public class FilterDemo implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(&amp;#34;执行了filter&amp;#34;); chain.doFilter(request, response); } }     过滤器细节
  web.xml
  &amp;lt;filter&amp;gt; &amp;lt;filter-name&amp;gt;demo1&amp;lt;/filter-name&amp;gt; &amp;lt;filter-class&amp;gt;com.</description>
    </item>
    
    <item>
      <title>MySQL中的数据类型</title>
      <link>https://example.com/p/mysql%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Tue, 11 May 2021 15:29:19 +0800</pubDate>
      
      <guid>https://example.com/p/mysql%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>MySQL中的数据类型 MySQL支持多种数据类型，主要有数值类型、日期/时间类型和字符串类型。
数值类型 数值类型包括：
  整数类型：TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT
  浮点数类型有FLOAT和DOUBLE
  定点小数类型DECIMAL
  日期/时间类型：包括YEAR、TIME、DATE、DATATIME和TIMESTAMP。
  字符串类型：CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET等。字符串类型又分为文本字符串和二进制字符串。
  整数类型 数值型数据类型主要用来存储数字，不同的数据类型提供不同的取值范围，可以存储的值的范围越大，其所需要的存储空间也会越大。整数类型的字段可以添加AUTO_INCREMENT自增约束条件。
   类型名称 存储需求（B）     TINYINT tinyint 1   SMALLINT smallint 2   MEDIUMINT mediumint 3   INT 4   BIGINT 8    需要注意的是，在设计数据库的时候，在实体类中long型的变量对应BIGINT,INT对应int类型的成员变量。
例：
CREATE TABLE tb_emp1( id INT(11), name VARCHAR(25). deptId INT(11), salary FLOAT ); id字段的数据类型为INT（11），“11”表示该数据类型指定的显示宽度，指定能显示的数值中数字的个数。</description>
    </item>
    
    <item>
      <title>Spring01 概述及IOC理论推导</title>
      <link>https://example.com/p/spring01-%E6%A6%82%E8%BF%B0%E5%8F%8Aioc%E7%90%86%E8%AE%BA%E6%8E%A8%E5%AF%BC/</link>
      <pubDate>Tue, 11 May 2021 15:29:19 +0800</pubDate>
      
      <guid>https://example.com/p/spring01-%E6%A6%82%E8%BF%B0%E5%8F%8Aioc%E7%90%86%E8%AE%BA%E6%8E%A8%E5%AF%BC/</guid>
      <description>Spring介绍  简介  Spring : 春天 &amp;mdash;&amp;gt;给软件行业带来了春天
2002年，Rod Jahnson首次推出了Spring框架雏形interface21框架。
2004年3月24日，Spring框架以interface21框架为基础，经过重新设计，发布了1.0正式版。
很难想象Rod Johnson的学历 , 他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学。
Spring理念 : 使现有技术更加实用 . 本身就是一个大杂烩 , 整合现有的框架技术
官网 : http://spring.io/
官方下载地址 : https://repo.spring.io/libs-release-local/org/springframework/spring/
GitHub : https://github.com/spring-projects
 优点    Spring是一个开源免费的框架 , 容器 .
  Spring是一个轻量级的框架 , 非侵入式的 .
  控制反转 IoC , 面向切面 Aop
  对事物的支持 , 对框架的支持
  一句话概括：
Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）。
 组成  Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式 .</description>
    </item>
    
    <item>
      <title>使用EL表达式</title>
      <link>https://example.com/p/%E4%BD%BF%E7%94%A8el%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Tue, 11 May 2021 15:29:19 +0800</pubDate>
      
      <guid>https://example.com/p/%E4%BD%BF%E7%94%A8el%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>EL（Expression Language） JSP表达式语言（EL）使得访问存储在JavaBean中的数据变得非常简单。JSP EL既可以用来创建算术表达式也可以用来创建逻辑表达式。在JSP EL表达式内可以使用整型数，浮点数，字符串，常量true、false，还有null。
一个简单的语法 ${expr} {expr} 其中，expr指的是表达式。在JSP EL中通用的操作符是 . 和 {} 。这两个操作符允许您通过内嵌的JSP对象访问各种各样的JavaBean属性。
&amp;lt;jsp:setProperty name=&amp;quot;box&amp;quot; property=&amp;quot;perimeter&amp;quot; name=&amp;quot;box&amp;quot; property=&amp;quot;perimeter&amp;quot; value=&amp;quot;${2*box.width+2*box.height}&amp;quot;/&amp;gt;value=&amp;quot;${2*box.width+2*box.height}&amp;quot;/&amp;gt; 当JSP编译器在属性中见到&amp;quot;${}&amp;ldquo;格式后，它会产生代码来计算这个表达式，并且产生一个替代品来代替表达式的值。
您也可以在标签的模板文本中使用表达式语言。比如jsp:text标签简单地将其主体中的文本插入到JSP输出中：
&amp;lt;jsp:text&amp;gt; &amp;lt;h1&amp;gt;Hello JSP!&amp;lt;/h1&amp;gt;&amp;lt;h1&amp;gt;Hello JSP!&amp;lt;/h1&amp;gt; &amp;lt;/jsp:text&amp;gt;&amp;lt;/jsp:text&amp;gt; 现在，在jsp:text标签主体中使用表达式，就像这样：
&amp;lt;jsp:text&amp;gt; Box Perimeter is: ${2*box.width + 2*box.height} &amp;lt;/jsp:text&amp;gt;&amp;lt;/jsp:text&amp;gt; 在EL表达式中可以使用圆括号来组织子表达式。比如${(1 + 2) * 3}等于9，但是${1 + (2 * 3)} 等于7。
想要停用对EL表达式的评估的话，需要使用page指令将isELIgnored属性值设为true：
&amp;lt;%@ page isELIgnored =&amp;quot;true|false&amp;quot; %&amp;gt; 这样，EL表达式就会被忽略。若设为false，则容器将会计算EL表达式。
 EL中的基础操作符 EL表达式支持大部分Java所提供的算术和逻辑操作符：
   操作符 描述     . 访问一个Bean属性或者一个映射条目   [] 访问一个数组或者链表的元素   ( ) 组织一个子表达式以改变优先级   + 加   - 减或负   * 乘   / or div 除   % or mod 取模   == or eq 测试是否相等   !</description>
    </item>
    
  </channel>
</rss>
