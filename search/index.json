[{"content":"Springmvc 中的中文乱码 解决POST请求中文乱码问题  encoding是设置的request乱码问题，forceEncoding是设置的response乱码问题\n \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;CharacterEncodingFilter\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.CharacterEncodingFilter\u0026lt;/filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;UTF-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;!--spring5之后就不需要配置forceEncoding了--\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;forceEncoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;true\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;CharacterEncodingFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; 解决Get乱码 修改tomcat配置文件编码\n\u0026lt;!--ISO8859-1是tomcat默认编码，需要将tomcat编码改为utf-8--\u0026gt; \u0026lt;ConnectorURIEncoding=\u0026#34;utf-8\u0026#34; connectionTimeout=\u0026#34;20000\u0026#34; port=\u0026#34;8080\u0026#34; protocol=\u0026#34;HTTP/1.1\u0026#34; redirectPort=\u0026#34;8443\u0026#34;/\u0026gt; 狂神推荐的大神过滤器 package com.zhang.filter; import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletRequestWrapper; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.UnsupportedEncodingException; import java.util.Map; /** * 解决get和post请求，全部乱码的过滤器 */ public class GenericEncodingFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws IOException, ServletException { //处理response的字符编码  HttpServletResponse myResponse = (HttpServletResponse)response; //转型为与协议相关对象  HttpServletRequest httpServletRequest = (HttpServletRequest)request; //对request包装增强  HttpServletRequest myRequest = new MyRequest(httpServletRequest); filterChain.doFilter(myRequest,myResponse); } @Override public void destroy() { } } class MyRequest extends HttpServletRequestWrapper { private HttpServletRequest request; private boolean hasEncode; public MyRequest(HttpServletRequest request){ super(request); this.request = request; } @Override public Map getParameterMap() { String method = request.getMethod(); if(method.equalsIgnoreCase(\u0026#34;post\u0026#34;)){ try{ request.setCharacterEncoding(\u0026#34;utf-8\u0026#34;); return request.getParameterMap(); }catch (UnsupportedEncodingException e){ e.printStackTrace(); } }else if(method.equalsIgnoreCase(\u0026#34;get\u0026#34;)){ Map\u0026lt;String,String[]\u0026gt; parameterMap = request.getParameterMap(); if(!hasEncode){//确保get手动编码逻辑只运行一次  for(String parameterName : parameterMap.keySet()){ String[] values = parameterMap.get(parameterName); if(values != null){ for (int i = 0; i \u0026lt; values.length; i ++){ try{ //处理get乱码  values[i] = new String(values[i].getBytes(\u0026#34;ISO-8859-1\u0026#34;), \u0026#34;utf-8\u0026#34;); }catch (UnsupportedEncodingException e){ e.printStackTrace(); } } } } hasEncode = true; } return parameterMap; } return super.getParameterMap(); } @Override public String getParameter(String name) { Map\u0026lt;String,String[]\u0026gt; parameterMap = getParameterMap(); String[] values = parameterMap.get(name); if(values == null){ return null; } return values[0]; } @Override public String[] getParameterValues(String name) { Map\u0026lt;String,String[]\u0026gt; parameterMap = getParameterMap(); String[] values = parameterMap.get(name); return values; } } 怎么配置\n\u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;encoding\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;com.zhang.filter.GenericEncodingFilter\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;encoding\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; JSON乱码问题（两种解决办法）   办法一:\n每个方法都得加，很麻烦\nString userName = new @RequestMapping(value = \u0026#34;/j1\u0026#34;,produces = \u0026#34;application/json;charset=utf-8\u0026#34;) String(request.getParamter(\u0026#34;userName\u0026#34;).getBytes(\u0026#34;ISO8859-1\u0026#34;),\u0026#34;utf-8\u0026#34;)   办法二，在springmvc-servlet.xml中添加如下配置（需要导入jackson）\n  \u0026lt;!-- JSON乱码问题配置 --\u0026gt; \u0026lt;mvc:annotation-driven\u0026gt; \u0026lt;mvc:message-converters register-defaults=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.http.converter.StringHttpMessageConverter\u0026#34;\u0026gt; \u0026lt;constructor-arg value=\u0026#34;UTF-8\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;objectMapper\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;failOnEmptyBeans\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/mvc:message-converters\u0026gt; \u0026lt;/mvc:annotation-driven\u0026gt; ","date":"2021-11-11T11:18:56+08:00","permalink":"https://example.com/p/springmvc-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/","title":"Springmvc 中文乱码"},{"content":"mybatis缓存 简介 1、什么是缓存 [ Cache ]？\n 存在内存中的临时数据。 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。  2、为什么使用缓存？\n 减少和数据库的交互次数，减少系统开销，提高系统效率。  3、什么样的数据能使用缓存？\n 经常查询并且不经常改变的数据。  Mybatis缓存   MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。\n  MyBatis系统中默认定义了两级缓存：一级缓存和二级缓存\n   默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存） 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存    一级缓存 一级缓存也叫本地缓存：\n 与数据库同一次会话期间查询到的数据会放在本地缓存中。 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；  注意：\n必须保证多次查询中间，不能有任何的增删改操作，否则缓存数据会清空。\n1、在mybatis中加入日志，方便测试结果\n2、编写接口方法\n//根据id查询用户 User queryUserById(@Param(\u0026#34;id\u0026#34;) int id); 3、接口对应的Mapper文件\n\u0026lt;select id=\u0026#34;queryUserById\u0026#34; resultType=\u0026#34;user\u0026#34;\u0026gt; select * from user where id = #{id} \u0026lt;/select\u0026gt; 4、测试\n@Test public void testQueryUserById(){ SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); User user2 = mapper.queryUserById(1); System.out.println(user2); System.out.println(user==user2); session.close(); } 5、结果分析\n第一次查询和第二次查询的对象时一致的，并且只执行了一次sql语句\n一级缓存失效的四种情况 一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它；\n一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！\n1、sqlSession不同\n@Test public void testQueryUserById(){ SqlSession session = MybatisUtils.getSession(); SqlSession session2 = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); UserMapper mapper2 = session2.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); User user2 = mapper2.queryUserById(1); System.out.println(user2); System.out.println(user==user2); session.close(); session2.close(); } 观察结果：发现发送了两条SQL语句！\n结论：每个sqlSession中的缓存相互独立\n2、sqlSession相同，查询条件不同\n@Test public void testQueryUserById(){ SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); UserMapper mapper2 = session.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); User user2 = mapper2.queryUserById(2); System.out.println(user2); System.out.println(user==user2); session.close(); } 观察结果：发现发送了两条SQL语句！很正常的理解\n结论：当前缓存中，不存在这个数据\n3、sqlSession相同，两次查询之间执行了增删改操作！\n增加方法\n//修改用户 int updateUser(Map map); 编写SQL\n\u0026lt;update id=\u0026#34;updateUser\u0026#34; parameterType=\u0026#34;map\u0026#34;\u0026gt; update user set name = #{name} where id = #{id} \u0026lt;/update\u0026gt; 测试\n@Test public void testQueryUserById(){ SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); HashMap map = new HashMap(); map.put(\u0026#34;name\u0026#34;,\u0026#34;kuangshen\u0026#34;); map.put(\u0026#34;id\u0026#34;,4); mapper.updateUser(map); User user2 = mapper.queryUserById(1); System.out.println(user2); System.out.println(user==user2); session.close(); } 观察结果：查询在中间执行了增删改操作后，重新执行了\n结论：因为增删改操作可能会对当前数据产生影响\n4、sqlSession相同，手动清除一级缓存\n@Test public void testQueryUserById(){ SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); session.clearCache();//手动清除缓存 User user2 = mapper.queryUserById(1); System.out.println(user2); System.out.println(user==user2); session.close(); } 一级缓存就是一个map\n//手动清理缓存 sqlSession.clearCache(); 二级缓存   二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存\n  基于namespace级别的缓存，一个名称空间，对应一个二级缓存；\n  工作机制\n   一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中； 如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中； 新的会话查询信息，就可以从二级缓存中获取内容； 不同的mapper查出的数据会放在自己对应的缓存（map）中；    使用步骤 1、开启全局缓存 【mybatis-config.xml】\n\u0026lt;setting name=\u0026#34;cacheEnabled\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; 2、去每个mapper.xml中配置使用二级缓存，这个配置非常简单；【xxxMapper.xml】\n\u0026lt;cache/\u0026gt; 官方示例=====\u0026gt;查看官方文档 \u0026lt;cache eviction=\u0026#34;FIFO\u0026#34; flushInterval=\u0026#34;60000\u0026#34; size=\u0026#34;512\u0026#34; readOnly=\u0026#34;true\u0026#34;/\u0026gt; 这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。 eviction 配置缓存策略\n LRU – 最近最少使用：移除最长时间不被使用的对象。 FIFO – 先进先出：按对象进入缓存的顺序来移除它们。 SOFT – 软引用：基于垃圾回收器状态和软引用规则移除对象。 WEAK – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。  flushInterval 刷新间隔\nsize 缓存可用空间\nreadOnly 只读 会返回相同实例（因为这些实例是不可修改的）\nreadOnly 查询出来的实例是可以修改的，但是如果为false两个实例不相同。\n3、代码测试\n 所有的实体类先实现序列化接口 测试代码  @Test public void testQueryUserById(){ SqlSession session = MybatisUtils.getSession(); SqlSession session2 = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); UserMapper mapper2 = session2.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); session.close(); User user2 = mapper2.queryUserById(1); System.out.println(user2); System.out.println(user==user2); session2.close(); } 结论  只要开启了二级缓存，我们在同一个Mapper中的查询，可以在二级缓存中拿到数据 查出的数据都会被默认先放在一级缓存中 只有会话提交或者关闭以后，一级缓存中的数据才会转到二级缓存中  Mybaits缓存插件 ehcache 第三方缓存实现\u0026ndash;EhCache: 查看百度百科\nEhcache是一种广泛使用的java分布式缓存，用于通用缓存；\n要在应用程序中使用Ehcache，需要引入依赖的jar包\n\u0026lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.caches\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-ehcache\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在mapper.xml中使用对应的缓存即可\n\u0026lt;mapper namespace = “org.acme.FooMapper” \u0026gt; \u0026lt;cache type = “org.mybatis.caches.ehcache.EhcacheCache” /\u0026gt; \u0026lt;/mapper\u0026gt; 编写ehcache.xml文件，如果在加载时未找到/ehcache.xml资源或出现问题，则将使用默认配置。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;ehcache xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:noNamespaceSchemaLocation=\u0026#34;http://ehcache.org/ehcache.xsd\u0026#34; updateCheck=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;!-- diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下： user.home – 用户主目录 user.dir – 用户当前工作目录 java.io.tmpdir – 默认临时文件路径 --\u0026gt; \u0026lt;diskStore path=\u0026#34;./tmpdir/Tmp_EhCache\u0026#34;/\u0026gt; \u0026lt;defaultCache eternal=\u0026#34;false\u0026#34; maxElementsInMemory=\u0026#34;10000\u0026#34; overflowToDisk=\u0026#34;false\u0026#34; diskPersistent=\u0026#34;false\u0026#34; timeToIdleSeconds=\u0026#34;1800\u0026#34; timeToLiveSeconds=\u0026#34;259200\u0026#34; memoryStoreEvictionPolicy=\u0026#34;LRU\u0026#34;/\u0026gt; \u0026lt;cache name=\u0026#34;cloud_user\u0026#34; eternal=\u0026#34;false\u0026#34; maxElementsInMemory=\u0026#34;5000\u0026#34; overflowToDisk=\u0026#34;false\u0026#34; diskPersistent=\u0026#34;false\u0026#34; timeToIdleSeconds=\u0026#34;1800\u0026#34; timeToLiveSeconds=\u0026#34;1800\u0026#34; memoryStoreEvictionPolicy=\u0026#34;LRU\u0026#34;/\u0026gt; \u0026lt;!-- defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。 --\u0026gt; \u0026lt;!-- name:缓存名称。 maxElementsInMemory:缓存最大数目 maxElementsOnDisk：硬盘最大缓存个数。 eternal:对象是否永久有效，一但设置了，timeout将不起作用。 overflowToDisk:是否保存到磁盘，当系统当机时 timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。 timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。 diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false. diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。 diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。 memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。 clearOnFlush：内存数量最大时是否清除。 memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。 FIFO，first in first out，这个是大家最熟的，先进先出。 LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。 LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。 --\u0026gt; \u0026lt;/ehcache\u0026gt; 合理的使用缓存，可以让我们程序的性能大大提升！\n","date":"2021-11-09T09:58:40+08:00","permalink":"https://example.com/p/mybatis07-%E7%BC%93%E5%AD%98/","title":"MyBatis07 缓存"},{"content":"动态SQL 介绍 什么是动态SQL：动态SQL指的是根据不同的查询条件 , 生成不同的Sql语句.\n官网描述： MyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。 虽然在以前使用动态 SQL 并非一件易事，但正是 MyBatis 提供了可以被用在任意 SQL 映射语句中的强大的动态 SQL 语言得以改进这种情形。 动态 SQL 元素和 JSTL 或基于类似 XML 的文本处理器相似。在 MyBatis 之前的版本中，有很多元素需要花时间了解。MyBatis 3 大大精简了元素种类，现在只需学习原来一半的元素便可。MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。 ------------------------------- - if - choose (when, otherwise) - trim (where, set) - foreach ------------------------------- 我们之前写的 SQL 语句都比较简单，如果有比较复杂的业务，我们需要写复杂的 SQL 语句，往往需要拼接，而拼接 SQL ，稍微不注意，由于引号，空格等缺失可能都会导致错误。\n那么怎么去解决这个问题呢？这就要使用 mybatis 动态SQL，通过 if, choose, when, otherwise, trim, where, set, foreach等标签，可组合成非常灵活的SQL语句，从而在提高 SQL 语句的准确性的同时，也大大提高了开发人员的效率。\n搭建环境 新建一个数据库表：blog\n字段：id，title，author，create_time，views\nCREATETABLE`blog`(`id`varchar(50)NOTNULLCOMMENT\u0026#39;博客id\u0026#39;,`title`varchar(100)NOTNULLCOMMENT\u0026#39;博客标题\u0026#39;,`author`varchar(30)NOTNULLCOMMENT\u0026#39;博客作者\u0026#39;,`create_time`datetimeNOTNULLCOMMENT\u0026#39;创建时间\u0026#39;,`views`int(30)NOTNULLCOMMENT\u0026#39;浏览量\u0026#39;)ENGINE=InnoDBDEFAULTCHARSET=utf81、创建Mybatis基础工程\n2、IDutil工具类\npublic class IDUtil { public static String genId(){ return UUID.randomUUID().toString().replaceAll(\u0026#34;-\u0026#34;,\u0026#34;\u0026#34;); } } 3、实体类编写 【注意set方法作用】\n@Date public class Blog { private String id; private String title; private String author; private Date createTime; private int views; } 4、编写Mapper接口及xml文件\npublic interface BlogMapper { } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.cuit.mybatis.mapper.BlogMapper\u0026#34;\u0026gt; \u0026lt;/mapper\u0026gt; 5、mybatis核心配置文件，下划线驼峰自动转换\n\u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026#34;mapUnderscoreToCamelCase\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;logImpl\u0026#34; value=\u0026#34;STDOUT_LOGGING\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; \u0026lt;!--注册Mapper.xml--\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;mapper/BlogMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; 6、插入初始数据\n编写接口\n//新增一个博客 int addBlog(Blog blog); sql配置文件\n\u0026lt;insert id=\u0026#34;addBlog\u0026#34; parameterType=\u0026#34;blog\u0026#34;\u0026gt; insert into blog (id, title, author, create_time, views) values (#{id},#{title},#{author},#{createTime},#{views}); \u0026lt;/insert\u0026gt; 初始化博客方法\n@Test public void addInitBlog(){ SqlSession session = MybatisUtils.getSession(); BlogMapper mapper = session.getMapper(BlogMapper.class); Blog blog = new Blog(); blog.setId(IDUtil.genId()); blog.setTitle(\u0026#34;Mybatis如此简单\u0026#34;); blog.setAuthor(\u0026#34;张三\u0026#34;); blog.setCreateTime(new Date()); blog.setViews(9999); mapper.addBlog(blog); blog.setId(IDUtil.genId()); blog.setTitle(\u0026#34;Java如此简单\u0026#34;); mapper.addBlog(blog); blog.setId(IDUtil.genId()); blog.setTitle(\u0026#34;Spring如此简单\u0026#34;); mapper.addBlog(blog); blog.setId(IDUtil.genId()); blog.setTitle(\u0026#34;微服务如此简单\u0026#34;); mapper.addBlog(blog); session.close(); } 初始化数据完毕！\nif 语句 需求：根据作者名字和博客名字来查询博客！如果作者名字为空，那么只根据博客名字查询，反之，则根据作者名来查询\n1、编写接口类\n//需求1 List\u0026lt;Blog\u0026gt; queryBlogIf(Map map); 2、编写SQL语句\n\u0026lt;!--需求1： 根据作者名字和博客名字来查询博客！ 如果作者名字为空，那么只根据博客名字查询，反之，则根据作者名来查询 select * from blog where title = #{title} and author = #{author} --\u0026gt; \u0026lt;select id=\u0026#34;queryBlogIf\u0026#34; parameterType=\u0026#34;map\u0026#34; resultType=\u0026#34;blog\u0026#34;\u0026gt; select * from blog where \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt; title = #{title} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;author != null\u0026#34;\u0026gt; and author = #{author} \u0026lt;/if\u0026gt; \u0026lt;/select\u0026gt; 3、测试\n@Test public void testQueryBlogIf(){ SqlSession session = MybatisUtils.getSession(); BlogMapper mapper = session.getMapper(BlogMapper.class); HashMap\u0026lt;String, String\u0026gt; map = new HashMap\u0026lt;String, String\u0026gt;(); map.put(\u0026#34;title\u0026#34;,\u0026#34;Mybatis如此简单\u0026#34;); map.put(\u0026#34;author\u0026#34;,\u0026#34;张三\u0026#34;); List\u0026lt;Blog\u0026gt; blogs = mapper.queryBlogIf(map); System.out.println(blogs); session.close(); } 这样写我们可以看到，如果 author 等于 null，那么查询语句为 select * from user where title=#{title},但是如果title为空呢？那么查询语句为 select * from user where and author=#{author}，这是错误的 SQL 语句，如何解决呢？请看下面的 where 语句！\nWhere 修改上面的SQL语句；\n\u0026lt;select id=\u0026#34;queryBlogIf\u0026#34; parameterType=\u0026#34;map\u0026#34; resultType=\u0026#34;blog\u0026#34;\u0026gt; select * from blog \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt; title = #{title} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;author != null\u0026#34;\u0026gt; and author = #{author} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 这个“where”标签会知道如果它包含的标签中有返回值的话，它就插入一个‘where’。此外，如果标签返回的内容是以AND 或OR 开头的，则它会剔除掉。\nSet 同理，上面的对于查询 SQL 语句包含 where 关键字，如果在进行更新操作的时候，含有 set 关键词，我们怎么处理呢？\n1、编写接口方法\nint updateBlog(Map map); 2、sql配置文件\n\u0026lt;!--注意set是用的逗号隔开--\u0026gt; \u0026lt;update id=\u0026#34;updateBlog\u0026#34; parameterType=\u0026#34;map\u0026#34;\u0026gt; update blog \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt; title = #{title}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;author != null\u0026#34;\u0026gt; author = #{author} \u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; where id = #{id}; \u0026lt;/update\u0026gt; 3、测试\n@Test public void testUpdateBlog(){ SqlSession session = MybatisUtils.getSession(); BlogMapper mapper = session.getMapper(BlogMapper.class); HashMap\u0026lt;String, String\u0026gt; map = new HashMap\u0026lt;String, String\u0026gt;(); map.put(\u0026#34;title\u0026#34;,\u0026#34;动态SQL\u0026#34;); map.put(\u0026#34;author\u0026#34;,\u0026#34;李四\u0026#34;); map.put(\u0026#34;id\u0026#34;,\u0026#34;9d6a763f5e1347cebda43e2a32687a77\u0026#34;); mapper.updateBlog(map); session.close(); } choose语句 有时候，我们不想用到所有的查询条件，只想选择其中的一个，查询条件有一个满足即可，使用 choose 标签可以解决此类问题，类似于 Java 的 switch 语句\n1、编写接口方法\nList\u0026lt;Blog\u0026gt; queryBlogChoose(Map map); 2、sql配置文件\n\u0026lt;select id=\u0026#34;queryBlogChoose\u0026#34; parameterType=\u0026#34;map\u0026#34; resultType=\u0026#34;blog\u0026#34;\u0026gt; select * from blog \u0026lt;where\u0026gt; \u0026lt;choose\u0026gt; \u0026lt;when test=\u0026#34;title != null\u0026#34;\u0026gt; title = #{title} \u0026lt;/when\u0026gt; \u0026lt;when test=\u0026#34;author != null\u0026#34;\u0026gt; and author = #{author} \u0026lt;/when\u0026gt; \u0026lt;otherwise\u0026gt; and views = #{views} \u0026lt;/otherwise\u0026gt; \u0026lt;/choose\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 3、测试类\n@Test public void testQueryBlogChoose(){ SqlSession session = MybatisUtils.getSession(); BlogMapper mapper = session.getMapper(BlogMapper.class); HashMap\u0026lt;String, Object\u0026gt; map = new HashMap\u0026lt;String, Object\u0026gt;(); map.put(\u0026#34;title\u0026#34;,\u0026#34;Java如此简单\u0026#34;); map.put(\u0026#34;author\u0026#34;,\u0026#34;张三\u0026#34;); map.put(\u0026#34;views\u0026#34;,9999); List\u0026lt;Blog\u0026gt; blogs = mapper.queryBlogChoose(map); System.out.println(blogs); session.close(); } SQL片段 有时候可能某个 sql 语句我们用的特别多，为了增加代码的重用性，简化代码，我们需要将这些代码抽取出来，然后使用时直接调用。\n提取SQL片段：\n\u0026lt;sql id=\u0026#34;if-title-author\u0026#34;\u0026gt; \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt; title = #{title} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;author != null\u0026#34;\u0026gt; and author = #{author} \u0026lt;/if\u0026gt; \u0026lt;/sql\u0026gt; 引用SQL片段：\n\u0026lt;select id=\u0026#34;queryBlogIf\u0026#34; parameterType=\u0026#34;map\u0026#34; resultType=\u0026#34;blog\u0026#34;\u0026gt; select * from blog \u0026lt;where\u0026gt; \u0026lt;!-- 引用 sql 片段，如果refid 指定的不在本文件中，那么需要在前面加上 namespace --\u0026gt; \u0026lt;include refid=\u0026#34;if-title-author\u0026#34;\u0026gt;\u0026lt;/include\u0026gt; \u0026lt;!-- 在这里还可以引用其他的 sql 片段 --\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 注意：\n①、最好基于 单表来定义 sql 片段，提高片段的可重用性\n②、在 sql 片段中不要包括 where\nForeach 将数据库中前三个数据的id修改为1,2,3；\n需求：我们需要查询 blog 表中 id 分别为1,2,3的博客信息\n1、编写接口\nList\u0026lt;Blog\u0026gt; queryBlogForeach(Map map); 2、编写SQL语句\n\u0026lt;select id=\u0026#34;queryBlogForeach\u0026#34; parameterType=\u0026#34;map\u0026#34; resultType=\u0026#34;blog\u0026#34;\u0026gt; select * from blog \u0026lt;where\u0026gt; \u0026lt;!-- collection:指定输入对象中的集合属性 item:每次遍历生成的对象 open:开始遍历时的拼接字符串 close:结束时拼接的字符串 separator:遍历对象之间需要拼接的字符串 select * from blog where 1=1 and (id=1 or id=2 or id=3) --\u0026gt; \u0026lt;foreach collection=\u0026#34;ids\u0026#34; item=\u0026#34;id\u0026#34; open=\u0026#34;and (\u0026#34; close=\u0026#34;)\u0026#34; separator=\u0026#34;or\u0026#34;\u0026gt; id=#{id} \u0026lt;/foreach\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 3、测试\n@Test public void testQueryBlogForeach(){ SqlSession session = MybatisUtils.getSession(); BlogMapper mapper = session.getMapper(BlogMapper.class); HashMap map = new HashMap(); List\u0026lt;Integer\u0026gt; ids = new ArrayList\u0026lt;Integer\u0026gt;(); ids.add(1); ids.add(2); ids.add(3); map.put(\u0026#34;ids\u0026#34;,ids); List\u0026lt;Blog\u0026gt; blogs = mapper.queryBlogForeach(map); System.out.println(blogs); session.close(); } 小结：其实动态 sql 语句的编写往往就是一个拼接的问题，为了保证拼接准确，我们最好首先要写原生的 sql 语句出来，然后在通过 mybatis 动态sql 对照着改，防止出错。多在实践中使用才是熟练掌握它的技巧。\n动态SQL在开发中大量的使用，一定要熟练掌握！\n","date":"2021-11-09T09:57:49+08:00","permalink":"https://example.com/p/mybatis06-%E5%8A%A8%E6%80%81sql/","title":"MyBatis06 动态SQL"},{"content":"一对多和多对一处理 多对一的处理 多对一的理解：\n 多个学生对应一个老师 如果对于学生这边，就是一个多对一的现象，即从学生这边关联一个老师！  CREATETABLE`teacher`(`id`INT(10)NOTNULL,`name`VARCHAR(30)DEFAULTNULL,PRIMARYKEY(`id`))ENGINE=INNODBDEFAULTCHARSET=utf8INSERTINTOteacher(`id`,`name`)VALUES(1,\u0026#39;张老师\u0026#39;);CREATETABLE`student`(`id`INT(10)NOTNULL,`name`VARCHAR(30)DEFAULTNULL,`tid`INT(10)DEFAULTNULL,PRIMARYKEY(`id`),KEY`fktid`(`tid`),CONSTRAINT`fktid`FOREIGNKEY(`tid`)REFERENCES`teacher`(`id`))ENGINE=INNODBDEFAULTCHARSET=utf8INSERTINTO`student`(`id`,`name`,`tid`)VALUES(\u0026#39;1\u0026#39;,\u0026#39;小明\u0026#39;,\u0026#39;1\u0026#39;);INSERTINTO`student`(`id`,`name`,`tid`)VALUES(\u0026#39;2\u0026#39;,\u0026#39;小红\u0026#39;,\u0026#39;1\u0026#39;);INSERTINTO`student`(`id`,`name`,`tid`)VALUES(\u0026#39;3\u0026#39;,\u0026#39;小张\u0026#39;,\u0026#39;1\u0026#39;);INSERTINTO`student`(`id`,`name`,`tid`)VALUES(\u0026#39;4\u0026#39;,\u0026#39;小李\u0026#39;,\u0026#39;1\u0026#39;);INSERTINTO`student`(`id`,`name`,`tid`)VALUES(\u0026#39;5\u0026#39;,\u0026#39;小王\u0026#39;,\u0026#39;1\u0026#39;);搭建测试环境 1、IDEA安装Lombok插件\n2、引入Maven依赖\n\u0026lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.16.10\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 3、在代码中增加注解\n@Data //GET,SET,ToString，有参，无参构造 public class Teacher { private int id; private String name; } @Data public class Student { private int id; private String name; //多个学生可以是同一个老师，即多对一  private Teacher teacher; } 4、编写实体类对应的Mapper接口 【两个】\n 无论有没有需求，都应该写上，以备后来之需！  public interface StudentMapper { } public interface TeacherMapper { } 5、编写Mapper接口对应的 mapper.xml配置文件 【两个】\n 无论有没有需求，都应该写上，以备后来之需！  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.xxgc.mapper.StudentMapper\u0026#34;\u0026gt; \u0026lt;/mapper\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.xxgc.mapper.TeacherMapper\u0026#34;\u0026gt; \u0026lt;/mapper\u0026gt; 按查询嵌套处理 1、给StudentMapper接口增加方法\n//获取所有学生及对应老师的信息 public List\u0026lt;Student\u0026gt; getStudents(); 2、编写对应的Mapper文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.xxgc.mapper.StudentMapper\u0026#34;\u0026gt; \u0026lt;!-- 需求：获取所有学生及对应老师的信息 思路： 1. 获取所有学生的信息 2. 根据获取的学生信息的老师ID-\u0026gt;获取该老师的信息 3. 思考问题，这样学生的结果集中应该包含老师，该如何处理呢，数据库中我们一般使用关联查询？ 1. 做一个结果集映射：StudentTeacher 2. StudentTeacher结果集的类型为 Student 3. 学生中老师的属性为teacher，对应数据库中为tid。 多个 [1,...）学生关联一个老师=\u0026gt; 一对一，一对多 4. 查看官网找到：association – 一个复杂类型的关联；使用它来处理关联查询 --\u0026gt; \u0026lt;select id=\u0026#34;getStudents\u0026#34; resultMap=\u0026#34;StudentTeacher\u0026#34;\u0026gt; select * from student \u0026lt;/select\u0026gt; \u0026lt;resultMap id=\u0026#34;StudentTeacher\u0026#34; type=\u0026#34;Student\u0026#34;\u0026gt; \u0026lt;!--association关联属性 property属性名 javaType属性类型 column在多的一方的表中的列名--\u0026gt; \u0026lt;association property=\u0026#34;teacher\u0026#34; column=\u0026#34;tid\u0026#34; javaType=\u0026#34;Teacher\u0026#34; select=\u0026#34;getTeacher\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;!-- 这里传递过来的id，只有一个属性的时候，下面可以写任何值 association中column多参数配置： column=\u0026#34;{key=value,key=value}\u0026#34; 其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。 --\u0026gt; \u0026lt;select id=\u0026#34;getTeacher\u0026#34; resultType=\u0026#34;teacher\u0026#34;\u0026gt; select * from teacher where id = #{id} \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 3、编写完毕去Mybatis配置文件中，注册Mapper！\n4、注意点说明：\n\u0026lt;resultMap id=\u0026#34;StudentTeacher\u0026#34; type=\u0026#34;Student\u0026#34;\u0026gt; \u0026lt;!--association关联属性 property属性名 javaType属性类型 column在多的一方的表中的列名--\u0026gt; \u0026lt;association property=\u0026#34;teacher\u0026#34; column=\u0026#34;{id=tid,name=tid}\u0026#34; javaType=\u0026#34;Teacher\u0026#34; select=\u0026#34;getTeacher\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;!-- 这里传递过来的id，只有一个属性的时候，下面可以写任何值 association中column多参数配置： column=\u0026#34;{key=value,key=value}\u0026#34; 其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。 --\u0026gt; \u0026lt;select id=\u0026#34;getTeacher\u0026#34; resultType=\u0026#34;teacher\u0026#34;\u0026gt; select * from teacher where id = #{id} and name = #{name} \u0026lt;/select\u0026gt; 5、测试\n@Test public void testGetStudents(){ SqlSession session = MybatisUtils.getSession(); StudentMapper mapper = session.getMapper(StudentMapper.class); List\u0026lt;Student\u0026gt; students = mapper.getStudents(); for (Student student : students){ System.out.println( \u0026#34;学生名:\u0026#34;+ student.getName() +\u0026#34;\\t老师:\u0026#34;+student.getTeacher().getName()); } } 按结果嵌套处理 除了上面这种方式，还有其他思路吗？\n我们还可以按照结果进行嵌套处理；\n1、接口方法编写\npublic List\u0026lt;Student\u0026gt; getStudents2(); 2、编写对应的mapper文件\n\u0026lt;!-- 按查询结果嵌套处理 思路： 1. 直接查询出结果，进行结果集的映射 --\u0026gt; \u0026lt;select id=\u0026#34;getStudents2\u0026#34; resultMap=\u0026#34;StudentTeacher2\u0026#34; \u0026gt; select s.id sid, s.name sname , t.name tname from student s,teacher t where s.tid = t.id \u0026lt;/select\u0026gt; \u0026lt;resultMap id=\u0026#34;StudentTeacher2\u0026#34; type=\u0026#34;Student\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;id\u0026#34; column=\u0026#34;sid\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;sname\u0026#34;/\u0026gt; \u0026lt;!--关联对象property 关联对象在Student实体类中的属性--\u0026gt; \u0026lt;association property=\u0026#34;teacher\u0026#34; javaType=\u0026#34;Teacher\u0026#34;\u0026gt; \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;tname\u0026#34;/\u0026gt; \u0026lt;/association\u0026gt; \u0026lt;/resultMap\u0026gt; 3、去mybatis-config文件中注入【此处应该处理过了】\n4、测试\n@Test public void testGetStudents2(){ SqlSession session = MybatisUtils.getSession(); StudentMapper mapper = session.getMapper(StudentMapper.class); List\u0026lt;Student\u0026gt; students = mapper.getStudents2(); for (Student student : students){ System.out.println( \u0026#34;学生名:\u0026#34;+ student.getName() +\u0026#34;\\t老师:\u0026#34;+student.getTeacher().getName()); } } 小结 按照查询进行嵌套处理就像SQL中的子查询\n按照结果进行嵌套处理就像SQL中的联表查询\n一对多的处理 一对多的理解：\n 一个老师拥有多个学生 如果对于老师这边，就是一个一对多的现象，即从一个老师下面拥有一群学生（集合）！  实体类编写 @Data public class Student { private int id; private String name; private int tid; } @Data public class Teacher { private int id; private String name; //一个老师多个学生  private List\u0026lt;Student\u0026gt; students; } 和之前一样，搭建测试的环境！\n按结果嵌套处理 1、TeacherMapper接口编写方法\n//获取指定老师，及老师下的所有学生 public Teacher getTeacher(int id); 2、编写接口对应的Mapper配置文件\n\u0026lt;mapper namespace=\u0026#34;com.kuang.mapper.TeacherMapper\u0026#34;\u0026gt; \u0026lt;!-- 思路: 1. 从学生表和老师表中查出学生id，学生姓名，老师姓名 2. 对查询出来的操作做结果集映射 1. 集合的话，使用collection！ JavaType和ofType都是用来指定对象类型的 JavaType是用来指定pojo中属性的类型 ofType指定的是映射到list集合属性中pojo的类型。 --\u0026gt; \u0026lt;select id=\u0026#34;getTeacher\u0026#34; resultMap=\u0026#34;TeacherStudent\u0026#34;\u0026gt; select s.id sid, s.name sname , t.name tname, t.id tid from student s,teacher t where s.tid = t.id and t.id=#{id} \u0026lt;/select\u0026gt; \u0026lt;resultMap id=\u0026#34;TeacherStudent\u0026#34; type=\u0026#34;Teacher\u0026#34;\u0026gt; \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;tname\u0026#34;/\u0026gt; \u0026lt;collection property=\u0026#34;students\u0026#34; ofType=\u0026#34;Student\u0026#34;\u0026gt; \u0026lt;result property=\u0026#34;id\u0026#34; column=\u0026#34;sid\u0026#34; /\u0026gt; \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;sname\u0026#34; /\u0026gt; \u0026lt;result property=\u0026#34;tid\u0026#34; column=\u0026#34;tid\u0026#34; /\u0026gt; \u0026lt;/collection\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;/mapper\u0026gt; 3、将Mapper文件注册到MyBatis-config文件中\n\u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;mapper/TeacherMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; 4、测试\n@Test public void testGetTeacher(){ SqlSession session = MybatisUtils.getSession(); TeacherMapper mapper = session.getMapper(TeacherMapper.class); Teacher teacher = mapper.getTeacher(1); System.out.println(teacher.getName()); System.out.println(teacher.getStudents()); } 按查询嵌套处理 1、TeacherMapper接口编写方法\npublic Teacher getTeacher2(int id); 2、编写接口对应的Mapper配置文件\n\u0026lt;select id=\u0026#34;getTeacher2\u0026#34; resultMap=\u0026#34;TeacherStudent2\u0026#34;\u0026gt; select * from teacher where id = #{id} \u0026lt;/select\u0026gt; \u0026lt;resultMap id=\u0026#34;TeacherStudent2\u0026#34; type=\u0026#34;Teacher\u0026#34;\u0026gt; \u0026lt;!--column是一对多的外键 , 写的是一的主键的列名--\u0026gt; \u0026lt;collection property=\u0026#34;students\u0026#34; javaType=\u0026#34;ArrayList\u0026#34; ofType=\u0026#34;Student\u0026#34; column=\u0026#34;id\u0026#34;select=\u0026#34;getStudentByTeacherId\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;getStudentByTeacherId\u0026#34; resultType=\u0026#34;Student\u0026#34;\u0026gt; select * from student where tid = #{id} \u0026lt;/select\u0026gt; 3、将Mapper文件注册到MyBatis-config文件中\n4、测试\n@Test public void testGetTeacher2(){ SqlSession session = MybatisUtils.getSession(); TeacherMapper mapper = session.getMapper(TeacherMapper.class); Teacher teacher = mapper.getTeacher2(1); System.out.println(teacher.getName()); System.out.println(teacher.getStudents()); } 小结 1、关联-association\n2、集合-collection\n3、所以association是用于一对一和多对一，而collection是用于一对多的关系\n4、JavaType和ofType都是用来指定对象类型的\n JavaType是用来指定pojo中属性的类型 ofType指定的是映射到list集合属性中pojo的类型。  注意说明：\n1、保证SQL的可读性，尽量通俗易懂\n2、根据实际要求，尽量编写性能更高的SQL语句\n3、注意属性名和字段不一致的问题\n4、注意一对多和多对一 中：字段和属性对应的问题\n5、尽量使用Log4j，通过日志来查看自己的错误\n一对多和多对一对于很多人来说是难点，一定要大量的做练习理解！\n","date":"2021-11-09T09:56:14+08:00","permalink":"https://example.com/p/mybatis05-%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%92%8C%E5%A4%9A%E5%AF%B9%E4%B8%80%E5%A4%84%E7%90%86/","title":"MyBatis05 一对多和多对一处理"},{"content":"使用注解开发 面向接口编程  大家之前都学过面向对象编程，也学习过接口，但在真正的开发中，很多时候我们会选择面向接口编程 根本原因 : 解耦 , 可拓展 , 提高复用 , 分层开发中 , 上层不用管具体的实现 , 大家都遵守共同的标准 , 使得开发变得容易 , 规范性更好 在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的,对系统设计人员来讲就不那么重要了； 而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。  关于接口的理解   接口从更深层次的理解，应是定义（规范，约束）与实现（名实分离的原则）的分离。\n  接口的本身反映了系统设计人员对系统的抽象理解。\n  接口应有两类：\n   第一类是对一个个体的抽象，它可对应为一个抽象体(abstract class)； 第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface）；    一个体有可能有多个抽象面。抽象体与抽象面是有区别的。\n  三个面向区别   面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性及方法 .\n  面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现 .\n  接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题.更多的体现就是对系统整体的架构\n  利用注解开发   mybatis最初配置信息是基于 XML ,映射语句(SQL)也是定义在 XML 中的。而到MyBatis 3提供了新的基于注解的配置。不幸的是，Java 注解的的表达力和灵活性十分有限。最强大的 MyBatis 映射并不能用注解来构建\n  sql 类型主要分成 :\n   @select () @update () @Insert () @delete ()    **注意：**利用注解开发就不需要mapper.xml映射文件了 .\n1、我们在我们的接口中添加注解\n//查询全部用户 @Select(\u0026#34;select id,name,pwd password from user\u0026#34;) public List\u0026lt;User\u0026gt; getAllUser(); 2、在mybatis的核心配置文件中注入\n\u0026lt;!--使用class绑定接口--\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper class=\u0026#34;com.xxgc.mapper.UserMapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; 3、我们去进行测试\n@Test public void testGetAllUser() { SqlSession session = MybatisUtils.getSession(); //本质上利用了jvm的动态代理机制  UserMapper mapper = session.getMapper(UserMapper.class); List\u0026lt;User\u0026gt; users = mapper.getAllUser(); for (User user : users){ System.out.println(user); } session.close(); } 注解增删改 改造MybatisUtils工具类的getSession( ) 方法，重载实现。\n//获取SqlSession连接  public static SqlSession getSession(){ return getSession(true); //事务自动提交  } public static SqlSession getSession(boolean flag){ return sqlSessionFactory.openSession(flag); } 【注意】确保实体类和数据库字段对应\n查询： 1、编写接口方法注解\n//根据id查询用户 @Select(\u0026#34;select * from user where id = #{id}\u0026#34;) User selectUserById(@Param(\u0026#34;id\u0026#34;) int id); 2、测试\n@Test public void testSelectUserById() { SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.selectUserById(1); System.out.println(user); session.close(); } 在进行多表联合查询的时候，遇到字段不匹配可以使用\n@Results(id = \u0026#34;UserExMap\u0026#34;, value = { @Result(column = \u0026#34;数据库字段名\u0026#34;,property = \u0026#34;类属性名\u0026#34;), @Result(column = \u0026#34;m_money\u0026#34;,property = \u0026#34;money\u0026#34;), @Result(column = \u0026#34;m_type\u0026#34;,property = \u0026#34;type\u0026#34;) }) 注意：只需要配置一次，如果还需要使用的地方用\n@ResultMap(\u0026#34;UserExMap\u0026#34;) 新增： 1、编写接口方法注解\n//添加一个用户 @Insert(\u0026#34;insert into user (id,name,pwd) values (#{id},#{name},#{pwd})\u0026#34;) int addUser(User user); 2、测试\n@Test public void testAddUser() { SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = new User(6, \u0026#34;秦疆\u0026#34;, \u0026#34;123456\u0026#34;); mapper.addUser(user); session.close(); } 修改： 1、编写接口方法注解\n//修改一个用户 @Update(\u0026#34;update user set name=#{name},pwd=#{pwd} where id = #{id}\u0026#34;) int updateUser(User user); 2、测试\n@Test public void testUpdateUser() { SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = new User(6, \u0026#34;秦疆\u0026#34;, \u0026#34;zxcvbn\u0026#34;); mapper.updateUser(user); session.close(); } 删除： 1、编写接口方法注解\n//根据id删除用 @Delete(\u0026#34;delete from user where id = #{id}\u0026#34;) int deleteUser(@Param(\u0026#34;id\u0026#34;)int id); 2、测试\n@Test public void testDeleteUser() { SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); mapper.deleteUser(6); session.close(); } 【注意点：增删改一定记得对事务的处理】\n使用注解进行sql拼接 方法一 //type 类名 method方法名 @SelectProvider(type = UserProvider.class,method = \u0026#34;selectUser\u0026#34;) List\u0026lt;User\u0026gt; selectUserByAttr(@Param(\u0026#34;uId\u0026#34;) int uId, @Param(\u0026#34;uName\u0026#34;)String uName); /*内部内*/ class UserProvider{ /*自定义的方法*/ public String selectUser(Map\u0026lt;String,Object\u0026gt; map){ String sql = \u0026#34;select * from users where 1 = 1 \u0026#34;; if(map.get(\u0026#34;uId\u0026#34;) != null){ sql += \u0026#34;and u_id = #{uId} \u0026#34;; } if(map.get(\u0026#34;uName\u0026#34;) != null \u0026amp;\u0026amp; map.get(\u0026#34;uName\u0026#34;) != \u0026#34;\u0026#34;){ sql += \u0026#34;and u_name = #{uName} \u0026#34;; } return sql; } } 方法二 @Select({ \u0026#34;\u0026lt;script\u0026gt;\u0026#34;, \u0026#34;select * from users\u0026#34;, \u0026#34;\u0026lt;where\u0026gt;\u0026#34;, \u0026#34;\u0026lt;if test=\u0026#39;uId != null\u0026#39;\u0026gt;\u0026#34;, \u0026#34;and u_id = #{uId}\u0026#34;, \u0026#34;\u0026lt;/if\u0026gt;\u0026#34;, \u0026#34;\u0026lt;if test=\u0026#39;uName != null\u0026#39;\u0026gt;\u0026#34;, \u0026#34;and u_name = #{uName}\u0026#34;, \u0026#34;\u0026lt;/if\u0026gt;\u0026#34;, \u0026#34;\u0026lt;/where\u0026gt;\u0026#34;, \u0026#34;\u0026lt;/script\u0026gt;\u0026#34; }) List\u0026lt;User\u0026gt; selectUserByAttr2(@Param(\u0026#34;uId\u0026#34;) int uId, @Param(\u0026#34;uName\u0026#34;)String uName); 关于@Param @Param注解用于给方法参数起一个名字。以下是总结的使用原则：\n 在方法只接受一个参数的情况下，可以不使用@Param。 在方法接受多个参数的情况下，建议一定要使用@Param注解给参数命名。 如果参数是 JavaBean ， 则不能使用@Param。 不使用@Param注解时，参数只能有一个，并且是Javabean。  #与$的区别   #{} 的作用主要是替换预编译语句(PrepareStatement)中的占位符? 【推荐使用】\nINSERT INTO user (name) VALUES (#{name}); INSERT INTO user (name) VALUES (?);   ${} 的作用是直接进行字符串替换\nINSERT INTO user (name) VALUES (\u0026#39;${name}\u0026#39;); INSERT INTO user (name) VALUES (\u0026#39;kuangshen\u0026#39;);   使用注解和配置文件协同开发，才是MyBatis的最佳实践！\n使用注解开发可以提高我们的开发效率，可以合理使用哦！\n","date":"2021-11-09T09:55:20+08:00","permalink":"https://example.com/p/mybatis04-%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/","title":"MyBatis04 使用注解开发"},{"content":"ResultMap 查询为null问题 要解决的问题：属性名和字段名不一致\n环境：新建一个项目，将之前的项目拷贝过来\n1、查看之前的数据库的字段名\nid name pwd\n2、Java中的实体类设计\npublic class User { private int id; //id  private String name; //姓名  private String password; //密码和数据库不一样！ } 3、接口\n//根据id查询用户 User selectUserById(int id); 4、mapper映射文件\n\u0026lt;select id=\u0026#34;selectUserById\u0026#34; resultType=\u0026#34;user\u0026#34;\u0026gt; select * from user where id = #{id} \u0026lt;/select\u0026gt; 5、测试\n@Test public void testSelectUserById() { SqlSession session = MybatisUtils.getSession(); //获取SqlSession连接  UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.selectUserById(1); System.out.println(user); session.close(); } 结果:\n User{id=1, name=\u0026lsquo;张三\u0026rsquo;, password=\u0026lsquo;null\u0026rsquo;} 查询出来发现 password 为空 . 说明出现了问题！  分析：\n  select * from user where id = #{id} 可以看做\nselect id,name,pwd from user where id = #{id}\n  mybatis会根据这些查询的列名(会将列名转化为小写,数据库不区分大小写) , 去对应的实体类中查找相应列名的set方法设值 , 由于找不到setPwd() , 所以password返回null ; 【自动映射】\n  解决方案 方案一：为列名指定别名 , 别名和java实体类的属性名一致 .\n\u0026lt;select id=\u0026#34;selectUserById\u0026#34; resultType=\u0026#34;User\u0026#34;\u0026gt; select id , name , pwd as password from user where id = #{id} \u0026lt;/select\u0026gt; 方案二：使用结果集映射-\u0026gt;ResultMap 【推荐】\n\u0026lt;resultMap id=\u0026#34;UserMap\u0026#34; type=\u0026#34;User\u0026#34;\u0026gt; \u0026lt;!-- id为主键 --\u0026gt; \u0026lt;id column=\u0026#34;id\u0026#34; property=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;!-- column是数据库表的列名 , property是对应实体类的属性名 --\u0026gt; \u0026lt;result column=\u0026#34;name\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;pwd\u0026#34; property=\u0026#34;password\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;selectUserById\u0026#34; resultMap=\u0026#34;UserMap\u0026#34;\u0026gt; select id , name , pwd from user where id = #{id} \u0026lt;/select\u0026gt; ResultMap 自动映射  resultMap 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC ResultSets 数据提取代码中解放出来。 实际上，在为一些比如连接的复杂语句编写映射代码的时候，一份 resultMap 能够代替实现同等功能的长达数千行的代码。 ResultMap 的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句只需要描述它们的关系就行了。  你已经见过简单映射语句的示例了，但并没有显式指定 resultMap。比如：\n\u0026lt;select id=\u0026#34;selectUserById\u0026#34; resultType=\u0026#34;map\u0026#34;\u0026gt; select id , name , pwd from user where id = #{id} \u0026lt;/select\u0026gt; 上述语句只是简单地将所有的列映射到 HashMap 的键上，这由 resultType 属性指定。虽然在大部分情况下都够用，但是 HashMap 不是一个很好的模型。你的程序更可能会使用 JavaBean 或 POJO（Plain Old Java Objects，普通老式 Java 对象）作为模型。\nResultMap 最优秀的地方在于，虽然你已经对它相当了解了，但是根本就不需要显式地用到他们。\n手动映射 1、返回值类型为resultMap\n\u0026lt;select id=\u0026#34;selectUserById\u0026#34; resultMap=\u0026#34;UserMap\u0026#34;\u0026gt; select id , name , pwd from user where id = #{id} \u0026lt;/select\u0026gt; 2、编写resultMap，实现手动映射！\n\u0026lt;resultMap id=\u0026#34;UserMap\u0026#34; type=\u0026#34;User\u0026#34;\u0026gt; \u0026lt;!-- id为主键 --\u0026gt; \u0026lt;id column=\u0026#34;id\u0026#34; property=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;!-- column是数据库表的列名 , property是对应实体类的属性名 --\u0026gt; \u0026lt;result column=\u0026#34;name\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;pwd\u0026#34; property=\u0026#34;password\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; 如果世界总是这么简单就好了。但是肯定不是的，数据库中，存在一对多，多对一的情况，我们之后会使用到一些高级的结果集映射，association，collection这些，我们将在之后讲解，今天你们需要把这些知识都消化掉才是最重要的！理解结果集映射的这个概念！\n分页的几种方式 日志工厂 思考：我们在测试SQL的时候，要是能够在控制台输出 SQL 的话，是不是就能够有更快的排错效率？\n如果一个 数据库相关的操作出现了问题，我们可以根据输出的SQL语句快速排查问题。\n对于以往的开发过程，我们会经常使用到debug模式来调节，跟踪我们的代码执行过程。但是现在使用Mybatis是基于接口，配置文件的源代码执行过程。因此，我们必须选择日志工具来作为我们开发，调节程序的工具。\nMybatis内置的日志工厂提供日志功能，具体的日志实现有以下几种工具：\n SLF4J Apache Commons Logging Log4j 2 Log4j JDK logging  具体选择哪个日志实现工具由MyBatis的内置日志工厂确定。它会使用最先找到的（按上文列举的顺序查找）。如果一个都未找到，日志功能就会被禁用。\n标准日志实现 指定 MyBatis 应该使用哪个日志记录实现。如果此设置不存在，则会自动发现日志记录实现。\n\u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026quot;logImpl\u0026quot; value=\u0026quot;STDOUT_LOGGING\u0026quot;/\u0026gt; \u0026lt;/settings\u0026gt; 测试，可以看到控制台有大量的输出！我们可以通过这些输出来判断程序到底哪里出了Bug\n Log4j\n 简介：  Log4j是Apache的一个开源项目 通过使用Log4j，我们可以控制日志信息输送的目的地：控制台，文本，GUI组件\u0026hellip;. 我们也可以控制每一条日志的输出格式； 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。  使用步骤： 1、导入log4j的包\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.17\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 2、配置文件编写\n#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码 log4j.rootLogger=DEBUG,console,file #控制台输出的相关设置 log4j.appender.console = org.apache.log4j.ConsoleAppender log4j.appender.console.Target = System.out log4j.appender.console.Threshold=DEBUG log4j.appender.console.layout = org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern=[%c]-%m%n #文件输出的相关设置 log4j.appender.file = org.apache.log4j.RollingFileAppender log4j.appender.file.File=./log/kuang.log log4j.appender.file.MaxFileSize=10mb log4j.appender.file.Threshold=DEBUG log4j.appender.file.layout=org.apache.log4j.PatternLayout log4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n #日志输出级别 log4j.logger.org.mybatis=DEBUG log4j.logger.java.sql=DEBUG log4j.logger.java.sql.Statement=DEBUG log4j.logger.java.sql.ResultSet=DEBUG log4j.logger.java.sql.PreparedStatement=DEBUG 3、setting设置日志实现\n\u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026#34;logImpl\u0026#34; value=\u0026#34;LOG4J\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; 4、在程序中使用Log4j进行输出！\n//注意导包：org.apache.log4j.Logger static Logger logger = Logger.getLogger(MyTest.class); @Test public void selectUser() { logger.info(\u0026#34;info：进入selectUser方法\u0026#34;); logger.debug(\u0026#34;debug：进入selectUser方法\u0026#34;); logger.error(\u0026#34;error: 进入selectUser方法\u0026#34;); SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); List\u0026lt;User\u0026gt; users = mapper.selectUser(); for (User user: users){ System.out.println(user); } session.close(); } 5、测试，看控制台输出！\n 使用Log4j 输出日志 可以看到还生成了一个日志的文件 【需要修改file的日志级别】  limit实现分页 思考：为什么需要分页？\n在学习mybatis等持久层框架的时候，会经常对数据进行增删改查操作，使用最多的是对数据库进行查询操作，如果查询大量数据的时候，我们往往使用分页进行查询，也就是每次处理小部分数据，这样对数据库压力就在可控范围内。\n使用Limit实现分页\n#语法 SELECT * FROM table LIMIT stratIndex，pageSize SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15 #为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1： SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last. #如果只给定一个参数，它表示返回最大的记录行数目： SELECT * FROM table LIMIT 5; //检索前 5 个记录行 #换句话说，LIMIT n 等价于 LIMIT 0,n。 步骤：\n1、修改Mapper文件\n\u0026lt;select id=\u0026#34;selectUser\u0026#34; parameterType=\u0026#34;map\u0026#34; resultType=\u0026#34;user\u0026#34;\u0026gt; select * from user limit #{startIndex},#{pageSize} \u0026lt;/select\u0026gt; 2、Mapper接口，参数为map\n//选择全部用户实现分页 List\u0026lt;User\u0026gt; selectUser(Map\u0026lt;String,Integer\u0026gt; map); 3、在测试类中传入参数测试\n 推断：起始位置 = （当前页面 - 1 ） * 页面大小  //分页查询 , 两个参数startIndex , pageSize @Test public void testSelectUser() { SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); int currentPage = 1; //第几页  int pageSize = 2; //每页显示几个  Map\u0026lt;String,Integer\u0026gt; map = new HashMap\u0026lt;String,Integer\u0026gt;(); map.put(\u0026#34;startIndex\u0026#34;,(currentPage-1)*pageSize); map.put(\u0026#34;pageSize\u0026#34;,pageSize); List\u0026lt;User\u0026gt; users = mapper.selectUser(map); for (User user: users){ System.out.println(user); } session.close(); } RowBounds分页 我们除了使用Limit在SQL层面实现分页，也可以使用RowBounds在Java代码层面实现分页，当然此种方式作为了解即可。我们来看下如何实现的！\n步骤： 1、mapper接口\n//选择全部用户RowBounds实现分页 List\u0026lt;User\u0026gt; getUserByRowBounds(); 2、mapper文件\n\u0026lt;select id=\u0026#34;getUserByRowBounds\u0026#34; resultType=\u0026#34;user\u0026#34;\u0026gt; select * from user \u0026lt;/select\u0026gt; 3、测试类\n在这里，我们需要使用RowBounds类\n@Test public void testUserByRowBounds() { SqlSession session = MybatisUtils.getSession(); int currentPage = 2; //第几页  int pageSize = 2; //每页显示几个  RowBounds rowBounds = new RowBounds((currentPage-1)*pageSize,pageSize); //通过session.**方法进行传递rowBounds，[此种方式现在已经不推荐使用了]  List\u0026lt;User\u0026gt; users = session.selectList(\u0026#34;com.xxgc.mapper.UserMapper.getUserByRowBounds\u0026#34;, null, rowBounds); for (User user: users){ System.out.println(user); } session.close(); } PageHelper分页插件 官网地址：https://pagehelper.github.io/\n添加依赖 \u0026lt;!--Mybaits分页查件--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.pagehelper\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pagehelper\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Mybatis配置插件 typeAliases 之后\nenvironments 之前\n\u0026lt;!--MyBatis的插件配置--\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin interceptor=\u0026quot;com.github.pagehelper.PageInterceptor\u0026quot;\u0026gt; \u0026lt;!--表示使用mysql的分页方法--\u0026gt; \u0026lt;property name=\u0026quot;helperDialect\u0026quot; value=\u0026quot;mysql\u0026quot;/\u0026gt; \u0026lt;!--表示当前页码长度为0的时候就不行行分页--\u0026gt; \u0026lt;property name=\u0026quot;pageSizeZero\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; 使用  @Test public void test2(){ //调用工具类 得到sqlSession SqlSession sqlSession = MyBatisUtils.getSqlSession(); //加载dao层映射 MoneyDao mapper = sqlSession.getMapper(MoneyDao.class); //分页第一步 调用接口之前开启分页 PageHelper.startPage(1,5); List\u0026lt;UserEx\u0026gt; userExes = mapper.selectUserMoneyPage(); //分页第二步，对拿到的数据进行处理 PageInfo\u0026lt;UserEx\u0026gt; userExPageInfo = new PageInfo\u0026lt;UserEx\u0026gt;(userExes); logger.info(\u0026quot;总条数\u0026quot;+userExPageInfo.getTotal()); for (UserEx userEx : userExPageInfo.getList()) { System.out.println(\u0026quot;userEx = \u0026quot; + userEx); } //手动关闭sqlsession(学到了spring过后就不需要了) sqlSession.close(); } ","date":"2021-11-09T09:53:47+08:00","permalink":"https://example.com/p/mybatis03-resultmap%E5%8F%8A%E5%88%86%E9%A1%B5/","title":"MyBatis03 ResultMap及分页"},{"content":"CRUD操作  SQL语句返回值类型。【完整的类名或者别名】 传入SQL语句的参数类型 。【万能的Map，可以多尝试使用】 命名空间中唯一的标识符 接口中的方法名与映射文件中的SQL语句ID 一一对应 id parameterType resultType  select 标签  id 相应dao层方法 parameterType 传入参数类型 resultType 返回对象  需求：根据id查询用户\n1、在UserMapper中添加对应方法\npublic interface UserMapper { //根据id查询用户  User selectUserById(int id); } 2、在UserMapper.xml中添加Select语句\n\u0026lt;select id=\u0026#34;selectUserById\u0026#34; resultType=\u0026#34;com.xxgc.pojo.User\u0026#34;\u0026gt; select * from user where id = #{id} \u0026lt;/select\u0026gt; 3、测试类中测试\n@Test public void tsetSelectUserById() { SqlSession session = MybatisUtils.getSession(); //获取SqlSession连接  UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.selectUserById(1); System.out.println(user); session.close(); } insert 标签 需求：给数据库增加一个用户\n1、在UserMapper接口中添加对应的方法\n//添加一个用户 int addUser(User user); 2、在UserMapper.xml中添加insert语句\n\u0026lt;insert id=\u0026#34;addUser\u0026#34; parameterType=\u0026#34;com.xxgc.pojo.User\u0026#34;\u0026gt; \u0026lt;!--对象中的属性值可以直接取出来--\u0026gt; insert into user (id,name,pwd) values (#{id},#{name},#{pwd}) \u0026lt;/insert\u0026gt; 3、测试\n@Test public void testAddUser() { SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = new User(5,\u0026#34;王五\u0026#34;,\u0026#34;zxcvbn\u0026#34;); int i = mapper.addUser(user); System.out.println(i); //提交事务,重点!不写的话不会提交到数据库  session.commit(); session.close(); } 注意点：增、删、改操作需要提交事务！\nupdate标签 需求：修改用户的信息\n1、同理，编写接口方法\n//修改一个用户 int updateUser(User user); 2、编写对应的配置文件SQL\n\u0026lt;update id=\u0026#34;updateUser\u0026#34; parameterType=\u0026#34;com.xxgc.pojo.User\u0026#34;\u0026gt; update user set name=#{name},pwd=#{pwd} where id = #{id} \u0026lt;/update\u0026gt; 3、测试\n@Test public void testUpdateUser() { SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.selectUserById(1); user.setPwd(\u0026#34;asdfgh\u0026#34;); int i = mapper.updateUser(user); System.out.println(i); session.commit(); session.close(); } delete标签 需求：根据id删除一个用户\n1、同理，编写接口方法\n//根据id删除用户 int deleteUser(int id); 2、编写对应的配置文件SQL\n\u0026lt;delete id=\u0026#34;deleteUser\u0026#34; parameterType=\u0026#34;int\u0026#34;\u0026gt; delete from user where id = #{id} \u0026lt;/delete\u0026gt; 3、测试\n@Test public void testDeleteUser() { SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); int i = mapper.deleteUser(5); System.out.println(i); session.commit(); session.close(); } 模糊查询 第1种：在Java代码中添加sql通配符。\nstring wildcardname = “%smi%”; list\u0026lt;name\u0026gt; names = mapper.selectlike(wildcardname); \u0026lt;select id=”selectlike”\u0026gt; select * from foo where bar like #{value} \u0026lt;/select\u0026gt; 第2种：在sql语句中拼接通配符，会引起sql注入\nstring wildcardname = “smi”; list\u0026lt;name\u0026gt; names = mapper.selectlike(wildcardname); \u0026lt;select id=”selectlike”\u0026gt; select * from foo where bar like \u0026quot;%\u0026quot;#{value}\u0026quot;%\u0026quot; \u0026lt;/select\u0026gt; 第3种：使用CONCA()函数\n\u0026lt;select id=\u0026#34;selectUsersByLike\u0026#34; parameterType=\u0026#34;String\u0026#34; resultType=\u0026#34;com.xxgc.pojo.User\u0026#34;\u0026gt; select * from user where name like CONCAT(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;); \u0026lt;/select\u0026gt; 小结：\n 所有的增删改操作都需要提交事务！ 接口所有的普通参数，尽量都写上@Param参数，尤其是多个参数时，必须写上！ 有时候根据业务的需求，可以考虑使用map传递参数！ 为了规范操作，在SQL的配置文件中，我们尽量将Parameter参数和resultType都写上！  多参数传递 1、在接口方法的参数前加 @Param属性\n2、Sql语句编写的时候，直接取@Param中设置的值即可，不需要单独设置参数类型\n//通过密码和名字查询用户 User selectUserByNP(@Param(\u0026quot;name\u0026quot;) String username,@Param(\u0026quot;pwd\u0026quot;) String pwd); /* \u0026lt;select id=\u0026quot;selectUserByNP\u0026quot; resultType=\u0026quot;com.kuang.pojo.User\u0026quot;\u0026gt; select * from user where name = #{username} and pwd = #{pwd} \u0026lt;/select\u0026gt; */ 思路二：使用万能的Map\n1、在接口方法中，参数直接传递Map；\nUser selectUserByNP2(Map\u0026lt;String,Object\u0026gt; map); 2、编写sql语句的时候，需要传递参数类型，参数类型为map\n\u0026lt;select id=\u0026quot;selectUserByNP2\u0026quot; parameterType=\u0026quot;map\u0026quot; resultType=\u0026quot;com.kuang.pojo.User\u0026quot;\u0026gt; select * from user where name = #{username} and pwd = #{pwd} \u0026lt;/select\u0026gt; 3、在使用方法的时候，Map的 key 为 sql中取的值即可，没有顺序要求！\nMap\u0026lt;String, Object\u0026gt; map = new HashMap\u0026lt;String, Object\u0026gt;(); map.put(\u0026quot;username\u0026quot;,\u0026quot;小明\u0026quot;); map.put(\u0026quot;pwd\u0026quot;,\u0026quot;123456\u0026quot;); User user = mapper.selectUserByNP2(map); 总结：如果参数过多，我们可以考虑直接使用Map实现，如果参数比较少，直接传递参数即可\n常用配置 mybatis环境配置 environments节点 \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;...\u0026#34; value=\u0026#34;...\u0026#34;/\u0026gt; \u0026lt;/transactionManager\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;${driver}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${password}\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt;   配置MyBatis的多套运行环境，将SQL映射到多个不同的数据库上，必须指定其中一个为默认运行环境（通过default指定）\n  子元素节点：environment\n    dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。\n  数据源是必须配置的。\n  有三种内建的数据源类型\ntype=\u0026quot;[UNPOOLED|POOLED|JNDI]\u0026quot;）   unpooled：这个数据源的实现只是每次被请求时打开和关闭连接。\n  pooled：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来 , 这是一种使得并发 Web 应用快速响应请求的流行处理方式。\n  jndi：这个数据源的实现是为了能在如 Spring 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。\n  数据源也有很多第三方的实现，比如dbcp，c3p0，druid等等\u0026hellip;.\n  详情：点击查看官方文档\n  这两种事务管理器类型都不需要设置任何属性。\n  具体的一套环境，通过设置id进行区别，id保证唯一！\n  子元素节点：transactionManager - [ 事务管理器 ]\n\u0026lt;!-- 语法 --\u0026gt; \u0026lt;transactionManager type=\u0026quot;[ JDBC | MANAGED ]\u0026quot;/\u0026gt;   子元素节点：数据源（dataSource）\n    mappers节点  映射器 : 定义映射SQL语句文件 既然 MyBatis 的行为其他元素已经配置完了，我们现在就要定义 SQL 映射语句了。但是首先我们需要告诉 MyBatis 到哪里去找到这些语句。Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。你可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 file:/// 的 URL），或类名和包名等。映射器是MyBatis中最核心的组件之一，在MyBatis 3之前，只支持xml映射器，即：所有的SQL语句都必须在xml文件中配置。而从MyBatis 3开始，还支持接口映射器，这种映射器方式允许以Java代码的方式注解定义SQL语句，非常简洁。  引入资源方式\n\u0026lt;!-- 使用相对于类路径的资源引用 --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;org/mybatis/builder/PostMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;!-- 使用完全限定资源定位符（URL） --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper url=\u0026#34;file:///var/mappers/AuthorMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;!-- 使用映射器接口实现类的完全限定类名 需要配置文件名称和接口名称一致，并且位于同一目录下 --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper class=\u0026#34;org.mybatis.builder.AuthorMapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;!-- 将包内的映射器接口实现全部注册为映射器 但是需要配置文件名称和接口名称一致，并且位于同一目录下 --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;package name=\u0026#34;org.mybatis.builder\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; Mapper文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.xxgc.mybatis.mapper.UserMapper\u0026#34;\u0026gt; \u0026lt;/mapper\u0026gt;   namespace中文意思：命名空间，作用如下：\n   namespace的命名必须跟某个接口同名 接口中的方法与映射文件中sql语句id应该一一对应     namespace和子元素的id联合保证唯一 , 区别不同的mapper 绑定DAO接口 namespace命名规则 : 包名+类名    MyBatis 的真正强大在于它的映射语句，这是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 为聚焦于 SQL 而构建，以尽可能地为你减少麻烦。\nProperties优化 数据库这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。具体的官方文档\n我们来优化我们的配置文件\n第一步 ; 在资源目录下新建一个db.properties\ndriver=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/mybatis?useSSL=true\u0026amp;useUnicode=true\u0026amp;characterEncoding=utf8 username=root password=123456 第二步 : 将文件导入properties 配置文件\n\u0026lt;configuration\u0026gt; \u0026lt;!--导入properties文件--\u0026gt; \u0026lt;properties resource=\u0026#34;db.properties\u0026#34;/\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;${driver}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${password}\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;mapper/UserMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt; typeAliases优化 类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。\n\u0026lt;!--配置别名,注意顺序--\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;typeAlias type=\u0026#34;com.xxgc.mybatis.pojo.User\u0026#34; alias=\u0026#34;User\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如:\n\u0026lt;typeAliases\u0026gt; \u0026lt;package name=\u0026#34;com.xxgc.mybatis.pojo\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; 每一个在包 com.xxgc.mybatis.pojo 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。\n若有注解，则别名为其注解值。见下面的例子：\n@Alias(\u0026#34;user\u0026#34;) public class User { ... } 其他配置浏览 设置\n  设置（settings）相关 =\u0026gt; 查看帮助文档\n   懒加载 日志实现 缓存开启关闭    一个配置完整的 settings 元素的示例如下：\n\u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026#34;cacheEnabled\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;lazyLoadingEnabled\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;multipleResultSetsEnabled\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;useColumnLabel\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;useGeneratedKeys\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;autoMappingBehavior\u0026#34; value=\u0026#34;PARTIAL\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;autoMappingUnknownColumnBehavior\u0026#34; value=\u0026#34;WARNING\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;defaultExecutorType\u0026#34; value=\u0026#34;SIMPLE\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;defaultStatementTimeout\u0026#34; value=\u0026#34;25\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;defaultFetchSize\u0026#34; value=\u0026#34;100\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;safeRowBoundsEnabled\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;mapUnderscoreToCamelCase\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;localCacheScope\u0026#34; value=\u0026#34;SESSION\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;jdbcTypeForNull\u0026#34; value=\u0026#34;OTHER\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;lazyLoadTriggerMethods\u0026#34; value=\u0026#34;equals,clone,hashCode,toString\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt;   类型处理器\n 无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。 你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。【了解即可】  对象工厂\n MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。 默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过有参构造方法来实例化。 如果想覆盖对象工厂的默认行为，则可以通过创建自己的对象工厂来实现。【了解即可】  生命周期和作用域 作用域（Scope）和生命周期\n  理解到目前为止所讨论的类的作用域和生命周期是非常重要的。如果使用不当可导致严重的并发性问题。\nSqlSessionFactoryBuilder\n这个类可以在任何时候被实例化、使用和销毁。一旦您创造了SqlSessionFactory 就不需要再保留它了。所以SqlSessionFactoryBuilder 实例的最好的作用域是方法体内(即一个本地方法变量)。您能重用SqlSessionFactoryBuilder 创建多个SqlSessionFactory 实例，但最好不要把时间、资源放在解析XML 文件上，而是要从中解放出来做最重要事情。\nSqlSessionFactory\n一旦创建，SqlSessionFactory 将会存在于您的应用程序整个运行生命周期中。很少或根本没有理由去销毁它或重新创建它。最佳实践是不要在一个应用中多次创建SqlSessionFactory。这样做会被视为“没品味”。所是SqlSessionFactory 最好的作用域范围是一个应用的生命周期范围。这可以由多种方式来实现，最简单的方式是使用Singleton 模式或静态Singleton 模式。但这不是被广泛接受的最佳做法，相反，您可能更愿意使用像Google Guice 或Spring 的依赖注入方式。这些框架允许您创造一个管理器，用于管理SqlSessionFactory 的生命周期。\nSqlSession\n每个线程都有一个SqlSession 实例，SqlSession 实例是不被共享的，并且不是线程安全的。因此最好的作用域是request 或者method。决不要用一个静态字段或者一个类的实例字段来保存SqlSession 实例引用。也不要用任何一个管理作用域，如Servlet 框架中的HttpSession，来保存SqlSession 的引用。如果您正在用一个WEB 框架，可以把SqlSession 的作用域看作类似于HTTP 的请求范围。也就是说，在收到一个HTTP 请求，您可以打开一个SqlSession，当您把response 返回时，就可以把SqlSession 关闭。关闭会话是非常重要的，您应该要确保会话在一个finally 块中被关闭。\nSqlSession session = sqlSessionFactory.openSession(); try { // do work } finally { session.close(); } ​\t在您的代码里都使用这一模式将保证所有的数据库资源被正确地关闭(假如您没有把您自己\n的数据库连接传递给MyBatis 管理，这就对MyBatis 表明您希望自己管理连接)。\nMapper 实例\nMappers 是创建来绑定映射语句的接口，该Mapper 实例是从SqlSession 得到的。所有mapper 实例的作用域跟创建它的SqlSession 一样。但是，mapper 实例最好的作用域是method，也就是它们应该在方法内被调用，使用完即被销毁。并且mapper 实例不用显式地被关闭。虽然把mapper 实例保持在一个request 范围(与SqlSession 相似)不会产生太大的问题，但是您可能会发现，在这个层次上管理太多资源可能会失控。保持简单，就是让Mappers 保持在一个方法内。\nSqlSession session = sqlSessionFactory.openSession(); try { BlogMapper mapper = session.getMapper(BlogMapper.class); // do work } finally { session.close(); }   ","date":"2021-11-09T09:52:53+08:00","permalink":"https://example.com/p/mybatis02-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/","title":"MyBatis02 增删改查"},{"content":"MyBatis简介 什么是MyBatis   MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。\n  MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集的过程\n  MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 实体类 【Plain Old Java Objects,普通的 Java对象】映射成数据库中的记录。\n  Mybatis的历史   MyBatis 本是apache的一个开源项目ibatis, 2010年这个项目由apache 迁移到了google code，并且改名为MyBatis 。\n  2013年11月迁移到Github .\n  Mybatis官方文档 : http://www.mybatis.org/mybatis-3/zh/index.html\n  GitHub : https://github.com/mybatis/mybatis-3\n  持久化 持久化是将程序数据在持久状态和瞬时状态间转换的机制。\n 即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。 JDBC就是一种持久化机制。文件IO也是一种持久化机制。  为什么需要持久化服务呢？那是由于内存本身的缺陷引起的\n 内存断电后数据会丢失，但有一些对象是无论如何都不能丢失的，比如银行账号等，遗憾的是，人们还无法保证内存永不掉电。 内存过于昂贵，与硬盘、光盘等外存相比。所以即使对象不需要永久保存，也会因为内存的容量限制不能一直呆在内存中，需要持久化来缓存到外存。  持久层 什么是持久层？\n 完成持久化工作的代码块 . \u0026mdash;-\u0026gt; dao层 【DAO (Data Access Object) 数据访问对象】 大多数情况下特别是企业级应用，数据持久化往往也就意味着将内存中的数据保存到磁盘上加以固化，而持久化的实现过程则大多通过各种关系数据库来完成。 不过这里有一个字需要特别强调，也就是所谓的“层”。对于应用系统而言，数据持久功能大多是必不可少的组成部分。也就是说，我们的系统中，已经天然的具备了“持久层”概念？也许是，但也许实际情况并非如此。之所以要独立出一个“持久层”的概念,而不是“持久模块”，“持久单元”，也就意味着，我们的系统架构中，应该有一个相对独立的逻辑层面，专注于数据持久化逻辑的实现. 与系统其他部分相对而言，这个层面应该具有一个较为清晰和严格的逻辑边界。【说白了就是用来操作数据库存在的！】  为什么需要Mybatis   Mybatis就是帮助程序猿将数据存入数据库中 , 和从数据库中取数据 .\n  传统的jdbc操作 , 有很多重复代码块 ，比如 : 数据取出时的封装 , 数据库的建立连接等等\u0026hellip; , 通过框架可以减少重复代码,提高开发效率 .\n  MyBatis 是一个半自动化的ORM框架 (Object Relationship Mapping) \u0026ndash;\u0026gt;对象关系映射\n  所有的事情，不用Mybatis依旧可以做到，只是用了它，所有实现会更加简单！技术没有高低之分，只有使用这个技术的人有高低之别\n  MyBatis的优点\n   简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件就可以了，易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。 灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。 解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。 提供xml标签，支持编写动态sql。 \u0026hellip;\u0026hellip;.    最重要的一点，使用的人多！公司需要！\n  MyBatis 测试 搭建实验数据库 CREATEDATABASE`mybatis`;USE`mybatis`;DROPTABLEIFEXISTS`user`;CREATETABLE`user`(`id`int(20)NOTNULL,`name`varchar(30)DEFAULTNULL,`pwd`varchar(30)DEFAULTNULL,PRIMARYKEY(`id`))ENGINE=InnoDBDEFAULTCHARSET=utf8;insertinto`user`(`id`,`name`,`pwd`)values(1,\u0026#39;张三\u0026#39;,\u0026#39;abcdef\u0026#39;),(2,\u0026#39;李四\u0026#39;,\u0026#39;987654\u0026#39;);导入MyBatis相关 jar 包 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.47\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 编写MyBatis核心配置文件 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;!--核心配置文件--\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!--environments 环境 --\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;!--事务 JDBC的事务--\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;!--serverTimezone=GMT 时区--\u0026gt; \u0026lt;!--useSSL=true 通道加密--\u0026gt; \u0026lt;!--useUnicode=true 自定义编码--\u0026gt; \u0026lt;!--characterEncoding=UTF-8 设置编码为UTF-8--\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis?serverTimezone=GMT\u0026amp;amp; useSSL=true\u0026amp;amp;useUnicode=true\u0026amp;amp;characterEncoding=UTF-8\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;123456\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;/configuration\u0026gt; 编写MyBatis工具类获取SqlSession //Mybaits工具类，用来获取sqlSession public class MyBatisUtils { private static SqlSessionFactory sqlSessionFactory; static { try { //以下三步通过配置文件来获取sqlSessionFactory  String resource = \u0026#34;mybatis-config.xml\u0026#34;; InputStream inputStream = Resources.getResourceAsStream(resource); /* ctrl + alt + f 提取/抽取 全局变量 */ sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e){ e.printStackTrace(); } } public static SqlSession getSqlSession(){ /* ctrl + alt + v 自动生成返回结果 */ SqlSession sqlSession = sqlSessionFactory.openSession(); return sqlSession; } } 创建实体类 public class User { private int id; private String name; private String pwd; } 编写Mapper(DAO)接口类 //用户表Dao层接口 public interface UserDao { //查询所有用户  List\u0026lt;User\u0026gt; selectAllUsers(); } 编写Mapper.xml配置文件  namespace 十分重要，不能写错！  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;!--映射一个/绑定一个 dao层接口--\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.xxgc.UserDao\u0026#34;\u0026gt; \u0026lt;!--id 对应接口里的方法名 --\u0026gt; \u0026lt;!--resultType 返回结果类型--\u0026gt; \u0026lt;select id=\u0026#34;selectAllUsers\u0026#34; resultType=\u0026#34;com.xxgc.User\u0026#34;\u0026gt; select * from users; \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 添加Mapper映射 \u0026lt;!--每一个持久层接口都对应一个mapper文件 mapper文件需要手动注入--\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;com\\xxgc\\mybatis\\dao\\UserDaoMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; 开启驼峰命名 \u0026lt;!--开启驼峰命名,将数据库中的_ 修改为下一个字母大写--\u0026gt; \u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026#34;mapUnderscoreToCamelCase\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; 编写测试类  Junit 包测试  @Test public void test(){ //调用工具类 得到sqlSession  SqlSession sqlSession = MyBatisUtils.getSqlSession(); //加载dao层映射  UserDao mapper = sqlSession.getMapper(UserDao.class); //通过调用接口执行语句  List\u0026lt;User\u0026gt; users = mapper.selectAllUsers(); //循环打印内容  for (User user : users) { System.out.println(\u0026#34;user = \u0026#34; + user); } //手动关闭sqlsession(学到了spring过后就不需要了)  sqlSession.close(); } 运行测试，成功的查询出来的我们的数据，ok！\n问题说明 可能出现问题说明：Maven静态资源过滤问题\n\u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/java\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/resources\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; ","date":"2021-11-09T09:50:26+08:00","permalink":"https://example.com/p/mybatis01-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","title":"MyBatis01 环境配置"},{"content":"拦截器以及文件的上传和下载 拦截器 概述 SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。\n**过滤器与拦截器的区别：**拦截器是AOP思想的具体应用。\n过滤器\n servlet规范中的一部分，任何java web工程都可以使用 在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截  拦截器\n 拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用 拦截器只会拦截访问的控制器方法， 如果访问的是jsp/html/css/image/js是不会进行拦截的  自定义拦截器 那如何实现拦截器呢？\n想要自定义拦截器，必须实现 HandlerInterceptor 接口。\n1、新建一个Moudule ， springmvc-07-Interceptor ， 添加web支持\n2、配置web.xml 和 springmvc-servlet.xml 文件\n3、编写一个拦截器\npackage com.kuang.interceptor; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class MyInterceptor implements HandlerInterceptor { //在请求处理的方法之前执行  //如果返回true执行下一个拦截器  //如果返回false就不执行下一个拦截器  public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception { System.out.println(\u0026#34;------------处理前------------\u0026#34;); return true; } //在请求处理方法执行之后执行  public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception { System.out.println(\u0026#34;------------处理后------------\u0026#34;); } //在dispatcherServlet处理后执行,做清理工作.  public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponsehttpServletResponse, Object o, Exception e) throws Exception { System.out.println(\u0026#34;------------清理------------\u0026#34;); } } 4、在springmvc的配置文件中配置拦截器\n\u0026lt;!--关于拦截器的配置--\u0026gt; \u0026lt;mvc:interceptors\u0026gt; \u0026lt;mvc:interceptor\u0026gt; \u0026lt;!--/** 包括路径及其子路径--\u0026gt; \u0026lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--\u0026gt; \u0026lt;!--/admin/** 拦截的是/admin/下的所有--\u0026gt; \u0026lt;mvc:mapping path=\u0026#34;/**\u0026#34;/\u0026gt; \u0026lt;!--bean配置的就是拦截器--\u0026gt; \u0026lt;bean class=\u0026#34;com.kuang.interceptor.MyInterceptor\u0026#34;/\u0026gt; \u0026lt;/mvc:interceptor\u0026gt; \u0026lt;/mvc:interceptors\u0026gt; 5、编写一个Controller，接收请求\n//测试拦截器的控制器 @Controller public class InterceptorController { @RequestMapping(\u0026#34;/interceptor\u0026#34;) @ResponseBody public String testFunction() { System.out.println(\u0026#34;控制器中的方法执行了\u0026#34;); return \u0026#34;hello\u0026#34;; } } 6、前端 index.jsp\n\u0026lt;a href=\u0026#34;${pageContext.request.contextPath}/interceptor\u0026#34;\u0026gt;拦截器测试\u0026lt;/a\u0026gt; 7、启动tomcat 测试一下！\n验证用户是否登录 (认证用户) 实现思路 1、有一个登陆页面，需要写一个controller访问页面。\n2、登陆页面有一提交表单的动作。需要在controller中处理。判断用户名密码是否正确。如果正确，向session中写入用户信息。返回登陆成功。\n3、拦截用户请求，判断用户是否登陆。如果用户已经登陆。放行， 如果用户未登陆，跳转到登陆页面\n测试： 1、编写一个登陆页面 login.jsp\n\u0026lt;%@ page contentType=\u0026quot;text/html;charset=UTF-8\u0026quot; language=\u0026quot;java\u0026quot; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;h1\u0026gt;登录页面\u0026lt;/h1\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026quot;${pageContext.request.contextPath}/user/login\u0026quot;\u0026gt; 用户名：\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;username\u0026quot;\u0026gt; \u0026lt;br\u0026gt; 密码：\u0026lt;input type=\u0026quot;password\u0026quot; name=\u0026quot;pwd\u0026quot;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;提交\u0026quot;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 2、编写一个Controller处理请求\n@Controller @RequestMapping(\u0026#34;/user\u0026#34;) public class UserController { //跳转到登陆页面  @RequestMapping(\u0026#34;/jumplogin\u0026#34;) public String jumpLogin() throws Exception { return \u0026#34;login\u0026#34;; } //跳转到成功页面  @RequestMapping(\u0026#34;/jumpSuccess\u0026#34;) public String jumpSuccess() throws Exception { return \u0026#34;success\u0026#34;; } //登陆提交  @RequestMapping(\u0026#34;/login\u0026#34;) public String login(HttpSession session, String username, String pwd) throws Exception { // 向session记录用户身份信息  System.out.println(\u0026#34;接收前端===\u0026#34;+username); session.setAttribute(\u0026#34;user\u0026#34;, username); return \u0026#34;success\u0026#34;; } //退出登陆  @RequestMapping(\u0026#34;logout\u0026#34;) public String logout(HttpSession session) throws Exception { // session 过期  session.invalidate(); return \u0026#34;login\u0026#34;; } } 3、编写一个登陆成功的页面 success.jsp\n\u0026lt;%@ page contentType=\u0026quot;text/html;charset=UTF-8\u0026quot; language=\u0026quot;java\u0026quot; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;登录成功页面\u0026lt;/h1\u0026gt; \u0026lt;hr\u0026gt; ${user} \u0026lt;a href=\u0026quot;${pageContext.request.contextPath}/user/logout\u0026quot;\u0026gt;注销\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 4、在 index 页面上测试跳转！启动Tomcat 测试，未登录也可以进入主页！\n\u0026lt;%@ page contentType=\u0026quot;text/html;charset=UTF-8\u0026quot; language=\u0026quot;java\u0026quot; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;$Title$\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;首页\u0026lt;/h1\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;%--登录--%\u0026gt; \u0026lt;a href=\u0026quot;${pageContext.request.contextPath}/user/jumplogin\u0026quot;\u0026gt;登录\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;${pageContext.request.contextPath}/user/jumpSuccess\u0026quot;\u0026gt;成功页面\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 5、编写用户登录拦截器\npackage com.kuang.interceptor; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import javax.servlet.ServletException; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.io.IOException; public class LoginInterceptor implements HandlerInterceptor { public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throwsServletException, IOException { // 如果是登陆页面则放行  System.out.println(\u0026#34;uri: \u0026#34; + request.getRequestURI()); if (request.getRequestURI().contains(\u0026#34;login\u0026#34;)) { return true; } HttpSession session = request.getSession(); // 如果用户已登陆也放行  if(session.getAttribute(\u0026#34;user\u0026#34;) != null) { return true; } // 用户没有登陆跳转到登陆页面  request.getRequestDispatcher(\u0026#34;/WEB-INF/jsp/login.jsp\u0026#34;).forward(request, response); return false; } public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception { } public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponsehttpServletResponse, Object o, Exception e) throws Exception { } } 6、在Springmvc的配置文件中注册拦截器\n\u0026lt;!--关于拦截器的配置--\u0026gt; \u0026lt;mvc:interceptors\u0026gt; \u0026lt;mvc:interceptor\u0026gt; \u0026lt;mvc:mapping path=\u0026#34;/**\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;loginInterceptor\u0026#34; class=\u0026#34;com.kuang.interceptor.LoginInterceptor\u0026#34;/\u0026gt; \u0026lt;/mvc:interceptor\u0026gt; \u0026lt;/mvc:interceptors\u0026gt; 7、再次重启Tomcat测试！\nOK，测试登录拦截功能无误.\n文件上传和下载 准备工作 文件上传是项目开发中最常见的功能之一 ,springMVC 可以很好的支持文件上传，但是SpringMVC上下文中默认没有装配MultipartResolver，因此默认情况下其不能处理文件上传工作。如果想使用Spring的文件上传功能，则需要在上下文中配置MultipartResolver。\n前端表单要求：为了能上传文件，必须将表单的method设置为POST，并将enctype设置为multipart/form-data。只有在这样的情况下，浏览器才会把用户选择的文件以二进制数据发送给服务器；\n对表单中的 enctype 属性做个详细的说明：\n application/x-www=form-urlencoded：默认方式，只处理表单域中的 value 属性值，采用这种编码方式的表单会将表单域中的值处理成 URL 编码方式。 multipart/form-data：这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会把文件域指定文件的内容也封装到请求参数中，不会对字符编码。 text/plain：除了把空格转换为 \u0026ldquo;+\u0026rdquo; 号外，其他字符都不做编码处理，这种方式适用直接通过表单发送邮件。  \u0026lt;form action=\u0026#34;\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; 一旦设置了enctype为multipart/form-data，浏览器即会采用二进制流的方式来处理表单数据，而对于文件上传的处理则涉及在服务器端解析原始的HTTP响应。在2003年，Apache Software Foundation发布了开源的Commons FileUpload组件，其很快成为Servlet/JSP程序员上传文件的最佳选择。\n Servlet3.0规范已经提供方法来处理文件上传，但这种上传需要在Servlet中完成。 而Spring MVC则提供了更简单的封装。 Spring MVC为文件上传提供了直接的支持，这种支持是用即插即用的MultipartResolver实现的。 Spring MVC使用Apache Commons FileUpload技术实现了一个MultipartResolver实现类： CommonsMultipartResolver。因此，SpringMVC的文件上传还需要依赖Apache Commons FileUpload的组件。  文件上传 1、导入文件上传的jar包，commons-fileupload ， Maven会自动帮我们导入他的依赖包 commons-io包；\n\u0026lt;!--文件上传--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-fileupload\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-fileupload\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--servlet-api导入高版本的--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 2、配置bean：multipartResolver\n【注意！！！这个bena的id必须为：multipartResolver ， 否则上传文件会报400的错误！在这里栽过坑,教训！】\n\u0026lt;!--文件上传配置--\u0026gt; \u0026lt;bean id=\u0026#34;multipartResolver\u0026#34; class=\u0026#34;org.springframework.web.multipart.commons.CommonsMultipartResolver\u0026#34;\u0026gt; \u0026lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --\u0026gt; \u0026lt;property name=\u0026#34;defaultEncoding\u0026#34; value=\u0026#34;utf-8\u0026#34;/\u0026gt; \u0026lt;!-- 上传文件大小上限，单位为字节（10485760=10M） --\u0026gt; \u0026lt;property name=\u0026#34;maxUploadSize\u0026#34; value=\u0026#34;10485760\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;maxInMemorySize\u0026#34; value=\u0026#34;40960\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; CommonsMultipartFile 的 常用方法：\n String getOriginalFilename()：获取上传文件的原名 InputStream getInputStream()：获取文件流 void transferTo(File dest)：将上传文件保存到一个目录文件中  我们去实际测试一下\n3、编写前端页面\n\u0026lt;form action=\u0026#34;/upload\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;upload\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; 4、Controller\n@Controller public class FileController { //@RequestParam(\u0026#34;file\u0026#34;) 将name=file控件得到的文件封装成CommonsMultipartFile 对象  //批量上传CommonsMultipartFile则为数组即可  @RequestMapping(\u0026#34;/upload\u0026#34;) public String fileUpload(@RequestParam(\u0026#34;file\u0026#34;) CommonsMultipartFile file , HttpServletRequest request) throwsIOException { //获取文件名 : file.getOriginalFilename();  String uploadFileName = file.getOriginalFilename(); //如果文件名为空，直接回到首页！  if (\u0026#34;\u0026#34;.equals(uploadFileName)){ return \u0026#34;redirect:/index.jsp\u0026#34;; } System.out.println(\u0026#34;上传文件名 : \u0026#34;+uploadFileName); //上传路径保存设置  String path = request.getServletContext().getRealPath(\u0026#34;/upload\u0026#34;); //如果路径不存在，创建一个  File realPath = new File(path); if (!realPath.exists()){ realPath.mkdir(); } System.out.println(\u0026#34;上传文件保存地址：\u0026#34;+realPath); InputStream is = file.getInputStream(); //文件输入流  OutputStream os = new FileOutputStream(new File(realPath,uploadFileName)); //文件输出流  //读取写出  int len=0; byte[] buffer = new byte[1024]; while ((len=is.read(buffer))!=-1){ os.write(buffer,0,len); os.flush(); } os.close(); is.close(); return \u0026#34;redirect:/index.jsp\u0026#34;; } } 5、测试上传文件，OK！\n采用file.Transto 来保存上传的文件 1、编写Controller\n/* * 采用file.Transto 来保存上传的文件 */ @RequestMapping(\u0026#34;/upload2\u0026#34;) public String fileUpload2(@RequestParam(\u0026#34;file\u0026#34;) CommonsMultipartFile file, HttpServletRequest request) throwsIOException { //上传路径保存设置  String path = request.getServletContext().getRealPath(\u0026#34;/upload\u0026#34;); File realPath = new File(path); if (!realPath.exists()){ realPath.mkdir(); } //上传文件地址  System.out.println(\u0026#34;上传文件保存地址：\u0026#34;+realPath); //通过CommonsMultipartFile的方法直接写文件（注意这个时候）  file.transferTo(new File(realPath +\u0026#34;/\u0026#34;+ file.getOriginalFilename())); return \u0026#34;redirect:/index.jsp\u0026#34;; } 2、前端表单提交地址修改\n3、访问提交测试，OK！\n文件下载 文件下载步骤：\n1、设置 response 响应头\n2、读取文件 \u0026ndash; InputStream\n3、写出文件 \u0026ndash; OutputStream\n4、执行操作\n5、关闭流 （先开后关）\n代码实现：\n@RequestMapping(value=\u0026#34;/download\u0026#34;) public String downloads(HttpServletResponse response ,HttpServletRequest request) throws Exception{ //要下载的图片地址  String path = request.getServletContext().getRealPath(\u0026#34;/upload\u0026#34;); String fileName = \u0026#34;基础语法.jpg\u0026#34;; //1、设置response 响应头  response.reset(); //设置页面不缓存,清空buffer  response.setCharacterEncoding(\u0026#34;UTF-8\u0026#34;); //字符编码  response.setContentType(\u0026#34;multipart/form-data\u0026#34;); //二进制传输数据  //设置响应头  response.setHeader(\u0026#34;Content-Disposition\u0026#34;, \u0026#34;attachment;fileName=\u0026#34;+URLEncoder.encode(fileName, \u0026#34;UTF-8\u0026#34;)); File file = new File(path,fileName); //2、 读取文件--输入流  InputStream input=new FileInputStream(file); //3、 写出文件--输出流  OutputStream out = response.getOutputStream(); byte[] buff =new byte[1024]; int index=0; //4、执行 写出操作  while((index= input.read(buff))!= -1){ out.write(buff, 0, index); out.flush(); } out.close(); input.close(); return null; } 前端\n\u0026lt;a href=\u0026#34;/download\u0026#34;\u0026gt;点击下载\u0026lt;/a\u0026gt; 测试，文件下载OK，大家可以和我们之前学习的JavaWeb原生的方式对比一下，就可以知道这个便捷多了!\n拦截器及文件操作在我们开发中十分重要，一定要学会使用！\n","date":"2021-11-09T09:43:55+08:00","permalink":"https://example.com/p/springmvc08-%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B8%8E%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/","title":"SpringMVC08 拦截器与文件上传下载"},{"content":"Ajax研究 简介   AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。\n  AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。\n  Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。\n  在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。Google Suggest能够自动帮你完成搜索单词。\n  Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。\n  就和国内百度的搜索框一样!\n  传统的网页(即不用ajax技术的网页)，想要更新内容或者提交一个表单，都需要重新加载整个网页。\n  使用ajax技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。\n  使用Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的Web用户界面。\n  伪造Ajax 我们可以使用前端的一个标签来伪造一个ajax的样子。iframe标签\n1、新建一个module ：sspringmvc-06-ajax ， 导入web支持！\n2、编写一个 ajax-frame.html 使用 iframe 测试，感受下效果\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;kuangshen\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; window.onload = function(){ var myDate = new Date(); document.getElementById(\u0026#39;currentTime\u0026#39;).innerText = myDate.getTime(); }; function LoadPage(){ var targetUrl = document.getElementById(\u0026#39;url\u0026#39;).value; console.log(targetUrl); document.getElementById(\u0026#34;iframePosition\u0026#34;).src = targetUrl; } \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;请输入要加载的地址：\u0026lt;span id=\u0026#34;currentTime\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;input id=\u0026#34;url\u0026#34; type=\u0026#34;text\u0026#34; value=\u0026#34;https://www.baidu.com/\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;提交\u0026#34; onclick=\u0026#34;LoadPage()\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;加载页面位置：\u0026lt;/h3\u0026gt; \u0026lt;iframe id=\u0026#34;iframePosition\u0026#34; style=\u0026#34;width: 100%;height: 500px;\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 3、使用IDEA开浏览器测试一下！\n利用AJAX可以做：\n 注册时，输入用户名自动检测用户是否已经存在。 登陆时，提示用户名密码错误 删除数据行时，将行ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据行也删除。 \u0026hellip;.等等  jQuery.ajax 纯JS原生实现Ajax我们不去讲解这里，直接使用jquery提供的，方便学习和使用，避免重复造轮子，有兴趣的同学可以去了解下JS原生XMLHttpRequest ！\nAjax的核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。\njQuery 提供多个与 AJAX 有关的方法。\n通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON – 同时您能够把这些外部数据直接载入网页的被选元素中。\njQuery 不是生产者，而是大自然搬运工。\njQuery Ajax本质就是 XMLHttpRequest，对他进行了封装，方便调用！\njQuery.ajax(...) 部分参数： url：请求地址 type：请求方式，GET、POST（1.9.0之后用method） headers：请求头 data：要发送的数据 contentType：即将发送信息至服务器的内容编码类型(默认: \u0026quot;application/x-www-form-urlencoded; charset=UTF-8\u0026quot;) async：是否异步 timeout：设置请求超时时间（毫秒） beforeSend：发送请求前执行的函数(全局) complete：完成之后执行的回调函数(全局) success：成功之后执行的回调函数(全局) error：失败之后执行的回调函数(全局) accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型 dataType：将服务器端返回的数据转换成指定类型 \u0026quot;xml\u0026quot;: 将服务器端返回的内容转换成xml格式 \u0026quot;text\u0026quot;: 将服务器端返回的内容转换成普通文本格式 \u0026quot;html\u0026quot;: 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。 \u0026quot;script\u0026quot;: 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式 \u0026quot;json\u0026quot;: 将服务器端返回的内容转换成相应的JavaScript对象 \u0026quot;jsonp\u0026quot;: JSONP 格式使用 JSONP 形式调用函数时，如 \u0026quot;myurl?callback=?\u0026quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数 我们来个简单的测试，使用最原始的HttpServletResponse处理 , .最简单 , 最通用\n1、配置web.xml 和 springmvc的配置文件，复制上面案例的即可 【记得静态资源过滤和注解驱动配置上】\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:mvc=\u0026#34;http://www.springframework.org/schema/mvc\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\u0026#34;\u0026gt; \u0026lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.kuang.controller\u0026#34;/\u0026gt; \u0026lt;mvc:default-servlet-handler /\u0026gt; \u0026lt;mvc:annotation-driven /\u0026gt; \u0026lt;!-- 视图解析器 --\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026#34; id=\u0026#34;internalResourceViewResolver\u0026#34;\u0026gt; \u0026lt;!-- 前缀 --\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/jsp/\u0026#34; /\u0026gt; \u0026lt;!-- 后缀 --\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 2、编写一个AjaxController\n@Controller public class AjaxController { @RequestMapping(\u0026#34;/a1\u0026#34;) public void ajax1(String name , HttpServletResponse response) throws IOException { if (\u0026#34;admin\u0026#34;.equals(name)){ response.getWriter().print(\u0026#34;true\u0026#34;); }else{ response.getWriter().print(\u0026#34;false\u0026#34;); } } } 3、导入jquery ， 可以使用在线的CDN ， 也可以下载导入\n\u0026lt;script src=\u0026#34;https://code.jquery.com/jquery-3.1.1.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;${pageContext.request.contextPath}/statics/js/jquery-3.1.1.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 4、编写index.jsp测试\n\u0026lt;%@ page contentType=\u0026quot;text/html;charset=UTF-8\u0026quot; language=\u0026quot;java\u0026quot; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;$Title$\u0026lt;/title\u0026gt; \u0026lt;%--\u0026lt;script src=\u0026quot;https://code.jquery.com/jquery-3.1.1.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;--%\u0026gt; \u0026lt;script src=\u0026quot;${pageContext.request.contextPath}/statics/js/jquery-3.1.1.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; function a1(){ $.post({ url:\u0026quot;${pageContext.request.contextPath}/a1\u0026quot;, data:{'name':$(\u0026quot;#txtName\u0026quot;).val()}, success:function (data,status) { alert(data); alert(status); } }); } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;%--onblur：失去焦点触发事件--%\u0026gt; 用户名:\u0026lt;input type=\u0026quot;text\u0026quot; id=\u0026quot;txtName\u0026quot; onblur=\u0026quot;a1()\u0026quot;/\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 5、启动tomcat测试！打开浏览器的控制台，当我们鼠标离开输入框的时候，可以看到发出了一个ajax的请求！是后台返回给我们的结果！测试成功！\nSpringmvc实现 实体类user\n@Data @AllArgsConstructor @NoArgsConstructor public class User { private String name; private int age; private String sex; } 我们来获取一个集合对象，展示到前端页面\n@RequestMapping(\u0026#34;/a2\u0026#34;) public List\u0026lt;User\u0026gt; ajax2(){ List\u0026lt;User\u0026gt; list = new ArrayList\u0026lt;User\u0026gt;(); list.add(new User(\u0026#34;张三\u0026#34;,3,\u0026#34;男\u0026#34;)); list.add(new User(\u0026#34;李四\u0026#34;,3,\u0026#34;男\u0026#34;)); list.add(new User(\u0026#34;王五\u0026#34;,3,\u0026#34;男\u0026#34;)); return list; //由于@RestController注解，将list转成json格式返回 } 前端页面\n\u0026lt;%@ page contentType=\u0026quot;text/html;charset=UTF-8\u0026quot; language=\u0026quot;java\u0026quot; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026quot;button\u0026quot; id=\u0026quot;btn\u0026quot; value=\u0026quot;获取数据\u0026quot;/\u0026gt; \u0026lt;table width=\u0026quot;80%\u0026quot; align=\u0026quot;center\u0026quot;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;姓名\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;年龄\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;性别\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tbody id=\u0026quot;content\u0026quot;\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;script src=\u0026quot;${pageContext.request.contextPath}/statics/js/jquery-3.1.1.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; $(function () { $(\u0026quot;#btn\u0026quot;).click(function () { $.post(\u0026quot;${pageContext.request.contextPath}/a2\u0026quot;,function (data) { console.log(data) var html=\u0026quot;\u0026quot;; for (var i = 0; i \u0026lt;data.length ; i++) { html+= \u0026quot;\u0026lt;tr\u0026gt;\u0026quot; + \u0026quot;\u0026lt;td\u0026gt;\u0026quot; + data[i].name + \u0026quot;\u0026lt;/td\u0026gt;\u0026quot; + \u0026quot;\u0026lt;td\u0026gt;\u0026quot; + data[i].age + \u0026quot;\u0026lt;/td\u0026gt;\u0026quot; + \u0026quot;\u0026lt;td\u0026gt;\u0026quot; + data[i].sex + \u0026quot;\u0026lt;/td\u0026gt;\u0026quot; + \u0026quot;\u0026lt;/tr\u0026gt;\u0026quot; } $(\u0026quot;#content\u0026quot;).html(html); }); }) }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 成功实现了数据回显！可以体会一下Ajax的好处！\n注册提示效果 我们再测试一个小Demo，思考一下我们平时注册时候，输入框后面的实时提示怎么做到的；如何优化\n我们写一个Controller\n@RequestMapping(\u0026#34;/a3\u0026#34;) public String ajax3(String name,String pwd){ String msg = \u0026#34;\u0026#34;; //模拟数据库中存在数据  if (name!=null){ if (\u0026#34;admin\u0026#34;.equals(name)){ msg = \u0026#34;OK\u0026#34;; }else { msg = \u0026#34;用户名输入错误\u0026#34;; } } if (pwd!=null){ if (\u0026#34;123456\u0026#34;.equals(pwd)){ msg = \u0026#34;OK\u0026#34;; }else { msg = \u0026#34;密码输入有误\u0026#34;; } } return msg; //由于@RestController注解，将msg转成json格式返回 } 前端页面 login.jsp\n\u0026lt;%@ page contentType=\u0026quot;text/html;charset=UTF-8\u0026quot; language=\u0026quot;java\u0026quot; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;ajax\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026quot;${pageContext.request.contextPath}/statics/js/jquery-3.1.1.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; function a1(){ $.post({ url:\u0026quot;${pageContext.request.contextPath}/a3\u0026quot;, data:{'name':$(\u0026quot;#name\u0026quot;).val()}, success:function (data) { if (data.toString()=='OK'){ $(\u0026quot;#userInfo\u0026quot;).css(\u0026quot;color\u0026quot;,\u0026quot;green\u0026quot;); }else { $(\u0026quot;#userInfo\u0026quot;).css(\u0026quot;color\u0026quot;,\u0026quot;red\u0026quot;); } $(\u0026quot;#userInfo\u0026quot;).html(data); } }); } function a2(){ $.post({ url:\u0026quot;${pageContext.request.contextPath}/a3\u0026quot;, data:{'pwd':$(\u0026quot;#pwd\u0026quot;).val()}, success:function (data) { if (data.toString()=='OK'){ $(\u0026quot;#pwdInfo\u0026quot;).css(\u0026quot;color\u0026quot;,\u0026quot;green\u0026quot;); }else { $(\u0026quot;#pwdInfo\u0026quot;).css(\u0026quot;color\u0026quot;,\u0026quot;red\u0026quot;); } $(\u0026quot;#pwdInfo\u0026quot;).html(data); } }); } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt; 用户名:\u0026lt;input type=\u0026quot;text\u0026quot; id=\u0026quot;name\u0026quot; onblur=\u0026quot;a1()\u0026quot;/\u0026gt; \u0026lt;span id=\u0026quot;userInfo\u0026quot;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 密码:\u0026lt;input type=\u0026quot;text\u0026quot; id=\u0026quot;pwd\u0026quot; onblur=\u0026quot;a2()\u0026quot;/\u0026gt; \u0026lt;span id=\u0026quot;pwdInfo\u0026quot;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 【记得处理json乱码问题】\n测试一下效果，动态请求响应，局部刷新，就是如此！\n获取baidu接口Demo \u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Type\u0026#34; content=\u0026#34;text/html; charset=utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JSONP百度搜索\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; #q{ width: 500px; height: 30px; border:1px solid #ddd; line-height: 30px; display: block; margin: 0 auto; padding: 0 10px; font-size: 14px; } #ul{ width: 520px; list-style: none; margin: 0 auto; padding: 0; border:1px solid #ddd; margin-top: -1px; display: none; } #ul li{ line-height: 30px; padding: 0 10px; } #ul li:hover{ background-color: #f60; color: #fff; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; // 2.步骤二  // 定义demo函数 (分析接口、数据)  function demo(data){ var Ul = document.getElementById(\u0026#39;ul\u0026#39;); var html = \u0026#39;\u0026#39;; // 如果搜索数据存在 把内容添加进去  if (data.s.length) { // 隐藏掉的ul显示出来  Ul.style.display = \u0026#39;block\u0026#39;; // 搜索到的数据循环追加到li里  for(var i = 0;i\u0026lt;data.s.length;i++){ html += \u0026#39;\u0026lt;li\u0026gt;\u0026#39;+data.s[i]+\u0026#39;\u0026lt;/li\u0026gt;\u0026#39;; } // 循环的li写入ul  Ul.innerHTML = html; } } // 1.步骤一  window.onload = function(){ // 获取输入框和ul  var Q = document.getElementById(\u0026#39;q\u0026#39;); var Ul = document.getElementById(\u0026#39;ul\u0026#39;); // 事件鼠标抬起时候  Q.onkeyup = function(){ // 如果输入框不等于空  if (this.value != \u0026#39;\u0026#39;) { // ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆JSONPz重点☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆  // 创建标签  var script = document.createElement(\u0026#39;script\u0026#39;); //给定要跨域的地址 赋值给src  //这里是要请求的跨域的地址 我写的是百度搜索的跨域地址  script.src = \u0026#39;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=\u0026#39;+this.value+\u0026#39;\u0026amp;cb=demo\u0026#39;; // 将组合好的带src的script标签追加到body里  document.body.appendChild(script); } } } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;q\u0026#34; /\u0026gt; \u0026lt;ul id=\u0026#34;ul\u0026#34;\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Ajax在我们开发中十分重要，一定要学会使用！\n","date":"2021-11-09T09:43:00+08:00","permalink":"https://example.com/p/springmvc07-ajax%E7%A0%94%E7%A9%B6/","title":"SpringMVC07 Ajax研究"},{"content":"Json 什么是JSON？  JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。 采用完全独立于编程语言的文本格式来存储和表示数据。 简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。  在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式：\n 对象表示为键值对，数据由逗号分隔 花括号保存对象 方括号保存数组  JSON 键值对是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 \u0026quot;\u0026quot; 包裹，使用冒号 : 分隔，然后紧接着值：\n{\u0026#34;name\u0026#34;: \u0026#34;QinJiang\u0026#34;} {\u0026#34;age\u0026#34;: \u0026#34;3\u0026#34;} {\u0026#34;sex\u0026#34;: \u0026#34;男\u0026#34;} 很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解：\nJSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。\nvar obj = {a: \u0026#39;Hello\u0026#39;, b: \u0026#39;World\u0026#39;}; //这是一个对象，注意键名也是可以使用引号包裹的 var json = \u0026#39;{\u0026#34;a\u0026#34;: \u0026#34;Hello\u0026#34;, \u0026#34;b\u0026#34;: \u0026#34;World\u0026#34;}\u0026#39;; //这是一个 JSON 字符串，本质是一个字符串 JSON 和 JavaScript 对象互转\n要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法：\nvar obj = JSON.parse(\u0026#39;{\u0026#34;a\u0026#34;: \u0026#34;Hello\u0026#34;, \u0026#34;b\u0026#34;: \u0026#34;World\u0026#34;}\u0026#39;); //结果是 {a: \u0026#39;Hello\u0026#39;, b: \u0026#39;World\u0026#39;} 要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法：\nvar json = JSON.stringify({a: \u0026#39;Hello\u0026#39;, b: \u0026#39;World\u0026#39;}); //结果是 \u0026#39;{\u0026#34;a\u0026#34;: \u0026#34;Hello\u0026#34;, \u0026#34;b\u0026#34;: \u0026#34;World\u0026#34;}\u0026#39; 代码测试\n1、新建一个module ，springmvc-05-json ， 添加web的支持\n2、在web目录下新建一个 json-1.html ， 编写测试内容\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JSON\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; //编写一个js的对象  var user = { name:\u0026#34;张三\u0026#34;, age:3, sex:\u0026#34;男\u0026#34; }; //将js对象转换成json字符串  var str = JSON.stringify(user); console.log(str); //将json字符串转换为js对象  var user2 = JSON.parse(str); console.log(user2.age,user2.name,user2.sex); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 3、在IDEA中使用浏览器打开，查看控制台输出！\nController返回JSON数据 Jackson是springmvc默认的json解析工具其他还有 阿里巴巴的 fastjson、谷歌的 gson等等。\nJackson 使用它需要导入jar包\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.9.8\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 配置SpringMVC需要的配置\nweb.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;!--1.注册servlet--\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;SpringMVC\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:springmvc-servlet.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;!-- 启动顺序，数字越小，启动越早 --\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;!--所有请求都会被springmvc拦截 --\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;SpringMVC\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;encoding\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.CharacterEncodingFilter\u0026lt;/filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;utf-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;encoding\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; \u0026lt;/web-app\u0026gt; springmvc-servlet.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:mvc=\u0026#34;http://www.springframework.org/schema/mvc\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\u0026#34;\u0026gt; \u0026lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.spring.controller\u0026#34;/\u0026gt; \u0026lt;!-- 视图解析器 --\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026#34; id=\u0026#34;internalResourceViewResolver\u0026#34;\u0026gt; \u0026lt;!-- 前缀 --\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/jsp/\u0026#34; /\u0026gt; \u0026lt;!-- 后缀 --\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 我们随便编写一个User的实体类，然后我们去编写我们的测试Controller；\n@Data @AllArgsConstructor @NoArgsConstructor public class User { private String name; private int age; private String sex; } 这里我们需要两个新东西，一个是@ResponseBody，一个是ObjectMapper对象，我们看下具体的用法\n编写一个Controller；\n@Controller public class UserController { @RequestMapping(\u0026#34;/json1\u0026#34;) @ResponseBody public String json1() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据  ObjectMapper mapper = new ObjectMapper(); //创建一个对象  User user = new User(\u0026#34;张三\u0026#34;, 3, \u0026#34;男\u0026#34;); //将我们的对象解析成为json格式  String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便  return str; } } 配置Tomcat ， 启动测试一下！\nhttp://localhost:8080/json1\n发现出现了乱码问题，我们需要设置一下他的编码格式为utf-8，以及它返回的类型；\n通过@RequestMaping的produces属性来实现，修改下代码\n//produces:指定响应体返回类型和编码 @RequestMapping(value = \u0026#34;/json1\u0026#34;,produces = \u0026#34;application/json;charset=utf-8\u0026#34;) 再次测试， http://localhost:8080/json1 ， 乱码问题OK！\n【注意：使用json记得处理乱码问题】\n代码优化 乱码统一解决\n上一种方法比较麻烦，如果项目中有许多请求则每一个都要添加，可以通过Spring配置统一指定，这样就不用每次都去处理了！\n我们可以在springmvc的配置文件上添加一段消息StringHttpMessageConverter转换配置！\n\u0026lt;mvc:annotation-driven\u0026gt; \u0026lt;mvc:message-converters register-defaults=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.http.converter.StringHttpMessageConverter\u0026#34;\u0026gt; \u0026lt;constructor-arg value=\u0026#34;UTF-8\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;objectMapper\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;failOnEmptyBeans\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/mvc:message-converters\u0026gt; \u0026lt;/mvc:annotation-driven\u0026gt; 返回json字符串统一解决\n在类上直接使用 @RestController ，这样子，里面所有的方法都只会返回 json 字符串了，不用再每一个都添加@ResponseBody ！我们在前后端分离开发中，一般都使用 @RestController ，十分便捷！\n@RestController public class UserController { //produces:指定响应体返回类型和编码  @RequestMapping(value = \u0026#34;/json1\u0026#34;) public String json1() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据  ObjectMapper mapper = new ObjectMapper(); //创建一个对象  User user = new User(\u0026#34;张三\u0026#34;, 3, \u0026#34;男\u0026#34;); //将我们的对象解析成为json格式  String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便  return str; } } 启动tomcat测试，结果都正常输出！\n测试集合输出 增加一个新的方法\n@RequestMapping(\u0026#34;/json2\u0026#34;) public String json2() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据  ObjectMapper mapper = new ObjectMapper(); //创建一个对象  User user1 = new User(\u0026#34;张三\u0026#34;, 3, \u0026#34;男\u0026#34;); User user2 = new User(\u0026#34;李四\u0026#34;, 3, \u0026#34;男\u0026#34;); User user3 = new User(\u0026#34;王五\u0026#34;, 3, \u0026#34;男\u0026#34;); User user4 = new User(\u0026#34;找六\u0026#34;, 3, \u0026#34;男\u0026#34;); List\u0026lt;User\u0026gt; list = new ArrayList\u0026lt;User\u0026gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); //将我们的对象解析成为json格式  String str = mapper.writeValueAsString(list); return str; } 运行结果 : 十分完美，没有任何问题！\n输出时间对象 增加一个新的方法\n@RequestMapping(\u0026#34;/json3\u0026#34;) public String json3() throws JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); //创建时间一个对象，java.util.Date  Date date = new Date(); //将我们的对象解析成为json格式  String str = mapper.writeValueAsString(date); return str; }  默认日期格式会变成一个数字，是1970年1月1日到当前日期的毫秒数！ Jackson 默认是会把时间转成timestamps形式  解决方案：取消timestamps形式 ， 自定义时间格式\n@RequestMapping(\u0026#34;/json4\u0026#34;) public String json4() throws JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); //不使用时间戳的方式  mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期格式对象  SimpleDateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); //指定日期格式  mapper.setDateFormat(sdf); Date date = new Date(); String str = mapper.writeValueAsString(date); return str; } 运行结果 : 成功的输出了时间！\n抽取为工具类 如果要经常使用的话，这样是比较麻烦的，我们可以将这些代码封装到一个工具类中；我们去编写下\nimport com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.SerializationFeature; import java.text.SimpleDateFormat; public class JsonUtils { public static String getJson(Object object) { return getJson(object,\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); } public static String getJson(Object object,String dateFormat) { ObjectMapper mapper = new ObjectMapper(); //不使用时间差的方式  mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期格式对象  SimpleDateFormat sdf = new SimpleDateFormat(dateFormat); //指定日期格式  mapper.setDateFormat(sdf); try { return mapper.writeValueAsString(object); } catch (JsonProcessingException e) { e.printStackTrace(); } return null; } } 我们使用工具类，代码就更加简洁了！\n@RequestMapping(\u0026#34;/json5\u0026#34;) public String json5() throws JsonProcessingException { Date date = new Date(); String json = JsonUtils.getJson(date); return json; } 大功告成！完美！\nFastJson fastjson.jar是阿里开发的一款专门用于Java开发的包，可以方便的实现json对象与JavaBean对象的转换，实现JavaBean对象与json字符串的转换，实现json对象与json字符串的转换。实现json的转换方法很多，最后的实现结果都是一样的。\nfastjson 的 pom依赖！\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.60\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; fastjson 三个主要的类：\nJSONObject 代表 json 对象\n JSONObject实现了Map接口, 猜想 JSONObject底层操作是由Map实现的。 JSONObject对应json对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取\u0026quot;键：值\u0026quot;对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。  JSONArray 代表 json 对象数组\n 内部是有List接口中的方法来完成操作的。  JSON代表 JSONObject和JSONArray的转化\n JSON类源码分析与使用 仔细观察这些方法，主要是实现json对象，json对象数组，javabean对象，json字符串之间的相互转化。  代码测试，我们新建一个FastJsonDemo 类\npackage com.kuang.controller; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; import com.kuang.pojo.User; import java.util.ArrayList; import java.util.List; public class FastJsonDemo { public static void main(String[] args) { //创建一个对象  User user1 = new User(\u0026#34;张三\u0026#34;, 3, \u0026#34;男\u0026#34;); User user2 = new User(\u0026#34;李四\u0026#34;, 3, \u0026#34;男\u0026#34;); User user3 = new User(\u0026#34;王五\u0026#34;, 3, \u0026#34;男\u0026#34;); User user4 = new User(\u0026#34;找六\u0026#34;, 3, \u0026#34;男\u0026#34;); List\u0026lt;User\u0026gt; list = new ArrayList\u0026lt;User\u0026gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); System.out.println(\u0026#34;*******Java对象 转 JSON字符串*******\u0026#34;); String str1 = JSON.toJSONString(list); System.out.println(\u0026#34;JSON.toJSONString(list)==\u0026gt;\u0026#34;+str1); String str2 = JSON.toJSONString(user1); System.out.println(\u0026#34;JSON.toJSONString(user1)==\u0026gt;\u0026#34;+str2); System.out.println(\u0026#34;\\n****** JSON字符串 转 Java对象*******\u0026#34;); User jp_user1=JSON.parseObject(str2,User.class); System.out.println(\u0026#34;JSON.parseObject(str2,User.class)==\u0026gt;\u0026#34;+jp_user1); System.out.println(\u0026#34;\\n****** Java对象 转 JSON对象 ******\u0026#34;); JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2); System.out.println(\u0026#34;(JSONObject) JSON.toJSON(user2)==\u0026gt;\u0026#34;+jsonObject1.getString(\u0026#34;name\u0026#34;)); System.out.println(\u0026#34;\\n****** JSON对象 转 Java对象 ******\u0026#34;); User to_java_user = JSON.toJavaObject(jsonObject1, User.class); System.out.println(\u0026#34;JSON.toJavaObject(jsonObject1, User.class)==\u0026gt;\u0026#34;+to_java_user); } } 这种工具类，我们只需要掌握使用就好了，在使用的时候在根据具体的业务去找对应的实现。\nJson在我们数据传输中十分重要，一定要学会使用！\n","date":"2021-11-09T09:42:10+08:00","permalink":"https://example.com/p/springmvc06-json%E4%BA%A4%E4%BA%92%E5%A4%84%E7%90%86/","title":"SpringMVC06 Json交互处理"},{"content":"整合SSM框架 数据库环境 创建一个存放书籍数据的数据库表\nCREATEDATABASE`ssmbuild`;USE`ssmbuild`;DROPTABLEIFEXISTS`books`;CREATETABLE`books`(`bookID`INT(10)NOTNULLAUTO_INCREMENTCOMMENT\u0026#39;书id\u0026#39;,`bookName`VARCHAR(100)NOTNULLCOMMENT\u0026#39;书名\u0026#39;,`bookCounts`INT(11)NOTNULLCOMMENT\u0026#39;数量\u0026#39;,`detail`VARCHAR(200)NOTNULLCOMMENT\u0026#39;描述\u0026#39;,KEY`bookID`(`bookID`))ENGINE=INNODBDEFAULTCHARSET=utf8INSERTINTO`books`(`bookID`,`bookName`,`bookCounts`,`detail`)VALUES(1,\u0026#39;Java\u0026#39;,1,\u0026#39;从入门到放弃\u0026#39;),(2,\u0026#39;MySQL\u0026#39;,10,\u0026#39;从删库到跑路\u0026#39;),(3,\u0026#39;Linux\u0026#39;,5,\u0026#39;从进门到进牢\u0026#39;);基本环境搭建 1、新建一Maven项目！ssmbuild ， 添加web的支持\n2、导入相关的pom依赖！\n\u0026lt;dependencies\u0026gt; \u0026lt;!--Junit--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--数据库驱动--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.47\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 数据库连接池 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.mchange\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;c3p0\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.5.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Servlet - JSP --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet.jsp\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jsp-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jstl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Mybatis--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Spring--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.9.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.9.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 3、Maven资源过滤设置\n\u0026lt;build\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/java\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/resources\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;/build\u0026gt; 4、建立基本结构和配置框架！\n  com.spring.pojo\n  com.spring.dao\n  com.spring.service\n  com.spring.controller\n  mybatis-config.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;/configuration\u0026gt;   applicationContext.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;/beans\u0026gt;   Mybatis层 1、数据库配置文件 database.properties\njdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/ssmbuild?useSSL=true\u0026amp;useUnicode=true\u0026amp;characterEncoding=utf8 jdbc.username=root jdbc.password=123456 2、IDEA关联数据库\n3、编写MyBatis的核心配置文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!--应用配置文件--\u0026gt; \u0026lt;properties resource=\u0026#34;db.properties\u0026#34;/\u0026gt; \u0026lt;!--开启小驼峰命名，将数据库中的 _ 转为下一个字母大写--\u0026gt; \u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026#34;mapUnderscoreToCamelCase\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; \u0026lt;!--environments 环境 --\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;!--事务 JDBC的事务--\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;${driver}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${password}\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;package name=\u0026#34;com.spring.pojo\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;com/spring/dao/BookMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt; 4、编写数据库对应的实体类 com.spring.pojo.Books\n使用lombok插件！\n@Data @AllArgsConstructor @NoArgsConstructor public class Books { private int bookID; private String bookName; private int bookCounts; private String detail; } 5、编写Dao层的 Mapper接口！\npublic interface BookMapper { //增加一个Book  int addBook(Books book); //根据id删除一个Book  int deleteBookById(int id); //更新Book  int updateBook(Books books); //根据id查询,返回一个Book  Books queryBookById(int id); //查询全部Book,返回list集合  List\u0026lt;Books\u0026gt; queryAllBook(); } 6、编写接口对应的 Mapper.xml 文件。需要导入MyBatis的包；\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.spring.dao.BookMapper\u0026#34;\u0026gt; \u0026lt;!--增加一个Book--\u0026gt; \u0026lt;insert id=\u0026#34;addBook\u0026#34; parameterType=\u0026#34;Books\u0026#34;\u0026gt; insert into ssmbuild.books(bookName,bookCounts,detail) values (#{bookName}, #{bookCounts}, #{detail}) \u0026lt;/insert\u0026gt; \u0026lt;!--根据id删除一个Book--\u0026gt; \u0026lt;delete id=\u0026#34;deleteBookById\u0026#34; parameterType=\u0026#34;int\u0026#34;\u0026gt; delete from ssmbuild.books where bookID=#{bookID} \u0026lt;/delete\u0026gt; \u0026lt;!--更新Book--\u0026gt; \u0026lt;update id=\u0026#34;updateBook\u0026#34; parameterType=\u0026#34;Books\u0026#34;\u0026gt; update ssmbuild.books set bookName = #{bookName},bookCounts = #{bookCounts},detail = #{detail} where bookID = #{bookID} \u0026lt;/update\u0026gt; \u0026lt;!--根据id查询,返回一个Book--\u0026gt; \u0026lt;select id=\u0026#34;queryBookById\u0026#34; resultType=\u0026#34;Books\u0026#34;\u0026gt; select * from ssmbuild.books where bookID = #{bookID} \u0026lt;/select\u0026gt; \u0026lt;!--查询全部Book--\u0026gt; \u0026lt;select id=\u0026#34;queryAllBook\u0026#34; resultType=\u0026#34;Books\u0026#34;\u0026gt; SELECT * from ssmbuild.books \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 7、编写Service层的接口和实现类\n接口：\n//BookService:底下需要去实现,调用dao层 public interface BookService { //增加一个Book  int addBook(Books book); //根据id删除一个Book  int deleteBookById(int id); //更新Book  int updateBook(Books books); //根据id查询,返回一个Book  Books queryBookById(int id); //查询全部Book,返回list集合  List\u0026lt;Books\u0026gt; queryAllBook(); } 实现类：\npublic class BookServiceImpl implements BookService { //调用dao层的操作，设置一个set接口，方便Spring管理  private BookMapper bookMapper; public void setBookMapper(BookMapper bookMapper) { this.bookMapper = bookMapper; } public int addBook(Books book) { return bookMapper.addBook(book); } public int deleteBookById(int id) { return bookMapper.deleteBookById(id); } public int updateBook(Books books) { return bookMapper.updateBook(books); } public Books queryBookById(int id) { return bookMapper.queryBookById(id); } public List\u0026lt;Books\u0026gt; queryAllBook() { return bookMapper.queryAllBook(); } } OK，到此，底层需求操作编写完毕！\nSpring层 1、配置Spring整合MyBatis，我们这里数据源使用c3p0连接池\n2、我们去编写Spring整合Mybatis的相关的配置文件；spring-dao.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!-- 配置整合mybatis --\u0026gt; \u0026lt;!-- 1.关联数据库文件 --\u0026gt; \u0026lt;context:property-placeholder location=\u0026#34;classpath:database.properties\u0026#34;/\u0026gt; \u0026lt;!-- 2.数据库连接池 --\u0026gt; \u0026lt;!--数据库连接池 dbcp 半自动化操作 不能自动连接 c3p0 自动化操作（自动的加载配置文件 并且设置到对象里面） --\u0026gt; \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;com.mchange.v2.c3p0.ComboPooledDataSource\u0026#34;\u0026gt; \u0026lt;!-- 配置连接池属性 --\u0026gt; \u0026lt;property name=\u0026#34;driverClass\u0026#34; value=\u0026#34;${jdbc.driver}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;jdbcUrl\u0026#34; value=\u0026#34;${jdbc.url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;user\u0026#34; value=\u0026#34;${jdbc.username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${jdbc.password}\u0026#34;/\u0026gt; \u0026lt;!-- c3p0连接池的私有属性 --\u0026gt; \u0026lt;property name=\u0026#34;maxPoolSize\u0026#34; value=\u0026#34;30\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;minPoolSize\u0026#34; value=\u0026#34;10\u0026#34;/\u0026gt; \u0026lt;!-- 关闭连接后不自动commit --\u0026gt; \u0026lt;property name=\u0026#34;autoCommitOnClose\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;!-- 获取连接超时时间 --\u0026gt; \u0026lt;property name=\u0026#34;checkoutTimeout\u0026#34; value=\u0026#34;10000\u0026#34;/\u0026gt; \u0026lt;!-- 当获取连接失败重试次数 --\u0026gt; \u0026lt;property name=\u0026#34;acquireRetryAttempts\u0026#34; value=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 3.配置SqlSessionFactory对象 --\u0026gt; \u0026lt;bean id=\u0026#34;sqlSessionFactory\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionFactoryBean\u0026#34;\u0026gt; \u0026lt;!-- 注入数据库连接池 --\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;/\u0026gt; \u0026lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --\u0026gt; \u0026lt;property name=\u0026#34;configLocation\u0026#34; value=\u0026#34;classpath:mybatis-config.xml\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --\u0026gt; \u0026lt;bean class=\u0026#34;org.mybatis.spring.mapper.MapperScannerConfigurer\u0026#34;\u0026gt; \u0026lt;!-- 注入sqlSessionFactory --\u0026gt; \u0026lt;property name=\u0026#34;sqlSessionFactoryBeanName\u0026#34; value=\u0026#34;sqlSessionFactory\u0026#34;/\u0026gt; \u0026lt;!-- 给出需要扫描Dao接口包 --\u0026gt; \u0026lt;property name=\u0026#34;basePackage\u0026#34; value=\u0026#34;com.spring.dao\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 3、Spring整合service层\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!-- 扫描service相关的bean --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.kuang.service\u0026#34; /\u0026gt; \u0026lt;!--BookServiceImpl注入到IOC容器中--\u0026gt; \u0026lt;bean id=\u0026#34;BookServiceImpl\u0026#34; class=\u0026#34;com.kuang.service.BookServiceImpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;bookMapper\u0026#34; ref=\u0026#34;bookMapper\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 配置事务管理器 --\u0026gt; \u0026lt;bean id=\u0026#34;transactionManager\u0026#34;class=\u0026#34;org.springframework.jdbc.datasource.DataSourceTransactionManager\u0026#34;\u0026gt; \u0026lt;!-- 注入数据库连接池 --\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; Spring层搞定！再次理解一下，Spring就是一个大杂烩，一个容器！对吧！\nSpringMVC层 1、web.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;!--DispatcherServlet--\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;DispatcherServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;!--一定要注意:我们这里加载的是总的配置文件，之前被这里坑了！--\u0026gt; \u0026lt;param-value\u0026gt;classpath:applicationContext.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;DispatcherServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;!--encodingFilter--\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;encodingFilter\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt; org.springframework.web.filter.CharacterEncodingFilter \u0026lt;/filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;utf-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;encodingFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; \u0026lt;!--Session过期时间--\u0026gt; \u0026lt;session-config\u0026gt; \u0026lt;session-timeout\u0026gt;15\u0026lt;/session-timeout\u0026gt; \u0026lt;/session-config\u0026gt; \u0026lt;/web-app\u0026gt; 2、spring-mvc.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:mvc=\u0026#34;http://www.springframework.org/schema/mvc\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\u0026#34;\u0026gt; \u0026lt;!-- 配置SpringMVC --\u0026gt; \u0026lt;!-- 1.开启SpringMVC注解驱动 --\u0026gt; \u0026lt;mvc:annotation-driven /\u0026gt; \u0026lt;!-- 2.静态资源默认servlet配置--\u0026gt; \u0026lt;mvc:default-servlet-handler/\u0026gt; \u0026lt;!-- 3.配置jsp 显示ViewResolver视图解析器 --\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;viewClass\u0026#34; value=\u0026#34;org.springframework.web.servlet.view.JstlView\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/jsp/\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 4.扫描web相关的bean --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.spring.controller\u0026#34; /\u0026gt; \u0026lt;/beans\u0026gt; 3、Spring配置整合文件，applicationContext.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!-- 加载其他模块配置文件 --\u0026gt; \u0026lt;import resource=\u0026#34;spring-dao.xml\u0026#34;/\u0026gt; \u0026lt;import resource=\u0026#34;spring-service.xml\u0026#34;/\u0026gt; \u0026lt;import resource=\u0026#34;spring-mvc.xml\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; 配置文件，暂时结束！Controller 和 视图层编写\n1、BookController 类编写 ， 方法一：查询全部书籍\n@Controller @RequestMapping(\u0026#34;/book\u0026#34;) public class BookController { @Autowired @Qualifier(\u0026#34;BookServiceImpl\u0026#34;) private BookService bookService; @RequestMapping(\u0026#34;/allBook\u0026#34;) public String list(Model model) { List\u0026lt;Books\u0026gt; list = bookService.queryAllBook(); model.addAttribute(\u0026#34;list\u0026#34;, list); return \u0026#34;allBook\u0026#34;; } } 2、编写首页 index.jsp\n\u0026lt;%@ page language=\u0026quot;java\u0026quot; contentType=\u0026quot;text/html; charset=UTF-8\u0026quot; pageEncoding=\u0026quot;UTF-8\u0026quot; %\u0026gt; \u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;首页\u0026lt;/title\u0026gt; \u0026lt;style type=\u0026quot;text/css\u0026quot;\u0026gt; a { text-decoration: none; color: black; font-size: 18px; } h3 { width: 180px; height: 38px; margin: 100px auto; text-align: center; line-height: 38px; background: deepskyblue; border-radius: 4px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h3\u0026gt; \u0026lt;a href=\u0026quot;${pageContext.request.contextPath}/book/allBook\u0026quot;\u0026gt;点击进入列表页\u0026lt;/a\u0026gt; \u0026lt;/h3\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 3、书籍列表页面 allbook.jsp\n\u0026lt;%@ taglib prefix=\u0026quot;c\u0026quot; uri=\u0026quot;http://java.sun.com/jsp/jstl/core\u0026quot; %\u0026gt; \u0026lt;%@ page contentType=\u0026quot;text/html;charset=UTF-8\u0026quot; language=\u0026quot;java\u0026quot; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;书籍列表\u0026lt;/title\u0026gt; \u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1.0\u0026quot;\u0026gt; \u0026lt;!-- 引入 Bootstrap --\u0026gt; \u0026lt;link href=\u0026quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\u0026quot; rel=\u0026quot;stylesheet\u0026quot;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026quot;container\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;row clearfix\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;col-md-12 column\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;page-header\u0026quot;\u0026gt; \u0026lt;h1\u0026gt; \u0026lt;small\u0026gt;书籍列表 —— 显示所有书籍\u0026lt;/small\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;row\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;col-md-4 column\u0026quot;\u0026gt; \u0026lt;a class=\u0026quot;btn btn-primary\u0026quot; href=\u0026quot;${pageContext.request.contextPath}/book/toAddBook\u0026quot;\u0026gt;新增\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;row clearfix\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;col-md-12 column\u0026quot;\u0026gt; \u0026lt;table class=\u0026quot;table table-hover table-striped\u0026quot;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;书籍编号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;书籍名字\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;书籍数量\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;书籍详情\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;操作\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;c:forEach var=\u0026quot;book\u0026quot; items=\u0026quot;${requestScope.get('list')}\u0026quot;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;${book.getBookID()}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${book.getBookName()}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${book.getBookCounts()}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${book.getDetail()}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;a href=\u0026quot;${pageContext.request.contextPath}/book/toUpdateBook?id=${book.getBookID()}\u0026quot;\u0026gt;更改\u0026lt;/a\u0026gt; | \u0026lt;a href=\u0026quot;${pageContext.request.contextPath}/book/del/${book.getBookID()}\u0026quot;\u0026gt;删除\u0026lt;/a\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/c:forEach\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 4、BookController 类编写 ， 方法二：添加书籍\n@RequestMapping(\u0026#34;/toAddBook\u0026#34;) public String toAddPaper() { return \u0026#34;addBook\u0026#34;; } @RequestMapping(\u0026#34;/addBook\u0026#34;) public String addPaper(Books books) { System.out.println(books); bookService.addBook(books); return \u0026#34;redirect:/book/allBook\u0026#34;; } 5、添加书籍页面：addBook.jsp\n\u0026lt;%@ taglib prefix=\u0026quot;c\u0026quot; uri=\u0026quot;http://java.sun.com/jsp/jstl/core\u0026quot; %\u0026gt; \u0026lt;%@ page contentType=\u0026quot;text/html;charset=UTF-8\u0026quot; language=\u0026quot;java\u0026quot; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;新增书籍\u0026lt;/title\u0026gt; \u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1.0\u0026quot;\u0026gt; \u0026lt;!-- 引入 Bootstrap --\u0026gt; \u0026lt;link href=\u0026quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\u0026quot; rel=\u0026quot;stylesheet\u0026quot;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026quot;container\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;row clearfix\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;col-md-12 column\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;page-header\u0026quot;\u0026gt; \u0026lt;h1\u0026gt; \u0026lt;small\u0026gt;新增书籍\u0026lt;/small\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;form action=\u0026quot;${pageContext.request.contextPath}/book/addBook\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; 书籍名称：\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;bookName\u0026quot;\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt; 书籍数量：\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;bookCounts\u0026quot;\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt; 书籍详情：\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;detail\u0026quot;\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;添加\u0026quot;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; 6、BookController 类编写 ， 方法三：修改书籍\n@RequestMapping(\u0026#34;/toUpdateBook\u0026#34;) public String toUpdateBook(Model model, int id) { Books books = bookService.queryBookById(id); System.out.println(books); model.addAttribute(\u0026#34;book\u0026#34;,books ); return \u0026#34;updateBook\u0026#34;; } @RequestMapping(\u0026#34;/updateBook\u0026#34;) public String updateBook(Model model, Books book) { System.out.println(book); bookService.updateBook(book); Books books = bookService.queryBookById(book.getBookID()); model.addAttribute(\u0026#34;books\u0026#34;, books); return \u0026#34;redirect:/book/allBook\u0026#34;; } 7、修改书籍页面 updateBook.jsp\n\u0026lt;%@ taglib prefix=\u0026quot;c\u0026quot; uri=\u0026quot;http://java.sun.com/jsp/jstl/core\u0026quot; %\u0026gt; \u0026lt;%@ page contentType=\u0026quot;text/html;charset=UTF-8\u0026quot; language=\u0026quot;java\u0026quot; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;修改信息\u0026lt;/title\u0026gt; \u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1.0\u0026quot;\u0026gt; \u0026lt;!-- 引入 Bootstrap --\u0026gt; \u0026lt;link href=\u0026quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\u0026quot; rel=\u0026quot;stylesheet\u0026quot;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026quot;container\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;row clearfix\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;col-md-12 column\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;page-header\u0026quot;\u0026gt; \u0026lt;h1\u0026gt; \u0026lt;small\u0026gt;修改信息\u0026lt;/small\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;form action=\u0026quot;${pageContext.request.contextPath}/book/updateBook\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;bookID\u0026quot; value=\u0026quot;${book.getBookID()}\u0026quot;/\u0026gt; 书籍名称：\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;bookName\u0026quot; value=\u0026quot;${book.getBookName()}\u0026quot;/\u0026gt; 书籍数量：\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;bookCounts\u0026quot; value=\u0026quot;${book.getBookCounts()}\u0026quot;/\u0026gt; 书籍详情：\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;detail\u0026quot; value=\u0026quot;${book.getDetail() }\u0026quot;/\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;提交\u0026quot;/\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; 8、BookController 类编写 ， 方法四：删除书籍\n@RequestMapping(\u0026#34;/del/{bookId}\u0026#34;) public String deleteBook(@PathVariable(\u0026#34;bookId\u0026#34;) int id) { bookService.deleteBookById(id); return \u0026#34;redirect:/book/allBook\u0026#34;; } 配置Tomcat，进行运行！\n到目前为止，这个SSM项目整合已经完全的OK了，可以直接运行进行测试！这个练习十分的重要，大家需要保证，不看任何东西，自己也可以完整的实现出来！\n","date":"2021-11-09T09:40:59+08:00","permalink":"https://example.com/p/springmvc05-%E6%95%B4%E5%90%88ssm%E6%A1%86%E6%9E%B6/","title":"SpringMVC05 整合SSM框架"},{"content":"数据处理及跳转 跳转 ModelAndView 设置ModelAndView对象 , 根据view的名称 , 和视图解析器跳到指定的页面 .\n页面 : {视图解析器前缀} + viewName +{视图解析器后缀}\n\u0026lt;!-- 视图解析器 --\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026#34; id=\u0026#34;internalResourceViewResolver\u0026#34;\u0026gt; \u0026lt;!-- 前缀 --\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/jsp/\u0026#34; /\u0026gt; \u0026lt;!-- 后缀 --\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; 对应的controller类\npublic class ControllerTest1 implements Controller { public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponsehttpServletResponse) throws Exception { //返回一个模型视图对象  ModelAndView mv = new ModelAndView(); mv.addObject(\u0026#34;msg\u0026#34;,\u0026#34;ControllerTest1\u0026#34;); mv.setViewName(\u0026#34;test\u0026#34;); return mv; } } ServletAPI 通过设置ServletAPI , 不需要视图解析器 .\n1、通过HttpServletResponse进行输出\n2、通过HttpServletResponse实现重定向\n3、通过HttpServletResponse实现转发\n@Controller public class ResultGo { @RequestMapping(\u0026#34;/result/t1\u0026#34;) public void test1(HttpServletRequest req, HttpServletResponse rsp) throws IOException { rsp.getWriter().println(\u0026#34;Hello,Spring BY servlet API\u0026#34;); } @RequestMapping(\u0026#34;/result/t2\u0026#34;) public void test2(HttpServletRequest req, HttpServletResponse rsp) throws IOException { rsp.sendRedirect(\u0026#34;/index.jsp\u0026#34;); } @RequestMapping(\u0026#34;/result/t3\u0026#34;) public void test3(HttpServletRequest req, HttpServletResponse rsp) throws Exception { //转发  req.setAttribute(\u0026#34;msg\u0026#34;,\u0026#34;/result/t3\u0026#34;); req.getRequestDispatcher(\u0026#34;/WEB-INF/jsp/test.jsp\u0026#34;).forward(req,rsp); } } SpringMVC 通过SpringMVC来实现转发和重定向 - 无需视图解析器；\n测试前，需要将视图解析器注释掉\n@Controller public class ResultSpringMVC { @RequestMapping(\u0026#34;/rsm/t1\u0026#34;) public String test1(){ //转发  return \u0026#34;/index.jsp\u0026#34;; } @RequestMapping(\u0026#34;/rsm/t2\u0026#34;) public String test2(){ //转发二  return \u0026#34;forward:/index.jsp\u0026#34;; } @RequestMapping(\u0026#34;/rsm/t3\u0026#34;) public String test3(){ //重定向  return \u0026#34;redirect:/index.jsp\u0026#34;; } } 通过SpringMVC来实现转发和重定向 - 有视图解析器；\n重定向 , 不需要视图解析器 , 本质就是重新请求一个新地方嘛 , 所以注意路径问题.\n可以重定向到另外一个请求实现 .\n@Controller public class ResultSpringMVC2 { @RequestMapping(\u0026#34;/rsm2/t1\u0026#34;) public String test1(){ //转发  return \u0026#34;test\u0026#34;; } @RequestMapping(\u0026#34;/rsm2/t2\u0026#34;) public String test2(){ //重定向  return \u0026#34;redirect:/index.jsp\u0026#34;; //return \u0026#34;redirect:hello.do\u0026#34;; //hello.do为另一个请求/  } } 数据处理 处理提交数据 提交的域名称和处理方法的参数名一致\n提交数据 : http://localhost:8080/hello?name=zhangsan\n处理方法 :\n@RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(String name){ System.out.println(name); return \u0026#34;hello\u0026#34;; } 后台输出 : zhangsan\n2、提交的域名称和处理方法的参数名不一致\n提交数据 : http://localhost:8080/hello?username=zhangsan\n处理方法 :\n//@RequestParam(\u0026#34;username\u0026#34;) : username提交的域的名称 . @RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(@RequestParam(\u0026#34;username\u0026#34;) String name){ System.out.println(name); return \u0026#34;hello\u0026#34;; } 后台输出 : zhangsan\n3、提交的是一个对象\n要求提交的表单域和对象的属性名一致 , 参数使用对象即可\n1、实体类\n@Data public class User { private int id; private String name; private int age; } 2、提交数据 : http://localhost:8080/mvc04/user?name=zhangsan\u0026amp;id=1\u0026amp;age=15\n3、处理方法 :\n@RequestMapping(\u0026#34;/user\u0026#34;) public String user(User user){ System.out.println(user); return \u0026#34;hello\u0026#34;; } 后台输出 : User { id=1, name=\u0026lsquo;zhangsan\u0026rsquo;, age=15 }\n说明：如果使用对象的话，前端传递的参数名和对象名必须一致，否则就是null。\n数据显示到前端 第一种 : 通过ModelAndView\n我们前面一直都是如此 . 就不过多解释\npublic class ControllerTest1 implements Controller { public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponsehttpServletResponse) throws Exception { //返回一个模型视图对象  ModelAndView mv = new ModelAndView(); mv.addObject(\u0026#34;msg\u0026#34;,\u0026#34;ControllerTest1\u0026#34;); mv.setViewName(\u0026#34;test\u0026#34;); return mv; } } 第二种 : 通过ModelMap\nModelMap\n@RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(@RequestParam(\u0026#34;username\u0026#34;) String name, ModelMap model){ //封装要显示到视图中的数据  //相当于req.setAttribute(\u0026#34;name\u0026#34;,name);  model.addAttribute(\u0026#34;name\u0026#34;,name); System.out.println(name); return \u0026#34;hello\u0026#34;; } 第三种 : 通过Model\nModel\n@RequestMapping(\u0026#34;/ct2/hello\u0026#34;) public String hello(@RequestParam(\u0026#34;username\u0026#34;) String name, Model model){ //封装要显示到视图中的数据  //相当于req.setAttribute(\u0026#34;name\u0026#34;,name);  model.addAttribute(\u0026#34;msg\u0026#34;,name); System.out.println(name); return \u0026#34;test\u0026#34;; } 对比 就对于新手而言简单来说使用区别就是：\nModel 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解； ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性； ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。 当然更多的以后开发考虑的更多的是性能和优化，就不能单单仅限于此的了解。\n请使用80%的时间打好扎实的基础，剩下18%的时间研究框架，2%的时间去学点英文，框架的官方文档永远是最好的教程。\n乱码问题 测试步骤：\n1、我们可以在首页编写一个提交的表单\n\u0026lt;form action=\u0026quot;/e/t\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;name\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot;\u0026gt; \u0026lt;/form\u0026gt; 2、后台编写对应的处理类\n@Controller public class Encoding { @RequestMapping(\u0026#34;/e/t\u0026#34;) public String test(Model model,String name){ model.addAttribute(\u0026#34;msg\u0026#34;,name); //获取表单提交的值  return \u0026#34;test\u0026#34;; //跳转到test页面显示输入的值  } } 3、输入中文测试，发现乱码\n不得不说，乱码问题是在我们开发中十分常见的问题，也是让我们程序猿比较头大的问题！\n以前乱码问题通过过滤器解决 , 而SpringMVC给我们提供了一个过滤器 , 可以在web.xml中配置 .\n修改了xml文件需要重启服务器！\n\u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;encoding\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.CharacterEncodingFilter\u0026lt;/filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;utf-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;encoding\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; 但是我们发现 , 有些极端情况下.这个过滤器对get的支持不好 .\n处理方法 :\n1、修改tomcat配置文件 ：设置编码！\n\u0026lt;Connector URIEncoding=\u0026#34;utf-8\u0026#34; port=\u0026#34;8080\u0026#34; protocol=\u0026#34;HTTP/1.1\u0026#34; connectionTimeout=\u0026#34;20000\u0026#34; redirectPort=\u0026#34;8443\u0026#34; /\u0026gt; 2、自定义过滤器\nimport javax.servlet.*; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletRequestWrapper; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.UnsupportedEncodingException; import java.util.Map; /** * 解决get和post请求 全部乱码的过滤器 */ public class GenericEncodingFilter implements Filter { @Override public void destroy() { } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { //处理response的字符编码  HttpServletResponse myResponse=(HttpServletResponse) response; myResponse.setContentType(\u0026#34;text/html;charset=UTF-8\u0026#34;); // 转型为与协议相关对象  HttpServletRequest httpServletRequest = (HttpServletRequest) request; // 对request包装增强  HttpServletRequest myrequest = new MyRequest(httpServletRequest); chain.doFilter(myrequest, response); } @Override public void init(FilterConfig filterConfig) throws ServletException { } } //自定义request对象，HttpServletRequest的包装类 class MyRequest extends HttpServletRequestWrapper { private HttpServletRequest request; //是否编码的标记  private boolean hasEncode; //定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰  public MyRequest(HttpServletRequest request) { super(request);// super必须写  this.request = request; } // 对需要增强方法 进行覆盖  @Override public Map getParameterMap() { // 先获得请求方式  String method = request.getMethod(); if (method.equalsIgnoreCase(\u0026#34;post\u0026#34;)) { // post请求  try { // 处理post乱码  request.setCharacterEncoding(\u0026#34;utf-8\u0026#34;); return request.getParameterMap(); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } } else if (method.equalsIgnoreCase(\u0026#34;get\u0026#34;)) { // get请求  Map\u0026lt;String, String[]\u0026gt; parameterMap = request.getParameterMap(); if (!hasEncode) { // 确保get手动编码逻辑只运行一次  for (String parameterName : parameterMap.keySet()) { String[] values = parameterMap.get(parameterName); if (values != null) { for (int i = 0; i \u0026lt; values.length; i++) { try { // 处理get乱码  values[i] = new String(values[i] .getBytes(\u0026#34;ISO-8859-1\u0026#34;), \u0026#34;utf-8\u0026#34;); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } } } } hasEncode = true; } return parameterMap; } return super.getParameterMap(); } //取一个值  @Override public String getParameter(String name) { Map\u0026lt;String, String[]\u0026gt; parameterMap = getParameterMap(); String[] values = parameterMap.get(name); if (values == null) { return null; } return values[0]; // 取回参数的第一个值  } //取所有值  @Override public String[] getParameterValues(String name) { Map\u0026lt;String, String[]\u0026gt; parameterMap = getParameterMap(); String[] values = parameterMap.get(name); return values; } } 这个也是我在网上找的一些大神写的，一般情况下，SpringMVC默认的乱码处理就已经能够很好的解决了！\n然后在web.xml中配置这个过滤器即可！\n乱码问题，需要平时多注意，在尽可能能设置编码的地方，都设置为统一编码 UTF-8！\n","date":"2021-11-09T09:40:04+08:00","permalink":"https://example.com/p/springmvc04-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%8F%8A%E8%B7%B3%E8%BD%AC/","title":"SpringMVC04 数据处理及跳转"},{"content":"RestFul和控制器 控制器Controller   控制器复杂提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。\n  控制器负责解析用户的请求并将其转换为一个模型。\n  在Spring MVC中一个控制器类可以包含多个方法\n  在Spring MVC中，对于Controller的配置方式有很多种\n  实现Controller接口 Controller是一个接口，在org.springframework.web.servlet.mvc包下，接口中只有一个方法；\n  编写一个Controller类，ControllerTest1\n//定义控制器 //注意点：不要导错包，实现Controller接口，重写方法； public class ControllerTest1 implements Controller { //处理请求且返回一个模型与视图对象  public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponsehttpServletResponse) throws Exception { //返回一个模型视图对象  ModelAndView mv = new ModelAndView(); mv.addObject(\u0026#34;msg\u0026#34;,\u0026#34;Test1Controller\u0026#34;); mv.setViewName(\u0026#34;test\u0026#34;); return mv; } }   编写完毕后，去Spring配置文件中注册请求的bean；name对应请求路径，class对应处理请求的类\n\u0026lt;bean name=\u0026#34;/t1\u0026#34; class=\u0026#34;com.xxgc.controller.ControllerTest1\u0026#34;/\u0026gt;   编写前端test.jsp，注意在WEB-INF/jsp目录下编写，对应我们的视图解析器\n\u0026lt;%@ page contentType=\u0026quot;text/html;charset=UTF-8\u0026quot; language=\u0026quot;java\u0026quot; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;jsp\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; ${msg} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   配置Tomcat运行测试，我这里没有项目发布名配置的就是一个 / ，所以请求不用加项目名，OK！\n  说明：\n  实现接口Controller定义控制器是较老的办法\n  缺点是：一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller；定义的方式比较麻烦；\n  使用 @Controller 注解 @Controller注解类型用于声明Spring类的实例是一个控制器（在讲IOC时还提到了另外3个注解）；\nSpring 中配置组件扫描 \u0026lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.cuit.spring.controller\u0026#34;/\u0026gt; 注解实现 @Controller //@Controller注解的类会自动添加到Spring上下文中 @Controller public class ControllerTest2{ //映射访问路径  @RequestMapping(\u0026#34;/t2\u0026#34;) public String index(Model model){ //Spring MVC会自动实例化一个Model对象用于向视图中传值  model.addAttribute(\u0026#34;msg\u0026#34;, \u0026#34;ControllerTest2\u0026#34;); //返回视图位置  return \u0026#34;test\u0026#34;; } } 运行tomcat测试 可以发现，我们的两个请求都可以指向一个视图，但是页面结果的结果是不一样的，从这里可以看出视图是被复用的，而控制器与视图之间是弱偶合关系。\n注解方式是平时使用的最多的方式！\nRequestMapping @RequestMapping @RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。\n只注解方法 @Controller public class TestController { @RequestMapping(\u0026#34;/h1\u0026#34;) public String test(){ return \u0026#34;test\u0026#34;; } } 访问路径：http://localhost:8080 / 项目名 / h1\n同时注解类与方法 @Controller @RequestMapping(\u0026#34;/admin\u0026#34;) public class TestController { @RequestMapping(\u0026#34;/h1\u0026#34;) public String test(){ return \u0026#34;test\u0026#34;; } } 访问路径：http://localhost:8080 / 项目名/ admin /h1 , 需要先指定类的路径再指定方法的路径；\nRestFul 风格 概念 Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。\n功能 资源：互联网所有的事物都可以被抽象为资源\n资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。\n分别对应 添加、 删除、修改、查询。\n传统方式操作资源 ：通过不同的参数来实现不同的效果！方法单一，post 和 get\n​\thttp://127.0.0.1/item/queryItem.action?id=1 查询,GET\n​\thttp://127.0.0.1/item/saveItem.action 新增,POST\n​\thttp://127.0.0.1/item/updateItem.action 更新,POST\n​\thttp://127.0.0.1/item/deleteItem.action?id=1 删除,GET或POST\n使用RESTful操作资源 ：可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！\n​\thttp://127.0.0.1/item/1 查询,GET\n​\thttp://127.0.0.1/item 新增,POST\n​\thttp://127.0.0.1/item 更新,PUT\n​\thttp://127.0.0.1/item/1 删除,DELETE\n测试 在Spring MVC中可以使用 @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。\n@Controller public class RestFulController { //映射访问路径  @RequestMapping(\u0026#34;/commit/{p1}/{p2}\u0026#34;) public String index(@PathVariable int p1, @PathVariable int p2, Model model){ int result = p1+p2; //Spring MVC会自动实例化一个Model对象用于向视图中传值  model.addAttribute(\u0026#34;msg\u0026#34;, \u0026#34;结果：\u0026#34;+result); //返回视图位置  return \u0026#34;test\u0026#34;; } } 我们来测试请求查看下\n使用路径变量的好处？\n 使路径变得更加简洁； 获得参数更加方便，框架会自动进行类型转换。 通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是/commit/1/a，则路径与方法不匹配，而不会是参数转换失败。  我们来修改下对应的参数类型，再次测试\n//映射访问路径 @RequestMapping(\u0026#34;/commit/{p1}/{p2}\u0026#34;) public String index(@PathVariable int p1, @PathVariable String p2, Model model){ String result = p1+p2; //Spring MVC会自动实例化一个Model对象用于向视图中传值  model.addAttribute(\u0026#34;msg\u0026#34;, \u0026#34;结果：\u0026#34;+result); //返回视图位置  return \u0026#34;test\u0026#34;; } 使用method属性指定请求类型 用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等\n我们来测试一下：\n  增加一个方法\n//映射访问路径,必须是POST请求 @RequestMapping(value = \u0026#34;/hello\u0026#34;,method = {RequestMethod.POST}) public String index2(Model model){ model.addAttribute(\u0026#34;msg\u0026#34;, \u0026#34;hello!\u0026#34;); return \u0026#34;test\u0026#34;; }   我们使用浏览器地址栏进行访问默认是Get请求，会报错405：\n  如果将POST修改为GET则正常了；\n//映射访问路径,必须是Get请求 @RequestMapping(value = \u0026#34;/hello\u0026#34;,method = {RequestMethod.GET}) public String index2(Model model){ model.addAttribute(\u0026#34;msg\u0026#34;, \u0026#34;hello!\u0026#34;); return \u0026#34;test\u0026#34;; }   小结： Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。\n所有的地址栏请求默认都会是 HTTP GET 类型的。\n方法级别的注解变体有如下几个：组合注解\n@GetMapping @PostMapping @PutMapping @DeleteMapping @PatchMapping @GetMapping 是一个组合注解，平时使用的会比较多！\n它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。\n","date":"2021-11-09T09:39:07+08:00","permalink":"https://example.com/p/springmvc03-restful%E5%92%8C%E6%8E%A7%E5%88%B6%E5%99%A8/","title":"SpringMVC03 RestFul和控制器"},{"content":"配置springMVC 配置版 新建一个Moudle ， springmvc-02-hello ， 添加web的支持！\n确定导入了SpringMVC 的依赖！\n配置web.xml，注册DispatcherServlet \u0026lt;!DOCTYPE web-app PUBLIC \u0026#34;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\u0026#34; \u0026#34;http://java.sun.com/dtd/web-app_2_3.dtd\u0026#34; \u0026gt; \u0026lt;web-app\u0026gt; \u0026lt;display-name\u0026gt;Archetype Created Web Application\u0026lt;/display-name\u0026gt; \u0026lt;!--1.注册DispatcherServlet--\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:springmvc-servlet.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;!--启动级别-1--\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;!--/ 匹配所有的请求；（不包括.jsp）--\u0026gt; \u0026lt;!--/* 匹配所有的请求；（包括.jsp）--\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt; 编写SpringMVC 的 配置文件 名称：springmvc-servlet.xml : [servletname]-servlet.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt;\u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;/beans\u0026gt; 添加 处理映射器 \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\u0026#34;/\u0026gt; 添加 处理器适配器 \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\u0026#34;/\u0026gt; 添加 视图解析器 \u0026lt;!--视图解析器:DispatcherServlet给他的ModelAndView--\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026#34; id=\u0026#34;InternalResourceViewResolver\u0026#34;\u0026gt; \u0026lt;!--前缀--\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/jsp/\u0026#34;/\u0026gt; \u0026lt;!--后缀--\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 编写我们要操作业务Controller 要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图；\npackage com.kuang.controller; import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller; import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse; //注意：这里我们先导入Controller接口public class HelloController implements Controller { public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception { //ModelAndView 模型和视图  ModelAndView mv = new ModelAndView(); //封装对象，放在ModelAndView中。  mv.addObject(\u0026#34;msg\u0026#34;,\u0026#34;HelloSpringMVC!\u0026#34;); //封装要跳转的视图，放在ModelAndView中  mv.setViewName(\u0026#34;hello\u0026#34;); // /WEB-INF/jsp/hello.jsp  return mv; } } 将自己的类交给SpringIOC容器，注册bean \u0026lt;!--Handler--\u0026gt; \u0026lt;bean id=\u0026#34;/hello\u0026#34; class=\u0026#34;com.xxgc.controller.HelloController\u0026#34;/\u0026gt; 写要跳转的jsp页面，显示ModelandView存放的数据 \u0026lt;%@ page contentType=\u0026quot;text/html;charset=UTF-8\u0026quot; language=\u0026quot;java\u0026quot; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;jsp\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;${msg}\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 配置Tomcat 启动测试！ 可能遇到的问题：访问出现404，排查步骤：\n 查看控制台输出，看一下是不是缺少了什么jar包。 如果jar包存在，显示无法输出，就在IDEA的项目发布中，添加lib依赖！ 重启Tomcat 即可解决！  小结：看这个估计大部分同学都能理解其中的原理了，但是我们实际开发才不会这么写，不然就疯了，还学这个玩意干嘛！我们来看个注解版实现，这才是SpringMVC的精髓，到底有多么简单，看这个图就知道了。\n注解版 新建一个Moudle，springmvc-03-hello-annotation 。添加web支持！\n由于Maven可能存在资源过滤的问题，我们将配置完善\n\u0026lt;build\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/java\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/resources\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;/build\u0026gt; 在pom.xml文件引入相关的依赖：主要有Spring框架核心库、Spring MVC、servlet , JSTL等。我们在父依赖中已经引入了！\n配置web.xml \u0026lt;!DOCTYPE web-app PUBLIC \u0026#34;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\u0026#34; \u0026#34;http://java.sun.com/dtd/web-app_2_3.dtd\u0026#34; \u0026gt; \u0026lt;web-app\u0026gt; \u0026lt;display-name\u0026gt;Archetype Created Web Application\u0026lt;/display-name\u0026gt; \u0026lt;!--1.注册DispatcherServlet--\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:springmvc-servlet.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;!--启动级别-1--\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;!--/ 匹配所有的请求；（不包括.jsp）--\u0026gt; \u0026lt;!--/* 匹配所有的请求；（包括.jsp）--\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt; / 和 /* 的区别：\n\u0026lt; url-pattern \u0026gt; / \u0026lt;/ url-pattern \u0026gt; 不会匹配到.jsp， 只针对我们编写的请求；即：.jsp 不会进入spring的 DispatcherServlet类 。\n\u0026lt; url-pattern \u0026gt; /* \u0026lt;/ url-pattern \u0026gt; 会匹配 *.jsp，会出现返回 jsp视图 时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错。\n添加Spring MVC配置文件 在resource目录下添加springmvc-servlet.xml配置文件，配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能，具体配置信息如下：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:mvc=\u0026#34;http://www.springframework.org/schema/mvc\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\u0026#34;\u0026gt; \u0026lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.xxgc.spring.controller\u0026#34;/\u0026gt; \u0026lt;!-- 让Spring MVC不处理静态资源 HTML . JS . CSS . 图片 ， 视频 等等 --\u0026gt; \u0026lt;mvc:default-servlet-handler /\u0026gt; \u0026lt;!-- 支持mvc注解驱动 在spring中一般采用@RequestMapping注解来完成映射关系 要想使@RequestMapping注解生效 必须向上下文中注册DefaultAnnotationHandlerMapping 和一个AnnotationMethodHandlerAdapter实例 这两个实例分别在类级别和方法级别处理。 而annotation-driven配置帮助我们自动完成上述两个实例的注入。 --\u0026gt; \u0026lt;mvc:annotation-driven /\u0026gt; \u0026lt;!-- 视图解析器 --\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026#34; id=\u0026#34;internalResourceViewResolver\u0026#34;\u0026gt; \u0026lt;!-- 前缀 --\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/jsp/\u0026#34; /\u0026gt; \u0026lt;!-- 后缀 --\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 在视图解析器中我们把所有的视图都存放在/WEB-INF/目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问。\n创建Controller 编写一个Java控制类：\npackage com.xxgc.spring.controller; import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping; @Controller@RequestMapping(\u0026#34;/HelloController\u0026#34;) public class HelloController { //真实访问地址 : 项目名/HelloController/hello  @RequestMapping(\u0026#34;/hello\u0026#34;) public String sayHello(Model model){ //向模型中添加属性msg与值，可以在JSP页面中取出并渲染  model.addAttribute(\u0026#34;msg\u0026#34;,\u0026#34;hello,SpringMVC\u0026#34;); //web-inf/jsp/hello.jsp  return \u0026#34;hello\u0026#34;; } }   @Controller是为了让Spring IOC容器初始化时自动扫描到；\n  @RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/HelloController/hello；\n  方法中声明Model类型的参数是为了把Action中的数据带到视图中；\n  方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/hello.jsp。\n  创建视图层 在WEB-INF/ jsp目录中创建hello.jsp ， 视图可以直接取出并展示从Controller带回的信息；\n可以通过EL表示取出Model中存放的值，或者对象；\n\u0026lt;%@ page contentType=\u0026quot;text/html;charset=UTF-8\u0026quot; language=\u0026quot;java\u0026quot; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;SpringMVC\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;${msg}\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 配置Tomcat运行 配置Tomcat ， 开启服务器 ， 访问 对应的请求路径！\n小结 实现步骤其实非常的简单：\n 新建一个web项目 导入相关jar包 编写web.xml , 注册DispatcherServlet 编写springmvc配置文件 接下来就是去创建对应的控制类 , controller 最后完善前端视图和controller之间的对应 测试运行调试.  使用springMVC必须配置的三大件：\n处理器映射器、处理器适配器、视图解析器\n通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可，而省去了大段的xml配置\n","date":"2021-11-09T09:38:02+08:00","permalink":"https://example.com/p/springmvc02-%E9%85%8D%E7%BD%AEspringmvc/","title":"SpringMVC02 配置springMVC"},{"content":"什么是SpringMVC 回顾MVC 什么是MVC  MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。 是将业务逻辑、数据、显示分离的方法来组织代码。 MVC主要作用是降低了视图与业务逻辑间的双向偶合。 MVC不是一种设计模式，MVC是一种架构模式。当然不同的MVC存在差异。  **Model（模型）：**数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。\n**View（视图）：**负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。\n**Controller（控制器）：**接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。\n最典型的MVC就是JSP + servlet + javabean的模式。\nModel1时代  在web早期的开发中，通常采用的都是Model1。 Model1中，主要分为两层，视图层和模型层。  Model1优点：架构简单，比较适合小型项目开发；\nModel1缺点：JSP职责不单一，职责过重，不便于维护；\nModel2时代 Model2把一个项目分成三部分，包括视图、控制、模型。\n 用户发请求 Servlet接收请求数据，并调用对应的业务逻辑方法 业务处理完毕，返回更新后的数据给servlet servlet转向到JSP，由JSP来渲染页面 响应给前端更新后的页面  职责分析： Controller：控制器\n 取得表单数据 调用业务逻辑 转向指定的页面  Model：模型\n 业务逻辑 保存数据的状态  View：视图\n 显示页面  Model2这样不仅提高的代码的复用率与项目的扩展性，且大大降低了项目的维护成本。Model 1模式的实现比较简单，适用于快速开发小规模项目，Model1中JSP页面身兼View和Controller两种角色，将控制逻辑和表现逻辑混杂在一起，从而导致代码的重用性非常低，增加了应用的扩展性和维护的难度。Model2消除了Model1的缺点。\n回顾Servlet   新建一个Maven工程当做父工程！pom依赖！\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.9.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet.jsp\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jsp-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jstl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;   建立一个Moudle：springmvc-01-servlet ， 添加Web app的支持！\n  导入servlet 和 jsp 的 jar 依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet.jsp\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jsp-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   编写一个Servlet类，用来处理用户的请求\npackage com.xxgc.servlet; //实现Servlet接口 public class HelloServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //取得参数  String method = req.getParameter(\u0026#34;method\u0026#34;); if (method.equals(\u0026#34;add\u0026#34;)){ req.getSession().setAttribute(\u0026#34;msg\u0026#34;,\u0026#34;执行了add方法\u0026#34;); } if (method.equals(\u0026#34;delete\u0026#34;)){ req.getSession().setAttribute(\u0026#34;msg\u0026#34;,\u0026#34;执行了delete方法\u0026#34;); } //业务逻辑  //视图跳转  req.getRequestDispatcher(\u0026#34;/WEB-INF/jsp/hello.jsp\u0026#34;).forward(req,resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req,resp); } }   编写Hello.jsp，在WEB-INF目录下新建一个jsp的文件夹，新建hello.jsp\n\u0026lt;%@ page contentType=\u0026quot;text/html;charset=UTF-8\u0026quot; language=\u0026quot;java\u0026quot; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;jsp\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; ${msg} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   在web.xml中注册Servlet\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;HelloServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;com.kuang.servlet.HelloServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;HelloServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/user\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt;   配置Tomcat，并启动测试\n   localhost:8080/user?method=add localhost:8080/user?method=delete    MVC框架要做哪些事情\n 将url映射到java类或java类的方法 . 封装用户提交的数据 . 处理请求\u0026ndash;调用相关的业务处理\u0026ndash;封装响应数据 . 将响应的数据进行渲染 . jsp / html 等表示层数据 .  说明：\n​\t常见的服务器端MVC框架有：Struts、Spring MVC、ASP.NET MVC、Zend Framework、JSF；常见前端MVC框架：vue、angularjs、react、backbone；由MVC演化出了另外一些模式如：MVP、MVVM 等等\u0026hellip;.\n什么是SpringMVC 概述 Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。\n查看官方文档：https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web.html#spring-web\n我们为什么要学习SpringMVC呢?\nSpring MVC的特点：\n 轻量级，简单易学 高效 , 基于请求响应的MVC框架 与Spring兼容性好，无缝结合 约定优于配置 功能强大：RESTful、数据验证、格式化、本地化、主题等 简洁灵活  Spring的web框架围绕DispatcherServlet [ 调度Servlet ] 设计。\nDispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解形式进行开发，十分简洁；\n正因为SpringMVC好 , 简单 , 便捷 , 易学 , 天生和Spring无缝集成(使用SpringIoC和Aop) , 使用约定优于配置 . 能够进行简单的junit测试 . 支持Restful风格 .异常处理 , 本地化 , 国际化 , 数据验证 , 类型转换 , 拦截器 等等\u0026hellip;\u0026hellip;所以我们要学习 .\n最重要的一点还是用的人多 , 使用的公司多 .\n中心控制器 ​\tSpring的web框架围绕DispatcherServlet设计。DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解的controller声明方式。\n​\tSpring MVC框架像许多其他MVC框架一样, 以请求为驱动 , 围绕一个中心Servlet分派请求及提供其他功能，DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)。\n​\t当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。\nSpringMVC执行原理 简要分析执行流程\n  DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。\n我们假设请求的url为 : http://localhost:8080/SpringMVC/hello\n如上url拆分成三部分：\nhttp://localhost:8080服务器域名\nSpringMVC 部署在服务器上的web站点\nhello 表示控制器\n通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。\n  HandlerMapping为处理器映射DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。\n  HandlerExecution表示具体的Handler其主要作用是根据url查找控制器，如上url被查找控制器为：hello。\n  HandlerExecution将解析后的信息传递给DispatcherServlet如解析控制器映射等。\n  HandlerAdapter表示处理器适配器其按照特定的规则去执行Handler。\n  Handler让具体的Controller执行。\n  Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。\n  HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。\n  DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。\n  视图解析器将解析的逻辑视图名传给DispatcherServlet。\n  DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。\n  最终视图呈现给用户。\n  ","date":"2021-11-09T09:36:36+08:00","permalink":"https://example.com/p/springmvc01-%E4%BB%80%E4%B9%88%E6%98%AFspringmvc/","title":"SpringMVC01 什么是SpringMVC"},{"content":"整合MyBatis\n 步骤  1、导入相关jar包\njunit\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; mybatis\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; mysql-connector-java\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.47\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; spring相关\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.10.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.10.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; aspectJ AOP 织入器\n\u0026lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; mybatis-spring整合包 【重点】\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 配置Maven静态资源过滤问题！\n\u0026lt;build\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/java\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;true\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;/build\u0026gt; 2、编写配置文件\n3、代码实现\n 回忆MyBatis  编写pojo实体类\npackage com.kuang.pojo; public class User { private int id; //id private String name; //姓名 private String pwd; //密码 } 实现mybatis的配置文件\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026quot;-//mybatis.org//DTD Config 3.0//EN\u0026quot; \u0026quot;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026quot;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;package name=\u0026quot;com.kuang.pojo\u0026quot;/\u0026gt; \u0026lt;/typeAliases\u0026gt; \u0026lt;environments default=\u0026quot;development\u0026quot;\u0026gt; \u0026lt;environment id=\u0026quot;development\u0026quot;\u0026gt; \u0026lt;transactionManager type=\u0026quot;JDBC\u0026quot;/\u0026gt; \u0026lt;dataSource type=\u0026quot;POOLED\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;driver\u0026quot; value=\u0026quot;com.mysql.jdbc.Driver\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;url\u0026quot; value=\u0026quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true\u0026amp;amp;useUnicode=true\u0026amp;amp;characterEncoding=utf8\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;username\u0026quot; value=\u0026quot;root\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;123456\u0026quot;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;package name=\u0026quot;com.kuang.dao\u0026quot;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt; UserDao接口编写\npublic interface UserMapper { public List\u0026lt;User\u0026gt; selectUser(); } 接口对应的Mapper映射文件\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026quot;-//mybatis.org//DTD Mapper 3.0//EN\u0026quot; \u0026quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026quot;\u0026gt; \u0026lt;mapper namespace=\u0026quot;com.kuang.dao.UserMapper\u0026quot;\u0026gt; \u0026lt;select id=\u0026quot;selectUser\u0026quot; resultType=\u0026quot;User\u0026quot;\u0026gt; select * from user \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 测试类\n@Test public void selectUser() throws IOException { String resource = \u0026quot;mybatis-config.xml\u0026quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); List\u0026lt;User\u0026gt; userList = mapper.selectUser(); for (User user: userList){ System.out.println(user); } sqlSession.close(); }  MyBatis-Spring学习  引入Spring之前需要了解mybatis-spring包中的一些重要类；\nhttp://www.mybatis.org/spring/zh/index.html\n 图片 \n什么是 MyBatis-Spring？\nMyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。\n知识基础\n在开始使用 MyBatis-Spring 之前，你需要先熟悉 Spring 和 MyBatis 这两个框架和有关它们的术语。这很重要\nMyBatis-Spring 需要以下版本：\n   MyBatis-Spring MyBatis Spring 框架 Spring Batch Java     2.0 3.5+ 5.0+ 4.0+ Java 8+   1.3 3.4+ 3.2.2+ 2.1+ Java 6+    如果使用 Maven 作为构建工具，仅需要在 pom.xml 中加入以下代码即可：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 要和 Spring 一起使用 MyBatis，需要在 Spring 应用上下文中定义至少两样东西：一个 SqlSessionFactory 和至少一个数据映射器类。\n在 MyBatis-Spring 中，可使用SqlSessionFactoryBean来创建 SqlSessionFactory。要配置这个工厂 bean，只需要把下面代码放在 Spring 的 XML 配置文件中：\n\u0026lt;bean id=\u0026quot;sqlSessionFactory\u0026quot; class=\u0026quot;org.mybatis.spring.SqlSessionFactoryBean\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;dataSource\u0026quot; ref=\u0026quot;dataSource\u0026quot; /\u0026gt; \u0026lt;/bean\u0026gt; 注意：SqlSessionFactory需要一个 DataSource（数据源）。这可以是任意的 DataSource，只需要和配置其它 Spring 数据库连接一样配置它就可以了。\n在基础的 MyBatis 用法中，是通过 SqlSessionFactoryBuilder 来创建 SqlSessionFactory 的。而在 MyBatis-Spring 中，则使用 SqlSessionFactoryBean 来创建。\n在 MyBatis 中，你可以使用 SqlSessionFactory 来创建 SqlSession。一旦你获得一个 session 之后，你可以使用它来执行映射了的语句，提交或回滚连接，最后，当不再需要它的时候，你可以关闭 session。\nSqlSessionFactory有一个唯一的必要属性：用于 JDBC 的 DataSource。这可以是任意的 DataSource 对象，它的配置方法和其它 Spring 数据库连接是一样的。\n一个常用的属性是 configLocation，它用来指定 MyBatis 的 XML 配置文件路径。它在需要修改 MyBatis 的基础配置非常有用。通常，基础配置指的是 \u0026lt; settings\u0026gt; 或 \u0026lt; typeAliases\u0026gt;元素。\n需要注意的是，这个配置文件并不需要是一个完整的 MyBatis 配置。确切地说，任何环境配置（），数据源（）和 MyBatis 的事务管理器（）都会被忽略。SqlSessionFactoryBean 会创建它自有的 MyBatis 环境配置（Environment），并按要求设置自定义环境的值。\nSqlSessionTemplate 是 MyBatis-Spring 的核心。作为 SqlSession 的一个实现，这意味着可以使用它无缝代替你代码中已经在使用的 SqlSession。\n模板可以参与到 Spring 的事务管理中，并且由于其是线程安全的，可以供多个映射器类使用，你应该总是用 SqlSessionTemplate 来替换 MyBatis 默认的 DefaultSqlSession 实现。在同一应用程序中的不同类之间混杂使用可能会引起数据一致性的问题。\n可以使用 SqlSessionFactory 作为构造方法的参数来创建 SqlSessionTemplate 对象。\n\u0026lt;bean id=\u0026quot;sqlSession\u0026quot; class=\u0026quot;org.mybatis.spring.SqlSessionTemplate\u0026quot;\u0026gt; \u0026lt;constructor-arg index=\u0026quot;0\u0026quot; ref=\u0026quot;sqlSessionFactory\u0026quot; /\u0026gt; \u0026lt;/bean\u0026gt; 现在，这个 bean 就可以直接注入到你的 DAO bean 中了。你需要在你的 bean 中添加一个 SqlSession 属性，就像下面这样：\npublic class UserDaoImpl implements UserDao { private SqlSession sqlSession; public void setSqlSession(SqlSession sqlSession) { this.sqlSession = sqlSession; } public User getUser(String userId) { return sqlSession.getMapper...; } } 按下面这样，注入 SqlSessionTemplate：\n\u0026lt;bean id=\u0026quot;userDao\u0026quot; class=\u0026quot;org.mybatis.spring.sample.dao.UserDaoImpl\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;sqlSession\u0026quot; ref=\u0026quot;sqlSession\u0026quot; /\u0026gt; \u0026lt;/bean\u0026gt;  整合实现一  1、引入Spring配置文件beans.xml\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;beans xmlns=\u0026quot;http://www.springframework.org/schema/beans\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026quot;\u0026gt; 2、配置数据源替换mybaits的数据源\n\u0026lt;!--配置数据源：数据源有非常多，可以使用第三方的，也可使使用Spring的--\u0026gt; \u0026lt;bean id=\u0026quot;dataSource\u0026quot; class=\u0026quot;org.springframework.jdbc.datasource.DriverManagerDataSource\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;driverClassName\u0026quot; value=\u0026quot;com.mysql.jdbc.Driver\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;url\u0026quot; value=\u0026quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true\u0026amp;amp;useUnicode=true\u0026amp;amp;characterEncoding=utf8\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;username\u0026quot; value=\u0026quot;root\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;123456\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt; 3、配置SqlSessionFactory，关联MyBatis\n\u0026lt;!--配置SqlSessionFactory--\u0026gt; \u0026lt;bean id=\u0026quot;sqlSessionFactory\u0026quot; class=\u0026quot;org.mybatis.spring.SqlSessionFactoryBean\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;dataSource\u0026quot; ref=\u0026quot;dataSource\u0026quot;/\u0026gt; \u0026lt;!--关联Mybatis--\u0026gt; \u0026lt;property name=\u0026quot;configLocation\u0026quot; value=\u0026quot;classpath:mybatis-config.xml\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;mapperLocations\u0026quot; value=\u0026quot;classpath:com/kuang/dao/*.xml\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt; 4、注册sqlSessionTemplate，关联sqlSessionFactory；\n\u0026lt;!--注册sqlSessionTemplate , 关联sqlSessionFactory--\u0026gt; \u0026lt;bean id=\u0026quot;sqlSession\u0026quot; class=\u0026quot;org.mybatis.spring.SqlSessionTemplate\u0026quot;\u0026gt; \u0026lt;!--利用构造器注入--\u0026gt; \u0026lt;constructor-arg index=\u0026quot;0\u0026quot; ref=\u0026quot;sqlSessionFactory\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt; 5、增加Dao接口的实现类；私有化sqlSessionTemplate\npublic class UserDaoImpl implements UserMapper { //sqlSession不用我们自己创建了，Spring来管理 private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) { this.sqlSession = sqlSession; } public List\u0026lt;User\u0026gt; selectUser() { UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.selectUser(); } } 6、注册bean实现\n\u0026lt;bean id=\u0026quot;userDao\u0026quot; class=\u0026quot;com.kuang.dao.UserDaoImpl\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;sqlSession\u0026quot; ref=\u0026quot;sqlSession\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt; 7、测试\n @Test public void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026quot;beans.xml\u0026quot;); UserMapper mapper = (UserMapper) context.getBean(\u0026quot;userDao\u0026quot;); List\u0026lt;User\u0026gt; user = mapper.selectUser(); System.out.println(user); } 结果成功输出！现在我们的Mybatis配置文件的状态！发现都可以被Spring整合！\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026quot;-//mybatis.org//DTD Config 3.0//EN\u0026quot; \u0026quot;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026quot;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;package name=\u0026quot;com.kuang.pojo\u0026quot;/\u0026gt; \u0026lt;/typeAliases\u0026gt; \u0026lt;/configuration\u0026gt;  整合实现二  mybatis-spring1.2.3版以上的才有这个 .\n官方文档截图 :\ndao继承Support类 , 直接利用 getSqlSession() 获得 , 然后直接注入SqlSessionFactory . 比起方式1 , 不需要管理SqlSessionTemplate , 而且对事务的支持更加友好 . 可跟踪源码查看\n 图片 \n测试：\n1、将我们上面写的UserDaoImpl修改一下\npublic class UserDaoImpl extends SqlSessionDaoSupport implements UserMapper { public List\u0026lt;User\u0026gt; selectUser() { UserMapper mapper = getSqlSession().getMapper(UserMapper.class); return mapper.selectUser(); } } 2、修改bean的配置\n\u0026lt;bean id=\u0026quot;userDao\u0026quot; class=\u0026quot;com.kuang.dao.UserDaoImpl\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;sqlSessionFactory\u0026quot; ref=\u0026quot;sqlSessionFactory\u0026quot; /\u0026gt; \u0026lt;/bean\u0026gt; 3、测试\n@Test public void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026quot;beans.xml\u0026quot;); UserMapper mapper = (UserMapper) context.getBean(\u0026quot;userDao\u0026quot;); List\u0026lt;User\u0026gt; user = mapper.selectUser(); System.out.println(user); } 总结 : 整合到spring以后可以完全不要mybatis的配置文件，除了这些方式可以实现整合之外，我们还可以使用注解来实现，这个等我们后面学习SpringBoot的时候还会测试整合！\n","date":"2021-11-09T09:28:49+08:00","permalink":"https://example.com/p/spring08-%E6%95%B4%E5%90%88mybatis/","title":"Spring08 整合MyBatis"},{"content":"声明式事务 回顾事务  事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！ 事务管理是企业级应用程序开发中必备技术，用来确保数据的完整性和一致性。  事务就是把一系列的动作当成一个独立的工作单元，这些动作要么全部完成，要么全部不起作用。\n事务四个属性ACID 原子性（atomicity）  事务是原子性操作，由一系列动作组成，事务的原子性确保动作要么全部完成，要么完全不起作用  一致性（consistency）  一旦所有事务动作完成，事务就要被提交。数据和资源处于一种满足业务规则的一致性状态中  隔离性（isolation）  可能多个事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏  持久性（durability）  事务一旦完成，无论系统发生什么错误，结果都不会受到影响。通常情况下，事务的结果被写到持久化存储器中  测试 将上面的代码拷贝到一个新项目中\n在之前的案例中，我们给userDao接口新增两个方法，删除和增加用户；\n//添加一个用户 int addUser(User user); //根据id删除用户 int deleteUser(int id); mapper文件，我们故意把 deletes 写错，测试！\n\u0026lt;insert id=\u0026#34;addUser\u0026#34; parameterType=\u0026#34;com.kuang.pojo.User\u0026#34;\u0026gt; insert into user (id,name,pwd) values (#{id},#{name},#{pwd}) \u0026lt;/insert\u0026gt; \u0026lt;delete id=\u0026#34;deleteUser\u0026#34; parameterType=\u0026#34;int\u0026#34;\u0026gt; deletes from user where id = #{id} \u0026lt;/delete\u0026gt; 编写接口的实现类，在实现类中，我们去操作一波\npublic class UserDaoImpl extends SqlSessionDaoSupport implements UserMapper { //增加一些操作  public List\u0026lt;User\u0026gt; selectUser() { User user = new User(4,\u0026#34;小明\u0026#34;,\u0026#34;123456\u0026#34;); UserMapper mapper = getSqlSession().getMapper(UserMapper.class); mapper.addUser(user); mapper.deleteUser(4); return mapper.selectUser(); } //新增  public int addUser(User user) { UserMapper mapper = getSqlSession().getMapper(UserMapper.class); return mapper.addUser(user); } //删除  public int deleteUser(int id) { UserMapper mapper = getSqlSession().getMapper(UserMapper.class); return mapper.deleteUser(id); } } 测试\n@Test public void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans.xml\u0026#34;); UserMapper mapper = (UserMapper) context.getBean(\u0026#34;userDao\u0026#34;); List\u0026lt;User\u0026gt; user = mapper.selectUser(); System.out.println(user); } 报错：sql异常，delete写错了\n结果 ：插入成功！\n没有进行事务的管理；我们想让他们都成功才成功，有一个失败，就都失败，我们就应该需要事务！\n以前我们都需要自己手动管理事务，十分麻烦！\n但是Spring给我们提供了事务管理，我们只需要配置即可；\nSpring中的事务管理 Spring在不同的事务管理API之上定义了一个抽象层，使得开发人员不必了解底层的事务管理API就可以使用Spring的事务管理机制。Spring支持编程式事务管理和声明式的事务管理。\n编程式事务管理  将事务管理代码嵌到业务方法中来控制事务的提交和回滚 缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码  声明式事务管理  一般情况下比编程式事务好用。 将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。 将事务管理作为横切关注点，通过aop方法模块化。Spring中通过Spring AOP框架支持声明式事务管理。  使用Spring管理事务 注意头文件的约束导入 : tx\nxmlns:tx=\u0026#34;http://www.springframework.org/schema/tx\u0026#34; http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\u0026#34;\u0026gt; 事务管理器  无论使用Spring的哪种事务管理策略（编程式或者声明式）事务管理器都是必须的。 就是 Spring的核心事务管理抽象，管理封装了一组独立于技术的方法。  JDBC事务 \u0026lt;bean id=\u0026#34;transactionManager\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DataSourceTransactionManager\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; 配置好事务管理器后我们需要去配置事务的通知 \u0026lt;!--配置事务通知--\u0026gt; \u0026lt;tx:advice id=\u0026#34;txAdvice\u0026#34; transaction-manager=\u0026#34;transactionManager\u0026#34;\u0026gt; \u0026lt;tx:attributes\u0026gt; \u0026lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性--\u0026gt; \u0026lt;tx:method name=\u0026#34;add\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;delete\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;update\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;search*\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;get\u0026#34; read-only=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;*\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;/tx:attributes\u0026gt; \u0026lt;/tx:advice\u0026gt; spring事务传播特性： 事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。spring支持7种事务传播行为：\n propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。 propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。 propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。 propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。 propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。 propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作  Spring 默认的事务传播行为是 PROPAGATION_REQUIRED，它适合于绝大多数的情况。\n假设 ServiveX#methodX() 都工作在事务环境下（即都被 Spring 事务增强了），假设程序中存在如下的调用链：Service1#method1()-\u0026gt;Service2#method2()-\u0026gt;Service3#method3()，那么这 3 个服务类的 3 个方法通过 Spring 的事务传播机制都工作在同一个事务中。\n就好比，我们刚才的几个方法存在调用，所以会被放在一组事务当中！\n配置AOP 导入aop的头文件！\n\u0026lt;!--配置aop织入事务--\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;txPointcut\u0026#34; expression=\u0026#34;execution(* com.xxgc.dao.*.*(..))\u0026#34;/\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026#34;txAdvice\u0026#34; pointcut-ref=\u0026#34;txPointcut\u0026#34;/\u0026gt; \u0026lt;/aop:config\u0026gt; 进行测试\n删掉刚才插入的数据，再次测试！\n@Test public void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans.xml\u0026#34;); UserMapper mapper = (UserMapper) context.getBean(\u0026#34;userDao\u0026#34;); List\u0026lt;User\u0026gt; user = mapper.selectUser(); System.out.println(user); } 为什么需要配置事务？\n  如果不配置，就需要我们手动提交控制事务；\n  事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！\n  ","date":"2021-11-09T09:27:01+08:00","permalink":"https://example.com/p/spring09-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1/","title":"Spring09 声明式事务"},{"content":"API返回值去除为NULL的字段 简介 在前后端分离的微服务时代，后端API需要良好的规范。本篇主要将一个数据返回时的一个小技巧\u0026ndash; 过滤为空字段 解决痛点：将有效解决数据传输过程中的流量浪费。\n组件简介 Jackson ObjectMapper 通过自定义配置该组件可以选择性序列化返回的JSON。\n官方解释 Spring MVC（客户端和服务器端）用于HttpMessageConverters在HTTP交换中协商内容转换。如果Jackson在类路径上，您已经获得了提供的默认转换器Jackson2ObjectMapperBuilder，其中一个实例是为您自动配置的。 Spring Boot还具有一些功能，可以更轻松地自定义此行为。\n实战代码 创建配置类 首先创建一个配置类，加入定义为：JacksonConfig\n代码清单 import com.fasterxml.jackson.annotation.JsonInclude; import com.fasterxml.jackson.databind.ObjectMapper; import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Primary; import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder; /** * @author ybakiame * @description 返回json空值去掉null和\u0026#34;\u0026#34; * * 注解 @Configuration 注入后可自动配置 */ @Configuration public class JacksonConfig { @Bean @Primary @ConditionalOnMissingBean(ObjectMapper.class) public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) { ObjectMapper objectMapper = builder.createXmlMapper(false).build(); objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); return objectMapper; } } 关键点：objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); 通过该方法对mapper对象进行设置，所有序列化的对象都将按改规则进行系列化。 其中枚举属性：JsonInclude.Include.NON_NULL有以下选择：\n   属性 使用场景     Include.Include.ALWAYS 默认   Include.NON_DEFAULT 属性为默认值不序列化   Include.NON_EMPTY 属性为 空（\u0026quot;\u0026quot;） 或者为 NULL 都不序列化   Include.NON_NULL 属性为NULL 不序列化    替换非空\n可通过自定义替换原有制定值。代码如下：\npublic ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) { ObjectMapper objectMapper = builder.createXmlMapper(false).build(); // 字段保留，将null值转为\u0026#34;\u0026#34;  objectMapper.getSerializerProvider().setNullValueSerializer(new JsonSerializer\u0026lt;Object\u0026gt;() { @Override public void serialize(Object o, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException, JsonProcessingException { jsonGenerator.writeString(\u0026#34;\u0026#34;); } }); return objectMapper; } ","date":"2021-11-06T18:40:41+08:00","permalink":"https://example.com/p/api%E8%BF%94%E5%9B%9E%E5%80%BC%E5%8E%BB%E9%99%A4%E4%B8%BAnull%E7%9A%84%E5%AD%97%E6%AE%B5/","title":"API返回值去除为NULL的字段"},{"content":"在 pom.xml 中添加\n\u0026lt;build\u0026gt; \u0026lt;!--在进行模块化开发打jar包时，maven会将非java文件过滤掉，例如xml,properties等配置文件。--\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/java\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/resources\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;/build\u0026gt; ","date":"2021-10-26T22:14:13+08:00","permalink":"https://example.com/p/maven%E9%A1%B9%E7%9B%AExml%E8%BF%87%E6%BB%A4/","title":"Maven项目xml过滤"},{"content":"mybatis-generator 官网：https://mybatis.org/generator/\ngithub储存库：https://github.com/mybatis/generator\n什么是 mybatis-generator  MyBatis Generator (MBG) 是 MyBatis MyBatis的代码生成器。它将为所有版本的 MyBatis 生成代码。它将内省一个数据库表（或多个表）并生成可用于访问表的工件。这减少了设置对象和配置文件以与数据库表交互的初始麻烦。MBG 试图对大量简单的 CRUD（创建、检索、更新、删除）的数据库操作产生重大影响。您仍然需要为连接查询或存储过程编写 SQL 和对象代码。\n 功能  MBG 生成不同风格和不同语言的代码，这取决于它的配置方式。例如，MBG 可以生成 Java 或 Kotlin 代码。MBG 可以生成与 MyBatis3 兼容的 XML - 尽管现在被认为是 MBG 的遗留用途。生成代码的较新样式不需要 XML。\n根据它的配置方式，MyBatis Generator 可能会生成：\n  与表结构匹配的 Java 或 Kotlin 类。这可能包括：\n 匹配表主键的类（如果有主键） 匹配表的非主键字段的类（BLOB 字段除外） 一个包含表的 BLOB 字段的类（如果表有 BLOB 字段） 启用动态选择、更新和删除的类  这些类之间有适当的继承关系。请注意，生成器可以配置为生成不同类型的 POJO 层次结构 - 例如，如果您愿意，您可以选择为每个表生成单个域对象。\n  在某些情况下，MBG 会生成 MyBatis3 Compatible SQL Map XML Files。MBG 为配置中的每个表上的简单 CRUD 函数生成 SQL。生成的 SQL 语句包括：\n 插入 按主键更新 示例更新（使用动态 where 子句） 按主键删除 删除示例（使用动态 where 子句） 按主键选择 按示例选择（使用动态 where 子句） 举例数  根据表的结构，这些语句有不同的变体（例如，如果表没有主键，则 MBG 不会通过主键函数生成更新）。\n  适当使用上述对象的 Java 或 Kotlin 客户端类、接口和 Kotlin 扩展方法。客户端类的生成是可选的。MBG 将生成一个与 MyBatis 3.x 映射器基础设施配合使用的映射器接口\n  MyBatis 生成器旨在在迭代开发环境中良好运行，并且可以作为 Ant 任务或 Maven 插件包含在持续构建环境中。迭代运行 MBG 时需要注意的重要事项包括：\n 如果存在与新生成的 XML 文件同名的现有文件，MBG 将自动合并 XML 文件。MBG 不会覆盖您对其生成的 XML 文件所做的任何自定义更改。您可以一遍又一遍地运行它，而不必担心丢失对您的 XML 的自定义更改。MBG 将替换之前运行中生成的任何 XML 元素。 MBG不会合并 Java 文件，它可以覆盖现有文件或使用不同的唯一名称保存新生成的文件。如果对生成的 Java 文件进行更改并迭代运行 MBG，则必须手动合并更改。当作为Eclipse 插件运行时 ，MBG 可以自动合并 Java 文件。 MBG不会合并 Kotlin 文件，它可以覆盖现有文件或使用不同的唯一名称保存新生成的文件。如果您对生成的 Kotlin 文件进行更改并迭代运行 MBG，则必须手动合并更改。  依赖关系\nMBG 没有 JRE 之外的依赖项。需要 Java 8 或更高版本。此外，还需要一个实现 DatabaseMetaData 接口的 JDBC 驱动程序，尤其是getColumns和 getPrimaryKeys方法。\n mybatis-generator 的使用 创建数据库 创建 maven 工程 在 pom.xml 中添加依赖 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;org.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;MyBatis\u0026lt;/artifactId\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!--指定maven工程文件编码和要使用的jdk版本--\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;maven.compiler.source\u0026gt;1.8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;1.8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--mysql驱动--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.44\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mybatis的依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mybatis-generator插件--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.generator\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-generator-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Lombok插件--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.12\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;!--给出构建过程中用到的插件--\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;!-- mybatis-generator自动生成代码插件 --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.generator\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-generator-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.5\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!-- 输出详细信息 --\u0026gt; \u0026lt;verbose\u0026gt;true\u0026lt;/verbose\u0026gt; \u0026lt;!-- 覆盖生成文件 --\u0026gt; \u0026lt;overwrite\u0026gt;true\u0026lt;/overwrite\u0026gt; \u0026lt;!-- 定义配置文件 --\u0026gt; \u0026lt;configurationFile\u0026gt;src/main/resources/generatorConfig.xml\u0026lt;/configurationFile\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;!-- 使用 maven-compiler-plugin 插件可以指定项目源码的 jdk 版本，编译后的 jdk 版本，以及编码（可选） \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.8.0\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;source\u0026gt;1.8\u0026lt;/source\u0026gt; \u0026lt;target\u0026gt;1.8\u0026lt;/target\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; --\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 使用 java 代码运行（有自定义插件时使用）\npublic static void main(String[] args) throws Exception { // LogFactory.forceSlf4jLogging();  // System.setProperty(\u0026#34;user.name\u0026#34;, \u0026#34;zzs\u0026#34;);  // 这个集合记录着生成、合并、覆盖文件的信息  List\u0026lt;String\u0026gt; warnings = new ArrayList\u0026lt;String\u0026gt;(); InputStream in = MybatisGenerator.class.getClassLoader().getResourceAsStream(\u0026#34;generatorConfig.xml\u0026#34;); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(in); // 不覆盖 Java 文件  boolean overwrite = false; DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); // 生成文件  myBatisGenerator.generate(null); // 打印信息  warnings.forEach(System.err::println); } 或使用maven插件方式\n创建 generatorConfig.xml 配置文件 文件位于 resources 文件夹下\n简易配置\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE generatorConfiguration PUBLIC \u0026#34;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\u0026#34;\u0026gt; \u0026lt;!-- 配置生成器 --\u0026gt; \u0026lt;generatorConfiguration\u0026gt; \u0026lt;!-- 使用配置文件配置数据库连接 --\u0026gt; \u0026lt;properties resource=\u0026#34;db.properties\u0026#34;/\u0026gt; \u0026lt;context id=\u0026#34;mysql\u0026#34; defaultModelType=\u0026#34;flat\u0026#34; targetRuntime=\u0026#34;MyBatis3\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;autoDelimitKeywords\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;!-- 生成的Java文件的编码 --\u0026gt; \u0026lt;property name=\u0026#34;javaFileEncoding\u0026#34; value=\u0026#34;UTF-8\u0026#34;/\u0026gt; \u0026lt;!-- 格式化java代码 --\u0026gt; \u0026lt;property name=\u0026#34;javaFormatter\u0026#34; value=\u0026#34;org.mybatis.generator.api.dom.DefaultJavaFormatter\u0026#34;/\u0026gt; \u0026lt;!-- 格式化XML代码 --\u0026gt; \u0026lt;property name=\u0026#34;xmlFormatter\u0026#34; value=\u0026#34;org.mybatis.generator.api.dom.DefaultXmlFormatter\u0026#34;/\u0026gt; \u0026lt;!-- beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号； --\u0026gt; \u0026lt;property name=\u0026#34;beginningDelimiter\u0026#34; value=\u0026#34;`\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;endingDelimiter\u0026#34; value=\u0026#34;`\u0026#34;/\u0026gt; \u0026lt;!-- 生成 JavaBean 对象继承 Serializable 类 --\u0026gt; \u0026lt;plugin type=\u0026#34;org.mybatis.generator.plugins.SerializablePlugin\u0026#34;/\u0026gt; \u0026lt;!--通过type默认为（suppressDate）属性改成自己注解解析器--\u0026gt; \u0026lt;!-- \u0026lt;commentGenerator type=\u0026#34;com.xxgc.mybatis.plugin.commentPlugin\u0026#34;\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;property name=\u0026#34;suppressDate\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --\u0026gt; \u0026lt;!-- \u0026lt;property name=\u0026#34;suppressAllComments\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;property name=\u0026#34;addRemarkComments\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;/commentGenerator\u0026gt;--\u0026gt; \u0026lt;!-- 连接数据库--\u0026gt; \u0026lt;jdbcConnection driverClass=\u0026#34;${driver}\u0026#34; connectionURL=\u0026#34;${url}\u0026#34; userId=\u0026#34;${username}\u0026#34; password=\u0026#34;#{password}\u0026#34;\u0026gt; \u0026lt;/jdbcConnection\u0026gt; \u0026lt;!-- java类型处理器--\u0026gt; \u0026lt;javaTypeResolver type=\u0026#34;org.mybatis.generator.internal.types.JavaTypeResolverDefaultImpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;forceBigDecimals\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/javaTypeResolver\u0026gt; \u0026lt;!-- 实体类 文件生成位置 --\u0026gt; \u0026lt;javaModelGenerator targetPackage=\u0026#34;com.xxgc.mybatis.entity\u0026#34; targetProject=\u0026#34;src/main/java\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;constructorBased\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;enableSubPackages\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;trimStrings\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;immutable\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;trimStrings\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/javaModelGenerator\u0026gt; \u0026lt;!--mapping.xml文件生成位置--\u0026gt; \u0026lt;sqlMapGenerator targetPackage=\u0026#34;com.xxgc.mybatis.mapper\u0026#34; targetProject=\u0026#34;src/main/resources\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;enableSubPackages\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/sqlMapGenerator\u0026gt; \u0026lt;!--mapping文件生成位置--\u0026gt; \u0026lt;javaClientGenerator targetPackage=\u0026#34;com.xxgc.mybatis.mapper\u0026#34; type=\u0026#34;XMLMAPPER\u0026#34; targetProject=\u0026#34;src/main/java\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;enableSubPackages\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/javaClientGenerator\u0026gt; \u0026lt;!-- 要生成的表--\u0026gt; \u0026lt;table tableName=\u0026#34;user\u0026#34;/\u0026gt; \u0026lt;table tableName=\u0026#34;trade\u0026#34;/\u0026gt; \u0026lt;/context\u0026gt; \u0026lt;/generatorConfiguration\u0026gt; 配置文件详解\n?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE generatorConfiguration PUBLIC \u0026#34;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\u0026#34;\u0026gt; \u0026lt;!-- 配置生成器 --\u0026gt; \u0026lt;generatorConfiguration\u0026gt; \u0026lt;!-- 可以用于加载配置项或者配置文件，在整个配置文件中就可以使用${propertyKey}的方式来引用配置项 resource：配置资源加载地址，使用resource，MBG从classpath开始找，比如com/myproject/generatorConfig.properties url：配置资源加载地质，使用URL的方式，比如file:///C:/myfolder/generatorConfig.properties. 注意，两个属性只能选址一个; 另外，如果使用了mybatis-generator-maven-plugins，那么在pom.xml中定义的properties都可以直接在generatorConfig.xml中使用 \u0026lt;properties resource=\u0026#34;\u0026#34; url=\u0026#34;\u0026#34; /\u0026gt; --\u0026gt; \u0026lt;!-- 在MBG工作的时候，需要额外加载的依赖包 location属性指明加载jar/zip包的全路径 \u0026lt;classPathEntry location=\u0026#34;/Program Files/IBM/SQLLIB/java/db2java.zip\u0026#34; /\u0026gt; --\u0026gt; \u0026lt;!-- context:生成一组对象的环境 id:必选，上下文id，用于在生成错误时提示 defaultModelType:指定生成对象的样式 1，conditional：类似hierarchical；如果某张表只有一个字段，则不会生成改实体 2，flat：所有内容（主键，blob）等全部生成在一个对象中；常用 3，hierarchical：主键生成一个XXKey对象(key class)，Blob等单独生成一个对象，其他简单属性在一个对象中(record class) targetRuntime: 1，MyBatis3：默认的值，生成基于MyBatis3.x以上版本的内容，包括XXXBySample； 2，MyBatis3Simple：类似MyBatis3，只是不生成XXXBySmple； introspectedColumnImpl：类全限定名，用于扩展MBG --\u0026gt; \u0026lt;context id=\u0026#34;mysql\u0026#34; defaultModelType=\u0026#34;flat\u0026#34; targetRuntime=\u0026#34;MyBatis3\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;autoDelimitKeywords\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;!-- 生成的Java文件的编码 --\u0026gt; \u0026lt;property name=\u0026#34;javaFileEncoding\u0026#34; value=\u0026#34;UTF-8\u0026#34;/\u0026gt; \u0026lt;!-- 格式化java代码 --\u0026gt; \u0026lt;property name=\u0026#34;javaFormatter\u0026#34; value=\u0026#34;org.mybatis.generator.api.dom.DefaultJavaFormatter\u0026#34;/\u0026gt; \u0026lt;!-- 格式化XML代码 --\u0026gt; \u0026lt;property name=\u0026#34;xmlFormatter\u0026#34; value=\u0026#34;org.mybatis.generator.api.dom.DefaultXmlFormatter\u0026#34;/\u0026gt; \u0026lt;!-- beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号； --\u0026gt; \u0026lt;property name=\u0026#34;beginningDelimiter\u0026#34; value=\u0026#34;`\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;endingDelimiter\u0026#34; value=\u0026#34;`\u0026#34;/\u0026gt; \u0026lt;!-- 自定义lombok增强 --\u0026gt; \u0026lt;plugin type=\u0026#34;plugins.LombokPlugin\u0026#34; \u0026gt; \u0026lt;property name=\u0026#34;hasLombok\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;!--通过type属性改成自己注解解析器--\u0026gt; \u0026lt;commentGenerator type=\u0026#34;plugins.MyCommentGenerator\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;suppressDate\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --\u0026gt; \u0026lt;!--\u0026lt;property name=\u0026#34;suppressAllComments\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt;--\u0026gt; \u0026lt;property name=\u0026#34;addRemarkComments\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;/commentGenerator\u0026gt; \u0026lt;!-- 必须要有的，使用这个配置数据库连接的信息：驱动类、连接地址、用户名、密码 @TODO:是否可以扩展 --\u0026gt; \u0026lt;jdbcConnection driverClass=\u0026#34;com.mysql.jdbc.Driver\u0026#34; connectionURL=\u0026#34;jdbc:mysql://127.0.0.1:3306/mybatis?useUnicode=true\u0026amp;amp;characterEncoding=UTF-8\u0026#34; userId=\u0026#34;root\u0026#34; password=\u0026#34;123456\u0026#34;\u0026gt; \u0026lt;!-- 这里面可以设置property属性，每一个property属性都设置到配置的Driver上 --\u0026gt; \u0026lt;/jdbcConnection\u0026gt; \u0026lt;!-- java类型处理器 用于处理DB中的类型到Java中的类型，默认使用JavaTypeResolverDefaultImpl； 注意一点，默认会先尝试使用Integer，Long，Short等来对应DECIMAL和 NUMERIC数据类型； --\u0026gt; \u0026lt;javaTypeResolver type=\u0026#34;org.mybatis.generator.internal.types.JavaTypeResolverDefaultImpl\u0026#34;\u0026gt; \u0026lt;!-- true：使用BigDecimal对应DECIMAL和 NUMERIC数据类型 false：默认, scale\u0026gt;0;length\u0026gt;18：使用BigDecimal; scale=0;length[10,18]：使用Long； scale=0;length[5,9]：使用Integer； scale=0;length\u0026lt;5：使用Short； --\u0026gt; \u0026lt;property name=\u0026#34;forceBigDecimals\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/javaTypeResolver\u0026gt; \u0026lt;!-- java模型创建器，是必须要的元素 负责：1，key类（见context的defaultModelType）；2，java类；3，查询类 targetPackage：生成的类要放的包，真实的包受enableSubPackages属性控制； targetProject：目标项目，指定一个存在的目录下，生成的内容会放到指定目录中，如果目录不存在，MBG不会自动建目录 --\u0026gt; \u0026lt;javaModelGenerator targetPackage=\u0026#34;com.xxgc.mybatis.entity\u0026#34; targetProject=\u0026#34;src/main/java\u0026#34;\u0026gt; \u0026lt;!-- for MyBatis3/MyBatis3Simple 自动为每一个生成的类创建一个构造方法，构造方法包含了所有的field；而不是使用setter； --\u0026gt; \u0026lt;property name=\u0026#34;constructorBased\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --\u0026gt; \u0026lt;!-- enableSubPackages:是否让schema作为包的后缀 --\u0026gt; \u0026lt;property name=\u0026#34;enableSubPackages\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;!-- 从数据库返回的值被清理前后的空格 --\u0026gt; \u0026lt;property name=\u0026#34;trimStrings\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;!-- for MyBatis3 / MyBatis3Simple 是否创建一个不可变的类，如果为true， 那么MBG会创建一个没有setter方法的类，取而代之的是类似constructorBased的类 --\u0026gt; \u0026lt;property name=\u0026#34;immutable\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;!-- 设置一个根对象， 如果设置了这个根对象，那么生成的keyClass或者recordClass会继承这个类；在Table的rootClass属性中可以覆盖该选项 注意：如果在key class或者record class中有root class相同的属性，MBG就不会重新生成这些属性了，包括： 1，属性名相同，类型相同，有相同的getter/setter方法； --\u0026gt; \u0026lt;!--\u0026lt;property name=\u0026#34;rootClass\u0026#34; value=\u0026#34;com.intfish.mygenerator.entity.BaseDomain\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;!-- 设置是否在getter方法中，对String类型字段调用trim()方法 --\u0026gt; \u0026lt;property name=\u0026#34;trimStrings\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/javaModelGenerator\u0026gt; \u0026lt;!-- 生成SQL map的XML文件生成器， 注意，在Mybatis3之后，我们可以使用mapper.xml文件+Mapper接口（或者不用mapper接口）， 或者只使用Mapper接口+Annotation，所以，如果 javaClientGenerator配置中配置了需要生成XML的话，这个元素就必须配置 targetPackage/targetProject:同javaModelGenerator --\u0026gt; \u0026lt;sqlMapGenerator targetPackage=\u0026#34;mapper\u0026#34; targetProject=\u0026#34;src/main/resources\u0026#34;\u0026gt; \u0026lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --\u0026gt; \u0026lt;property name=\u0026#34;enableSubPackages\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/sqlMapGenerator\u0026gt; \u0026lt;!-- 对于mybatis来说，即生成Mapper接口，注意，如果没有配置该元素，那么默认不会生成Mapper接口 targetPackage/targetProject:同javaModelGenerator type：选择怎么生成mapper接口（在MyBatis3/MyBatis3Simple下）： 1，ANNOTATEDMAPPER：会生成使用Mapper接口+Annotation的方式创建（SQL生成在annotation中），不会生成对应的XML； 2，MIXEDMAPPER：使用混合配置，会生成Mapper接口，并适当添加合适的Annotation，但是XML会生成在XML中； 3，XMLMAPPER：会生成Mapper接口，接口完全依赖XML； 注意，如果context是MyBatis3Simple：只支持ANNOTATEDMAPPER和XMLMAPPER --\u0026gt; \u0026lt;javaClientGenerator targetPackage=\u0026#34;com.intfish.mygenerator.dao\u0026#34; type=\u0026#34;XMLMAPPER\u0026#34; targetProject=\u0026#34;src/main/java\u0026#34;\u0026gt; \u0026lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --\u0026gt; \u0026lt;property name=\u0026#34;enableSubPackages\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;!-- 可以为所有生成的接口添加一个父接口，但是MBG只负责生成，不负责检查 \u0026lt;property name=\u0026#34;rootInterface\u0026#34; value=\u0026#34;\u0026#34;/\u0026gt; --\u0026gt; \u0026lt;/javaClientGenerator\u0026gt; \u0026lt;!-- 选择一个table来生成相关文件，可以有一个或多个table，必须要有table元素 选择的table会生成一下文件： 1，SQL map文件 2，生成一个主键类； 3，除了BLOB和主键的其他字段的类； 4，包含BLOB的类； 5，一个用户生成动态查询的条件类（selectByExample, deleteByExample），可选； 6，Mapper接口（可选） tableName（必要）：要生成对象的表名； 注意：大小写敏感问题。正常情况下，MBG会自动的去识别数据库标识符的大小写敏感度，在一般情况下，MBG会 根据设置的schema，catalog或tablename去查询数据表，按照下面的流程： 1，如果schema，catalog或tablename中有空格，那么设置的是什么格式，就精确的使用指定的大小写格式去查询； 2，否则，如果数据库的标识符使用大写的，那么MBG自动把表名变成大写再查找； 3，否则，如果数据库的标识符使用小写的，那么MBG自动把表名变成小写再查找； 4，否则，使用指定的大小写格式查询； 另外的，如果在创建表的时候，使用的\u0026#34;\u0026#34;把数据库对象规定大小写，就算数据库标识符是使用的大写，在这种情况下也会使用给定的大小写来创建表名； 这个时候，请设置delimitIdentifiers=\u0026#34;true\u0026#34;即可保留大小写格式； 可选： 1，schema：数据库的schema； 2，catalog：数据库的catalog； 3，alias：为数据表设置的别名，如果设置了alias，那么生成的所有的SELECT SQL语句中，列名会变成：alias_actualColumnName 4，domainObjectName：生成的domain类的名字，如果不设置，直接使用表名作为domain类的名字；可以设置为somepck.domainName， 那么会自动把domainName类再放到somepck包里面； 5，enableInsert（默认true）：指定是否生成insert语句； 6，enableSelectByPrimaryKey（默认true）：指定是否生成按照主键查询对象的语句（就是getById或get）； 7，enableSelectByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询语句； 8，enableUpdateByPrimaryKey（默认true）：指定是否生成按照主键修改对象的语句（即update)； 9，enableDeleteByPrimaryKey（默认true）：指定是否生成按照主键删除对象的语句（即delete）； 10，enableDeleteByExample（默认true）：MyBatis3Simple为false，指定是否生成动态删除语句； 11，enableCountByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询总条数语句（用于分页的总条数查询）； 12，enableUpdateByExample（默认true）：MyBatis3Simple为false，指定是否生成动态修改语句（只修改对象中不为空的属性）； 13，modelType：参考context元素的defaultModelType，相当于覆盖； 14，delimitIdentifiers：参考tableName的解释，注意，默认的delimitIdentifiers是双引号，如果类似MYSQL这样的数据库， 使用的是`（反引号，那么还需要设置context的beginningDelimiter和endingDelimiter属性） 15，delimitAllColumns：设置是否所有生成的SQL中的列名都使用标识符引起来。默认为false，delimitIdentifiers参考context的属性 注意，table里面很多参数都是对javaModelGenerator，context等元素的默认属性的一个复写； --\u0026gt; \u0026lt;table tableName=\u0026#34;user\u0026#34; \u0026gt; \u0026lt;!-- 参考 javaModelGenerator 的 constructorBased属性--\u0026gt; \u0026lt;property name=\u0026#34;constructorBased\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;!-- 默认为false，如果设置为true，在生成的SQL中，table名字不会加上catalog或schema； --\u0026gt; \u0026lt;property name=\u0026#34;ignoreQualifiersAtRuntime\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;!-- 参考 javaModelGenerator 的 immutable 属性 --\u0026gt; \u0026lt;property name=\u0026#34;immutable\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;!-- 指定是否只生成domain类，如果设置为true，只生成domain类，如果还配置了sqlMapGenerator，那么在mapper XML文件中，只生成resultMap元素 --\u0026gt; \u0026lt;property name=\u0026#34;modelOnly\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;!-- 参考 javaModelGenerator 的 rootClass 属性 \u0026lt;property name=\u0026#34;rootClass\u0026#34; value=\u0026#34;\u0026#34;/\u0026gt; --\u0026gt; \u0026lt;!-- 参考javaClientGenerator 的 rootInterface 属性 \u0026lt;property name=\u0026#34;rootInterface\u0026#34; value=\u0026#34;\u0026#34;/\u0026gt; --\u0026gt; \u0026lt;!-- 如果设置了runtimeCatalog，那么在生成的SQL中，使用该指定的catalog，而不是table元素上的catalog \u0026lt;property name=\u0026#34;runtimeCatalog\u0026#34; value=\u0026#34;\u0026#34;/\u0026gt; --\u0026gt; \u0026lt;!-- 如果设置了runtimeSchema，那么在生成的SQL中，使用该指定的schema，而不是table元素上的schema \u0026lt;property name=\u0026#34;runtimeSchema\u0026#34; value=\u0026#34;\u0026#34;/\u0026gt; --\u0026gt; \u0026lt;!-- 如果设置了runtimeTableName，那么在生成的SQL中，使用该指定的tablename，而不是table元素上的tablename \u0026lt;property name=\u0026#34;runtimeTableName\u0026#34; value=\u0026#34;\u0026#34;/\u0026gt; --\u0026gt; \u0026lt;!-- 注意，该属性只针对MyBatis3Simple有用； 如果选择的runtime是MyBatis3Simple，那么会生成一个SelectAll方法，如果指定了selectAllOrderByClause，那么会在该SQL中添加指定的这个order条件； --\u0026gt; \u0026lt;property name=\u0026#34;selectAllOrderByClause\u0026#34; value=\u0026#34;id desc,name asc\u0026#34;/\u0026gt; \u0026lt;!-- 如果设置为true，生成的model类会直接使用column本身的名字，而不会再使用驼峰命名方法，比如BORN_DATE，生成的属性名字就是BORN_DATE,而不会是bornDate --\u0026gt; \u0026lt;property name=\u0026#34;useActualColumnNames\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;!-- generatedKey用于生成生成主键的方法， 如果设置了该元素，MBG会在生成的\u0026lt;insert\u0026gt;元素中生成一条正确的\u0026lt;selectKey\u0026gt;元素，该元素可选 column:主键的列名； sqlStatement：要生成的selectKey语句，有以下可选项： Cloudscape:相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL() DB2 :相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL() DB2_MF :相当于selectKey的SQL为：SELECT IDENTITY_VAL_LOCAL() FROM SYSIBM.SYSDUMMY1 Derby :相当于selectKey的SQL为：VALUES IDENTITY_VAL_LOCAL() HSQLDB :相当于selectKey的SQL为：CALL IDENTITY() Informix :相当于selectKey的SQL为：select dbinfo(\u0026#39;sqlca.sqlerrd1\u0026#39;) from systables where tabid=1 MySql :相当于selectKey的SQL为：SELECT LAST_INSERT_ID() SqlServer :相当于selectKey的SQL为：SELECT SCOPE_IDENTITY() SYBASE :相当于selectKey的SQL为：SELECT @@IDENTITY JDBC :相当于在生成的insert元素上添加useGeneratedKeys=\u0026#34;true\u0026#34;和keyProperty属性 \u0026lt;generatedKey column=\u0026#34;\u0026#34; sqlStatement=\u0026#34;\u0026#34;/\u0026gt; --\u0026gt; \u0026lt;!-- 该元素会在根据表中列名计算对象属性名之前先重命名列名，非常适合用于表中的列都有公用的前缀字符串的时候， 比如列名为：CUST_ID,CUST_NAME,CUST_EMAIL,CUST_ADDRESS等； 那么就可以设置searchString为\u0026#34;^CUST_\u0026#34;，并使用空白替换，那么生成的Customer对象中的属性名称就不是 custId,custName等，而是先被替换为ID,NAME,EMAIL,然后变成属性：id，name，email； 注意，MBG是使用java.util.regex.Matcher.replaceAll来替换searchString和replaceString的， 如果使用了columnOverride元素，该属性无效； \u0026lt;columnRenamingRule searchString=\u0026#34;\u0026#34; replaceString=\u0026#34;\u0026#34;/\u0026gt; --\u0026gt; \u0026lt;!-- 用来修改表中某个列的属性，MBG会使用修改后的列来生成domain的属性； column:要重新设置的列名； 注意，一个table元素中可以有多个columnOverride元素哈~ --\u0026gt; \u0026lt;columnOverride column=\u0026#34;name\u0026#34;\u0026gt; \u0026lt;!-- 使用property属性来指定列要生成的属性名称 --\u0026gt; \u0026lt;property name=\u0026#34;property\u0026#34; value=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;!-- javaType用于指定生成的domain的属性类型，使用类型的全限定名 \u0026lt;property name=\u0026#34;javaType\u0026#34; value=\u0026#34;\u0026#34;/\u0026gt; --\u0026gt; \u0026lt;!-- jdbcType用于指定该列的JDBC类型 \u0026lt;property name=\u0026#34;jdbcType\u0026#34; value=\u0026#34;\u0026#34;/\u0026gt; --\u0026gt; \u0026lt;!-- typeHandler 用于指定该列使用到的TypeHandler，如果要指定，配置类型处理器的全限定名 注意，mybatis中，不会生成到mybatis-config.xml中的typeHandler 只会生成类似：where id = #{id,jdbcType=BIGINT,typeHandler=com._520it.mybatis.MyTypeHandler}的参数描述 \u0026lt;property name=\u0026#34;jdbcType\u0026#34; value=\u0026#34;\u0026#34;/\u0026gt; --\u0026gt; \u0026lt;!-- 参考table元素的delimitAllColumns配置，默认为false \u0026lt;property name=\u0026#34;delimitedColumnName\u0026#34; value=\u0026#34;\u0026#34;/\u0026gt; --\u0026gt; \u0026lt;/columnOverride\u0026gt; \u0026lt;!-- ignoreColumn设置一个MGB忽略的列，如果设置了改列，那么在生成的domain中，生成的SQL中，都不会有该列出现 column:指定要忽略的列的名字； delimitedColumnName：参考table元素的delimitAllColumns配置，默认为false 注意，一个table元素中可以有多个ignoreColumn元素 \u0026lt;ignoreColumn column=\u0026#34;deptId\u0026#34; delimitedColumnName=\u0026#34;\u0026#34;/\u0026gt; --\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/context\u0026gt; \u0026lt;/generatorConfiguration\u0026gt; context targetRuntime 选择  MyBatis Generator (MBG) 根据配置方式生成不同风格的代码。这是通过在\u0026lt;context\u0026gt;配置元素上指定targetRuntime属性来控制的。\n目标运行时信息和示例    目标运行时 注释     MyBatis3DynamicSql 这是默认值生成 Java 代码不生成 XML - MyBatis3 注解被独占使用生成的模型对象是“扁平的”——没有单独的主键对象生成的代码依赖于 MyBatis 动态 SQL 库生成的代码量比较少生成的代码为查询构造提供了极大的灵活性   MyBatis3Kotlin 生成 Kotlin 代码不生成 XML - MyBatis3 注解被独占使用生成的模型对象是“扁平的”——没有单独的主键对象生成的代码依赖于 MyBatis 动态 SQL 库生成的代码量比较少生成的代码为查询构造提供了极大的灵活性   MyBatis3 这是原始运行时。在 MBG 1.3.6 版本之前，MBG 的大多数用法都使用这种风格的代码。生成 Java 代码生成兼容 MyBatis3 的 XML 和 SQL 或兼容 MyBatis3 的带注释的接口，没有 XML生成的模型对象可能具有具有单独主键对象和/或带有 BLOB 字段的单独对象的层次结构生成的代码没有外部依赖生成的代码量非常大生成的代码构建查询能力有限，难以扩展   MyBatis3Simple 这是 MyBatis3 运行时的简化版本。生成 Java 代码生成兼容 MyBatis3 的 XML 和 SQL 或兼容 MyBatis3 的带注释的接口，没有 XML生成的模型对象是“扁平的”——没有单独的主键对象生成的代码没有外部依赖生成的代码量比较少不会生成“示例”或“选择性”方法生成的代码不包含动态查询构建的方法，难以扩展    MyBatis3DynamicSql 的示例配置(参考) \u0026lt;!DOCTYPE generatorConfiguration PUBLIC \u0026quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\u0026quot; \u0026quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\u0026quot;\u0026gt; \u0026lt;generatorConfiguration\u0026gt; \u0026lt;context id= \u0026quot;dsql\u0026quot; targetRuntime=\u0026quot;MyBatis3DynamicSql\u0026quot;\u0026gt; \u0026lt;jdbcConnection driverClass=\u0026quot;org.hsqldb.jdbcDriver\u0026quot; connectionURL=\u0026quot;jdbc:hsqldb:mem:aname\u0026quot; /\u0026gt; \u0026lt;javaModelGenerator targetPackage=\u0026quot;example.model\u0026quot; targetProject=\u0026quot;src/main/java \u0026quot;/\u0026gt; \u0026lt;javaClientGenerator targetPackage=\u0026quot;example.mapper\u0026quot; targetProject=\u0026quot;src/main/java\u0026quot;/\u0026gt; \u0026lt;table tableName=\u0026quot;FooTable\u0026quot; /\u0026gt; \u0026lt;/context\u0026gt; \u0026lt;/generatorConfiguration\u0026gt; MyBatis3Kotlin 的示例配置 \u0026lt;!DOCTYPE generatorConfiguration PUBLIC \u0026quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\u0026quot; \u0026quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\u0026quot;\u0026gt; \u0026lt;generatorConfiguration\u0026gt; \u0026lt;context id= \u0026quot;kotlin\u0026quot; targetRuntime=\u0026quot;MyBatis3Kotlin\u0026quot;\u0026gt; \u0026lt;jdbcConnection driverClass=\u0026quot;org.hsqldb.jdbcDriver\u0026quot; connectionURL=\u0026quot;jdbc:hsqldb:mem:aname\u0026quot; /\u0026gt; \u0026lt;javaModelGenerator targetPackage=\u0026quot;example.model\u0026quot; targetProject=\u0026quot;src/main/kotlin \u0026quot;/\u0026gt; \u0026lt;javaClientGenerator targetPackage=\u0026quot;example.mapper\u0026quot; targetProject=\u0026quot;src/main/kotlin\u0026quot;/\u0026gt; \u0026lt;table tableName=\u0026quot;FooTable\u0026quot; /\u0026gt; \u0026lt;/context\u0026gt; \u0026lt;/generatorConfiguration\u0026gt; MyBatis3 的示例配置 \u0026lt;!DOCTYPE generatorConfiguration PUBLIC \u0026quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\u0026quot; \u0026quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\u0026quot;\u0026gt; \u0026lt;generatorConfiguration\u0026gt; \u0026lt;context id= \u0026quot;simple\u0026quot; targetRuntime=\u0026quot;MyBatis3Simple\u0026quot;\u0026gt; \u0026lt;jdbcConnection driverClass=\u0026quot;org.hsqldb.jdbcDriver\u0026quot; connectionURL=\u0026quot;jdbc:hsqldb:mem:aname\u0026quot; /\u0026gt; \u0026lt;javaModelGenerator targetPackage=\u0026quot;example.model\u0026quot; targetProject=\u0026quot;src/main/java \u0026quot;/\u0026gt; \u0026lt;sqlMapGenerator targetPackage=\u0026quot;example.mapper\u0026quot; targetProject=\u0026quot;src/main/resources\u0026quot;/\u0026gt; \u0026lt;javaClientGenerator type=\u0026quot;XMLMAPPER\u0026quot; targetPackage=\u0026quot;example.mapper\u0026quot;targetProject=\u0026quot;src/main/java\u0026quot;/\u0026gt; \u0026lt;table tableName=\u0026quot;FooTable\u0026quot; /\u0026gt; \u0026lt;/context\u0026gt; \u0026lt;/generatorConfiguration\u0026gt; MyBatis3Simple 的示例配置 \u0026lt;!DOCTYPE generatorConfiguration PUBLIC \u0026quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\u0026quot; \u0026quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\u0026quot;\u0026gt; \u0026lt;generatorConfiguration\u0026gt; \u0026lt;context id= \u0026quot;simple\u0026quot; targetRuntime=\u0026quot;MyBatis3Simple\u0026quot;\u0026gt; \u0026lt;jdbcConnection driverClass=\u0026quot;org.hsqldb.jdbcDriver\u0026quot; connectionURL=\u0026quot;jdbc:hsqldb:mem:aname\u0026quot; /\u0026gt; \u0026lt;javaModelGenerator targetPackage=\u0026quot;example.model\u0026quot; targetProject=\u0026quot;src/main/java \u0026quot;/\u0026gt; \u0026lt;javaClientGenerator type=\u0026quot;ANNOTATEDMAPPER\u0026quot; targetPackage=\u0026quot;example.mapper\u0026quot; targetProject=\u0026quot;src/main/java\u0026quot;/\u0026gt; \u0026lt;table tableName=\u0026quot;FooTable\u0026quot; /\u0026gt; \u0026lt;/context\u0026gt; \u0026lt;/generatorConfiguration\u0026gt;  插件 MBG自带插件\n 提供的插件\n随着 MyBatis Generator (MBG) 使用量的增长，我们发现通过插件添加功能越来越有用，而不是增加基础代码生成器的复杂性。插件是用于扩展 MBG 的模块化且易于理解的机制。有关编写插件的更多信息，请参阅 实现插件。有关配置插件的信息，请参阅\n大多数提供的插件都在包 org.mybatis.generator.plugins 中。提供的插件展示了可以使用 MBG 插件完成的不同类型的任务。插件的源代码可通过 MBG 下载获得，也可以在此处在线 查看。\norg.mybatis.generator.plugins.CachePlugin\n当使用的目标运行时不生成 XML 时，此插件没有影响。\n这个插件向生成的 SQL 映射添加了一个 元素。此插件仅适用于 MyBatis3 目标运行时。\n此插件接受以下属性。所有都是可选的，如果指定，这些值将直接传递给生成的 元素上的相应属性。\n 缓存驱逐 cache_flushInterval 缓存只读 缓存大小 缓存类型  通过在 元素上指定属性，可以覆盖任何属性。\norg.mybatis.generator.plugins.CaseInsensitiveLikePlugin\n当使用的目标运行时基于 MyBatis 动态 SQL 时，此插件没有影响。\n该插件向 Example 类（实际上是 Criteria 内部类）添加方法以支持不区分大小写的 LIKE 搜索。这演示了通过插件向示例类添加功能，而不是扩展类。\norg.mybatis.generator.plugins.EqualsHashCodePlugin\n当使用的目标运行时是 MyBatis3Kotlin 时，这个插件没有影响，不需要。\n该插件为 MBG 生成的 Java 模型对象添加了equals和hashCode方法。\n默认情况下，equals和hashCode方法会检查它所知道的由此类生成的唯一字段。\n这个插件接受一个属性：\n useEqualsHashCodeFromRoot (optional) 如果你已经指定了根类，你可以使用这个属性来调用super equals和hashCode方法来检查根类的字段。它对于具有继承关系的表很有用。  org.mybatis.generator.plugins.FluentBuilderMethodsPlugin\n当使用的目标运行时是 MyBatis3Kotlin 时，这个插件没有影响，不需要。\n这个插件向生成的模型类添加了流畅的构建器方法。\n例子：\n 给定域类MyDomainClass 使用 setter 方法setFoo(String foo) 使用 setter 方法setBar(Integer bar)  该插件将创建额外的方法：\n 公共 MyDomainClass withFoo(String foo) public MyDomainClass withBar(Integer bar)  此插件不接受任何属性。\n使用此插件，您可以使用链式方法调用流畅地配置属性值。示例：new MyDomain().withFoo(\u0026quot;Test\u0026quot;).withBar(4711);\norg.mybatis.generator.plugins.MapperAnnotationPlugin\n当使用的目标运行时基于 MyBatis 动态 SQL 时，该插件没有影响，不需要。\n此插件将@Mapper注释添加到生成的映射器接口。这个插件应该只在 MyBatis3 环境中使用。\norg.mybatis.generator.plugins.MapperConfigPlugin\n当使用的目标运行时基于 MyBatis 动态 SQL 时，该插件没有影响，不需要。\n此插件生成一个框架 MapperConfig.xml 文件，其中包含对 MBG 生成的 XML 映射器文件的引用。该文件可用于配置 MyBatis 3.x 环境。\n这个插件接受三个属性：\n fileName（可选）生成的文件的名称。如果未指定，则默认为“MapperConfig.xml”。 targetPackage（必需）文件应放置的包的名称。指定为“com.mycompany.sql”。 targetProject（必需）应放置文件的项目的名称。  注意：targetPackage和targetProject遵循与 sqlMapGenerator 配置元素上的targetPackage和targetProject值相同的规则。\norg.mybatis.generator.plugins.RenameExampleClassPlugin\n当使用的目标运行时基于 MyBatis 动态 SQL 时，该插件没有影响，不需要。\n该插件通过重命名由 MBG 生成的示例类来演示初始化方法的用法。\n这个插件接受两个属性：\n searchString（必需）用于搜索示例类的默认生成名称的正则表达式。 replaceString（必需）要插入到searchString匹配项上的 字符串。  例如，为了从xxxExample重命名所生成的示例类xxxCriteria，指定实施例$用于搜索字符串 和标准为replaceString\norg.mybatis.generator.plugins.RowBoundsPlugin\n当使用的目标运行时基于 MyBatis 动态 SQL 时，该插件没有影响，不需要。\n这个插件将添加一个新版本的selectByExample 方法，它接受一个RowBounds参数。这支持 MyBatis RowBounds 函数，该函数可以限制返回结果列表的长度，并且可以指定开始位置。这在分页应用程序中很有用。\n该插件仅对 MyBatis3 目标运行时有效。\norg.mybatis.generator.plugins.SerializablePlugin\n当使用的目标运行时是 MyBatis3Kotlin 时，这个插件没有影响，不需要。\n该插件将标记接口java.io.Serializable添加到 MBG 生成的 Java 模型对象中。该插件还将serialVersionUID字段添加 到模型类中。\n重要提示：这是 java.io.Serializable 的简单实现，不会尝试对类进行任何版本控制。\n这个插件接受两个属性：\n addGWTInterface（可选）真/假。如果为 true，则插件会将 Google Web Toolkit (GWT) IsSerializable接口添加到模型对象。默认值为假。 抑制JavaInterface（必需）真/假。如果为 true，插件将不会添加java.io.Serializable接口。这是针对 GWT 对象应该可序列化的情况，但不是严格的 Java 意义上的。默认值为假。  org.mybatis.generator.plugins.ToStringPlugin\n当使用的目标运行时是 MyBatis3Kotlin 时，这个插件没有影响，不需要。\n该插件将toString()方法添加到生成的模型类中。\n这个插件接受一个属性：\n useToStringFromRoot (可选) 如果您指定了根类，您可以使用该属性调用超级toString方法打印根类的字段。它对于具有继承关系的表很有用。  org.mybatis.generator.plugins.UnmergeableXmlMappersPlugin\n当使用的目标运行时基于 MyBatis 动态 SQL 时，该插件没有影响，不需要。\n此插件将禁用生成的映射器 XML 文件的 XML 合并功能。这将导致生成器以与 Java 文件相同的方式尊重 XML 文件的覆盖标志 - 如果覆盖为真，则现有文件将被覆盖，否则将使用唯一名称写入新文件。\n如果您禁用所有评论，此插件会很有帮助。\norg.mybatis.generator.plugins.VirtualPrimaryKeyPlugin\n此插件可用于指定充当主键的列，即使它们未在数据库中定义为主键。这在数据库表没有主定义的情况下很有用。通常，如果没有主键，MBG 将生成非常有限的方法集。该插件可用于生成完整的 MBG 方法。\n要使用该插件，请将属性“virtualKeyColumns”添加到您的 配置中，并将值设置为逗号或空格分隔的列名列表，这些列名应该被视为主键。列名必须与从数据库返回的列名完全匹配（通常全部为大写）。例如：\n\u0026lt;table tableName=\u0026#34;foo\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;virtualKeyColumns\u0026#34; value=\u0026#34;ID1, ID2\u0026#34; /\u0026gt; \u0026lt;/table\u0026gt;  自定义插件\n 实现插件 插件可用于修改或添加由 MyBatis Generator 生成的对象。插件必须实现接口 org.mybatis.generator.api.Plugin。插件接口包含许多在代码生成过程的不同阶段调用的方法。任何特定插件通常不需要实现整个接口。因此，大多数插件应该扩展适配器类org.mybatis.generator.api.PluginAdapter。适配器类提供了基本的插件支持，并为大多数接口方法（类似于 Swing 适配器类）实现了无操作方法。\nMyBatis Generator 提供了几个插件（都在包 org.mybatis.generator.plugins 中）。提供的插件展示了可以使用插件完成的不同类型的任务。插件的源代码可通过下载获得，也可以在此处在线 查看。\n插件生命周期 插件有生命周期。插件是在代码生成过程的初始化期间创建的，并在过程的不同阶段按顺序调用。以下列表显示了插件的基本生命周期：\n  通过默认构造函数创建的插件\n  ``调用了setContext方法\n  ``调用了setProperties方法\n  ``调用的验证方法。如果此方法返回false，则不会调用插件中的其他方法\n  对于配置中的每个表：\n  ``调用的初始化方法\n  Java 客户端方法：\n1,2\n clientXXXMethodGenerated(Method, TopLevelClass, IntrospectedTable) - 在生成 Java 客户端实现类的每个方法时调用这些方法。 clientXXXMethodGenerated(Method, Interface, IntrospectedTable) - 在生成 Java 客户端接口的每个方法时调用这些方法。 调用了 clientGenerated(Interface, TopLevelClass, IntrospectedTable)方法    模型方法：\n1\n modelFieldGenerated , modelGetterMethodGenerated , modelSetterMethodGenerated用于类中的每个字段 modelExampleClassGenerated(TopLevelClass, IntrospectedTable) modelPrimaryKeyClassGenerated(TopLevelClass, IntrospectedTable) modelBaseRecordClassGenerated(TopLevelClass, IntrospectedTable) modelRecordWithBLOBsClassGenerated(TopLevelClass, IntrospectedTable)    SQL 映射方法：\n1\n sqlMapXXXElementGenerated(XmlElement, IntrospectedTable) - 在生成 SQL 映射的每个元素时调用这些方法 sqlMapDocumentGenerated(Document, IntrospectedTable) sqlMapDocument(GeneratedXmlFile, IntrospectedTable)    调用了 contextGenerateAdditionalJavaFiles(IntrospectedTable)方法\n  调用了 contextGenerateAdditionalXmlFiles(IntrospectedTable)方法\n    调用了 contextGenerateAdditionalJavaFiles()方法\n  调用了 contextGenerateAdditionalXmlFiles()方法\n  注意： 1 - 这些方法将由打包的代码生成器调用。如果您提供自定义代码生成器，则只有在自定义代码生成器调用这些方法时才会调用它们。 2 - 只有在配置了 Java 客户端生成器时才会调用 Java 客户端方法。\n编码插件 实现插件的最佳方法是扩展 org.mybatis.generator.api.PluginAdapter类并仅覆盖插件中您需要的特定方法。\n插件接口中的方法可用于修改默认生成的代码，或添加额外的生成代码。可以用插件完成的事情的例子是：\n 向生成的方法添加自定义注释 向生成的类添加其他方法 向生成的 XML 文件添加其他元素 生成额外的 Java 文件 生成额外的 XML 文件  该contextXXX方法将总是被调用。其他方法由打包的代码生成器调用 - 并且仅当表的规则会导致特定元素的生成时。例如， 如果表没有主键，则不会调用modelPrimaryKeyClassGenerated(TopLevelClass, IntrospectedTable)方法。\n返回布尔值的方法可用于绕过代码生成。如果这些方法中的任何一个返回false，则不会将相关项添加到生成的代码中。如果配置了多个插件，那么第一个从方法返回 false 的插件将导致 MyBatis Generator 停止在所有其他插件中调用该方法。\n 实现自定义插件 自定义lombokPlugin插件 生成实体类时添加作者，创建时间，并使用lombok注解简化bean。\npackage com.xxgc.mybatis.plugin; import org.mybatis.generator.api.IntrospectedColumn; import org.mybatis.generator.api.IntrospectedTable; import org.mybatis.generator.api.PluginAdapter; import org.mybatis.generator.api.dom.java.FullyQualifiedJavaType; import org.mybatis.generator.api.dom.java.Interface; import org.mybatis.generator.api.dom.java.Method; import org.mybatis.generator.api.dom.java.TopLevelClass; import java.text.SimpleDateFormat; import java.util.Date; import java.util.List; public class LombokPlugin extends PluginAdapter { @Override public boolean validate(List\u0026lt;String\u0026gt; list) { return true; } @Override public boolean modelBaseRecordClassGenerated(TopLevelClass topLevelClass, IntrospectedTable introspectedTable) { //实体类的import  topLevelClass.addImportedType(\u0026#34;java.io.Serializable\u0026#34;); topLevelClass.addImportedType(\u0026#34;lombok.Data\u0026#34;); topLevelClass.addImportedType(\u0026#34;lombok.Builder\u0026#34;); topLevelClass.addImportedType(\u0026#34;lombok.NoArgsConstructor\u0026#34;); topLevelClass.addImportedType(\u0026#34;lombok.AllArgsConstructor\u0026#34;); //实体类的注解  topLevelClass.addAnnotation(\u0026#34;@Data\u0026#34;); topLevelClass.addAnnotation(\u0026#34;@Builder\u0026#34;); topLevelClass.addAnnotation(\u0026#34;@NoArgsConstructor\u0026#34;); topLevelClass.addAnnotation(\u0026#34;@AllArgsConstructor\u0026#34;); //实体类的注释(添加作者和文件生成时间)  topLevelClass.addJavaDocLine(\u0026#34;/**\u0026#34;); topLevelClass.addJavaDocLine(\u0026#34; * @ybakiame\u0026#34;); topLevelClass.addJavaDocLine(\u0026#34; * @date \u0026#34; + new SimpleDateFormat(\u0026#34;yyyy/MM/dd/hh:mm\u0026#34;).format(new Date())); topLevelClass.addJavaDocLine(\u0026#34; */\u0026#34;); //接口  topLevelClass.addSuperInterface(new FullyQualifiedJavaType(\u0026#34;java.io.Serializable\u0026#34;)); return true; } @Override public boolean clientGenerated(Interface anInterface, TopLevelClass topLevelClass, IntrospectedTable introspectedTable) { //Mapper文件的注释  anInterface.addJavaDocLine(\u0026#34;/**\u0026#34;); anInterface.addJavaDocLine(\u0026#34; * @ybakiame\u0026#34;); anInterface.addJavaDocLine(\u0026#34; * @date \u0026#34; + new SimpleDateFormat(\u0026#34;yyyy/MM/dd/hh:mm\u0026#34;).format(new Date())); anInterface.addJavaDocLine(\u0026#34; */\u0026#34;); return true; } @Override public boolean modelSetterMethodGenerated(Method method, TopLevelClass topLevelClass, IntrospectedColumn introspectedColumn, IntrospectedTable introspectedTable, ModelClassType modelClassType) { //不生成getter  return false; } @Override public boolean modelGetterMethodGenerated(Method method, TopLevelClass topLevelClass, IntrospectedColumn introspectedColumn, IntrospectedTable introspectedTable, ModelClassType modelClassType) { //不生成setter  return false; } } 自定义 CommentGenerator 插件 将MyBatis Generator生成的英文注释替换为中文注释\npackage com.xxgc.mybatis.plugin; import static org.mybatis.generator.internal.util.StringUtility.isTrue; import java.text.SimpleDateFormat; import java.util.Date; import java.util.Properties; import org.mybatis.generator.api.CommentGenerator; import org.mybatis.generator.api.IntrospectedColumn; import org.mybatis.generator.api.IntrospectedTable; import org.mybatis.generator.api.dom.java.CompilationUnit; import org.mybatis.generator.api.dom.java.Field; import org.mybatis.generator.api.dom.java.InnerClass; import org.mybatis.generator.api.dom.java.InnerEnum; import org.mybatis.generator.api.dom.java.JavaElement; import org.mybatis.generator.api.dom.java.Method; import org.mybatis.generator.api.dom.java.TopLevelClass; import org.mybatis.generator.api.dom.xml.TextElement; import org.mybatis.generator.api.dom.xml.XmlElement; import org.mybatis.generator.api.dom.java.Parameter; import org.mybatis.generator.config.MergeConstants; import org.mybatis.generator.config.PropertyRegistry; public class MyCommentGenerator implements CommentGenerator{ /** * properties配置文件 */ private Properties properties; /** * properties配置文件 */ private Properties systemPro; /* * 父类时间 */ private boolean suppressDate; /** * 父类所有注释 */ private boolean suppressAllComments; /** * 当前时间 */ private String currentDateStr; public MyCommentGenerator() { super(); properties = new Properties(); systemPro = System.getProperties(); suppressDate = false; suppressAllComments = false; currentDateStr = (new SimpleDateFormat(\u0026#34;yyyy-MM-dd\u0026#34;)).format(new Date()); } /** * Java类的类注释 */ @Override public void addClassComment(InnerClass innerClass, IntrospectedTable introspectedTable) { if (suppressAllComments) { return; } StringBuilder sb = new StringBuilder(); innerClass.addJavaDocLine(\u0026#34;/**\u0026#34;); sb.append(\u0026#34; * \u0026#34;); sb.append(introspectedTable.getFullyQualifiedTable()); sb.append(\u0026#34; \u0026#34;); sb.append(getDateString()); innerClass.addJavaDocLine(sb.toString().replace(\u0026#34;\\n\u0026#34;, \u0026#34; \u0026#34;)); innerClass.addJavaDocLine(\u0026#34; */\u0026#34;); } /** * 为类添加注释 */ @Override public void addClassComment(InnerClass innerClass, IntrospectedTable introspectedTable, boolean markAsDoNotDelete) { if (suppressAllComments) { return; } StringBuilder sb = new StringBuilder(); innerClass.addJavaDocLine(\u0026#34;/**\u0026#34;); sb.append(\u0026#34; * \u0026#34;); sb.append(\u0026#34; * \u0026#34;); sb.append(introspectedTable.getFullyQualifiedTable()); innerClass.addJavaDocLine(sb.toString().replace(\u0026#34;\\n\u0026#34;, \u0026#34; \u0026#34;)); sb.setLength(0); sb.append(\u0026#34; * @author \u0026#34;); sb.append(systemPro.getProperty(\u0026#34;user.name\u0026#34;)); sb.append(\u0026#34; \u0026#34;); sb.append(currentDateStr); innerClass.addJavaDocLine(\u0026#34; */\u0026#34;); } /** * Mybatis的Mapper.xml文件里面的注释 */ @Override public void addComment(XmlElement xmlElement) { } /** * *@Title addConfigurationProperties *@Description: 从该配置中的任何属性添加此实例的属性CommentGenerator配置。 * 这个方法将在任何其他方法之前被调用。 *@Author fendo *@Date 2017年10月5日 下午3:45:58 *@return *@throws */ @Override public void addConfigurationProperties(Properties properties) { this.properties.putAll(properties); suppressDate = isTrue(properties.getProperty(PropertyRegistry.COMMENT_GENERATOR_SUPPRESS_DATE)); suppressAllComments = isTrue(properties.getProperty(PropertyRegistry.COMMENT_GENERATOR_SUPPRESS_ALL_COMMENTS)); } /** * *@Title getDateString *@Description: 此方法返回格式化的日期字符串以包含在Javadoc标记中和XML注释。 如果您不想要日期，则可以返回null在这些文档元素中。 *@Author fendo *@Date 2017年10月5日 下午3:45:58 *@return *@throws */ protected String getDateString() { String result = null; if (!suppressDate) { result = currentDateStr; } return result; } /** * *@Title addJavadocTag *@Description: 此方法为其添加了自定义javadoc标签。 *@Author fendo *@Date 2017年10月5日 下午3:49:05 *@param javaElement *@param markAsDoNotDelete *@throws */ protected void addJavadocTag(JavaElement javaElement, boolean markAsDoNotDelete) { javaElement.addJavaDocLine(\u0026#34; *\u0026#34;); StringBuilder sb = new StringBuilder(); sb.append(\u0026#34; * \u0026#34;); sb.append(MergeConstants.NEW_ELEMENT_TAG); if (markAsDoNotDelete) { sb.append(\u0026#34; do_not_delete_during_merge\u0026#34;); } String s = getDateString(); if (s != null) { sb.append(\u0026#39; \u0026#39;); sb.append(s); } javaElement.addJavaDocLine(sb.toString()); } /** * 为枚举添加注释 */ @Override public void addEnumComment(InnerEnum innerEnum, IntrospectedTable introspectedTable) { if (suppressAllComments) { return; } StringBuilder sb = new StringBuilder(); innerEnum.addJavaDocLine(\u0026#34;/**\u0026#34;); sb.append(\u0026#34; * \u0026#34;); sb.append(introspectedTable.getFullyQualifiedTable()); innerEnum.addJavaDocLine(sb.toString().replace(\u0026#34;\\n\u0026#34;, \u0026#34; \u0026#34;)); innerEnum.addJavaDocLine(\u0026#34; */\u0026#34;); } /** * Java属性注释 */ @Override public void addFieldComment(Field field, IntrospectedTable introspectedTable) { if (suppressAllComments) { return; } StringBuilder sb = new StringBuilder(); field.addJavaDocLine(\u0026#34;/**\u0026#34;); sb.append(\u0026#34; * \u0026#34;); sb.append(introspectedTable.getFullyQualifiedTable()); field.addJavaDocLine(sb.toString().replace(\u0026#34;\\n\u0026#34;, \u0026#34; \u0026#34;)); field.addJavaDocLine(\u0026#34; */\u0026#34;); } /** * 为字段添加注释 */ @Override public void addFieldComment(Field field, IntrospectedTable introspectedTable,IntrospectedColumn introspectedColumn) { if (suppressAllComments) { return; } StringBuilder sb = new StringBuilder(); field.addJavaDocLine(\u0026#34;/**\u0026#34;); sb.append(\u0026#34; * \u0026#34;); sb.append(introspectedColumn.getRemarks()); field.addJavaDocLine(sb.toString().replace(\u0026#34;\\n\u0026#34;, \u0026#34; \u0026#34;)); field.addJavaDocLine(\u0026#34; */\u0026#34;); } /** * 普通方法的注释，这里主要是XXXMapper.java里面的接口方法的注释 */ @Override public void addGeneralMethodComment(Method method, IntrospectedTable introspectedTable) { if (suppressAllComments) { return; } method.addJavaDocLine(\u0026#34;/**\u0026#34;); addJavadocTag(method, false); method.addJavaDocLine(\u0026#34; */\u0026#34;); } /** * 给getter方法加注释 */ @Override public void addGetterComment(Method method, IntrospectedTable introspectedTable,IntrospectedColumn introspectedColumn) { if (suppressAllComments) { return; } method.addJavaDocLine(\u0026#34;/**\u0026#34;); StringBuilder sb = new StringBuilder(); sb.append(\u0026#34; * \u0026#34;); sb.append(introspectedColumn.getRemarks()); method.addJavaDocLine(sb.toString().replace(\u0026#34;\\n\u0026#34;, \u0026#34; \u0026#34;)); sb.setLength(0); sb.append(\u0026#34; * @return \u0026#34;); sb.append(introspectedColumn.getActualColumnName()); sb.append(\u0026#34; \u0026#34;); sb.append(introspectedColumn.getRemarks()); method.addJavaDocLine(sb.toString().replace(\u0026#34;\\n\u0026#34;, \u0026#34; \u0026#34;)); method.addJavaDocLine(\u0026#34; */\u0026#34;); } /** * 给Java文件加注释，这个注释是在文件的顶部，也就是package上面。 */ @Override public void addJavaFileComment(CompilationUnit compilationUnit) { SimpleDateFormat sdf=new SimpleDateFormat(\u0026#34;yyyy-MM-dd\u0026#34;); compilationUnit.addFileCommentLine(\u0026#34;/*\u0026#34;); compilationUnit.addFileCommentLine(\u0026#34;*\u0026#34;); compilationUnit.addFileCommentLine(\u0026#34;* \u0026#34;+compilationUnit.getType().getShortName()+\u0026#34;.java\u0026#34;); compilationUnit.addFileCommentLine(\u0026#34;* Copyright(C) 2017-2020 fendo公司\u0026#34;); compilationUnit.addFileCommentLine(\u0026#34;* @date \u0026#34;+sdf.format(new Date())+\u0026#34;\u0026#34;); compilationUnit.addFileCommentLine(\u0026#34;*/\u0026#34;); } /** * 为模型类添加注释 */ @Override public void addModelClassComment(TopLevelClass arg0, IntrospectedTable arg1) { } /** * 为调用此方法作为根元素的第一个子节点添加注释。 */ @Override public void addRootComment(XmlElement arg0) { } /** * 给setter方法加注释 */ @Override public void addSetterComment(Method method, IntrospectedTable introspectedTable,IntrospectedColumn introspectedColumn) { if (suppressAllComments) { return; } method.addJavaDocLine(\u0026#34;/**\u0026#34;); StringBuilder sb = new StringBuilder(); sb.append(\u0026#34; * \u0026#34;); sb.append(introspectedColumn.getRemarks()); method.addJavaDocLine(sb.toString().replace(\u0026#34;\\n\u0026#34;, \u0026#34; \u0026#34;)); Parameter parm = method.getParameters().get(0); sb.setLength(0); sb.append(\u0026#34; * @param \u0026#34;); sb.append(parm.getName()); sb.append(\u0026#34; \u0026#34;); sb.append(introspectedColumn.getRemarks()); method.addJavaDocLine(sb.toString().replace(\u0026#34;\\n\u0026#34;, \u0026#34; \u0026#34;)); method.addJavaDocLine(\u0026#34; */\u0026#34;); } } 在 generatorConfig.xml 文件中使用自定义插件 \u0026lt;!-- 自定义lombok --\u0026gt; \u0026lt;plugin type=\u0026#34;com.xxgc.mybatis.plugin.LombokPlugin\u0026#34; /\u0026gt; \u0026lt;!-- 自定义注解解析器 --\u0026gt; \u0026lt;commentGenerator type=\u0026#34;com.xxgc.mybatis.plugin.MyCommentGenerator\u0026#34; /\u0026gt; \u0026lt;!-- 自定义lombok增强 --\u0026gt; \u0026lt;plugin type=\u0026#34;plugins.LombokPlugin\u0026#34; \u0026gt; \u0026lt;property name=\u0026#34;hasLombok\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;!--通过type属性改成自己注解解析器--\u0026gt; \u0026lt;commentGenerator type=\u0026#34;plugins.MyCommentGenerator\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;suppressDate\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --\u0026gt; \u0026lt;!--\u0026lt;property name=\u0026#34;suppressAllComments\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt;--\u0026gt; \u0026lt;property name=\u0026#34;addRemarkComments\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;/commentGenerator\u0026gt; 可能出现的问题 大多数情况下,到第三步就算是结束了.下面的,都是踩的坑.\n提示找不到MyCommentGenerator 这个一般是使用Maven命令运行MBG时才会出现的错误.\n原因是mybatis-generator-core与MyCommentGenerator不在同一个ClassPath下。需要将自定义插件打包生成jar,然后在pom文件mybatis-generator-maven-plugin插件中添加相关依赖。\n获取不到字段注释  没错,就是introspectedColumn.getRemarks()获取不到字段的注释,生成的javabean里面应该显示字段注释的地方显示的是null.配置文件中我们对做如下修改即可:\n\u0026lt;jdbcConnection driverClass=\u0026#34;${driver}\u0026#34; connectionURL=\u0026#34;{url}\u0026#34; userId=\u0026#34;${username}\u0026#34; password=\u0026#34;${password}\u0026#34;\u0026gt; \u0026lt;!-- 针对oracle数据库 --\u0026gt; \u0026lt;property name=\u0026#34;remarksReporting\u0026#34; value=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;!-- 针对mysql数据库 --\u0026gt; \u0026lt;property name=\u0026#34;useInformationSchema\u0026#34; value=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/jdbcConnection\u0026gt;  ","date":"2021-10-26T19:34:24+08:00","permalink":"https://example.com/p/mybatis-generator%E4%BD%BF%E7%94%A8/","title":"Mybatis Generator使用"},{"content":"Java命名规范参考！ 文章摘自https://www.cnblogs.com/liqiangchn/p/12000361.html\n简洁清爽的代码风格应该是大多数工程师所期待的。在工作中笔者常常因为起名字而纠结，夸张点可以说是编程5分钟，命名两小时！究竟为什么命名成为了工作中的拦路虎。\n每个公司都有不同的标准，目的是为了保持统一，减少沟通成本，提升团队研发效能。所以本文中是笔者结合阿里巴巴开发规范，以及工作中的见闻针对Java领域相关命名进行整理和总结，仅供参考。\nJava中的命名规范 好的命名能体现出代码的特征，含义或者是用途，让阅读者可以根据名称的含义快速厘清程序的脉络。不同语言中采用的命名形式大相径庭，Java中常用到的命名形式共有三种，既首字母大写的UpperCamelCase，首字母小写的lowerCamelCase以及全部大写的并用下划线分割单词的UPPER_CAMEL_UNSER_SCORE。通常约定，类一般采用大驼峰命名，方法和局部变量使用小驼峰命名，而大写下划线命名通常是常量和枚举中使用。\n   类型 约束 例     项目名 全部小写，多个单词用中划线分隔‘-’ spring-cloud   包名 全部小写 com.alibaba.fastjson   类名 单词首字母大写 Feature, ParserConfig,DefaultFieldDeserializer   变量名 首字母小写，多个单词组成时，除首个单词，其他单词首字母都要大写 password, userName   常量名 全部大写，多个单词，用'_\u0026lsquo;分隔 CACHE_EXPIRED_TIME   方法 同变量 read(), readObject(), getById()    包命名 包名统一使用小写，点分隔符之间有且仅有一个自然语义的英文单词或者多个单词自然连接到一块（如 springframework，deepspace不需要使用任何分割）。包名统一使用单数形式，如果类命有复数含义，则可以使用复数形式。\n包名的构成可以分为以下几四部分【前缀】 【发起者名】【项目名】【模块名】。常见的前缀可以分为以下几种：\n   前缀名 例 含义     indi（或onem ） indi.发起者名.项目名.模块名.…… 个体项目，指个人发起，但非自己独自完成的项目，可公开或私有项目，copyright主要属于发起者。   pers pers.个人名.项目名.模块名.…… 个人项目，指个人发起，独自完成，可分享的项目，copyright主要属于个人   priv priv.个人名.项目名.模块名.…… 私有项目，指个人发起，独自完成，非公开的私人使用的项目，copyright属于个人。   team team.团队名.项目名.模块名.…… 团队项目，指由团队发起，并由该团队开发的项目，copyright属于该团队所有   顶级域名 com.公司名.项目名.模块名.…… 公司项目，copyright由项目发起的公司所有    类命名 类名使用大驼峰命名形式，类命通常时名词或名词短语，接口名除了用名词和名词短语以外，还可以使用形容词或形容词短语，如Cloneable，Callable等，表示实现该接口的类有某种功能或能力。对于测试类则以它要测试的类开头，以Test结尾，如HashMapTest。\n对于一些特殊特有名词缩写也可以使用全大写命名，比如XMLHttpRequest，不过笔者认为缩写三个字母以内都大写，超过三个字母则按照要给单词算。这个没有标准如阿里巴巴中fastjson用JSONObject作为类命，而google则使用JsonObjectRequest命名，对于这种特殊的缩写，原则是统一就好。\n   属性 约束 例     抽象类 Abstract 或者 Base 开头 BaseUserService   枚举类 Enum 作为后缀 GenderEnum   工具类 Utils作为后缀 StringUtils   异常类 Exception结尾 RuntimeException   接口实现类 接口名+ Impl UserServiceImpl   领域模型相关 /DO/DTO/VO/DAO 正例：UserDAO 反例： UserDo， UserDao   设计模式相关类 Builder，Factory等 当使用到设计模式时，需要使用对应的设计模式作为后缀，如ThreadFactory   处理特定功能的 Handler，Predicate, Validator 表示处理器，校验器，断言，这些类工厂还有配套的方法名如handle，predicate，validate   测试类 Test结尾 UserServiceTest， 表示用来测试UserService类的   MVC分层 Controller，Service，ServiceImpl，DAO后缀 UserManageController，UserManageDAO    方法 方法命名采用小驼峰的形式，首字小写，往后的每个单词首字母都要大写。 和类名不同的是，方法命名一般为动词或动词短语，与参数或参数名共同组成动宾短语，即动词 + 名词。一个好的函数名一般能通过名字直接获知该函数实现什么样的功能。\n返回真伪值的方法 注：Prefix-前缀，Suffix-后缀，Alone-单独使用\n   位置 单词 意义 例     Prefix is 对象是否符合期待的状态 isValid   Prefix can 对象能否执行所期待的动作 canRemove   Prefix should 调用方执行某个命令或方法是好还是不好,应不应该，或者说推荐还是不推荐 shouldMigrate   Prefix has 对象是否持有所期待的数据和属性 hasObservers   Prefix needs 调用方是否需要执行某个命令或方法 needsMigrate    用来检查的方法    单词 意义 例     ensure 检查是否为期待的状态，不是则抛出异常或返回error code ensureCapacity   validate 检查是否为正确的状态，不是则抛出异常或返回error code validateInputs    按需求才执行的方法    位置 单词 意义 例     Suffix IfNeeded 需要的时候执行，不需要的时候什么都不做 drawIfNeeded   Prefix might 同上 mightCreate   Prefix try 尝试执行，失败时抛出异常或是返回errorcode tryCreate   Suffix OrDefault 尝试执行，失败时返回默认值 getOrDefault   Suffix OrElse 尝试执行、失败时返回实际参数中指定的值 getOrElse   Prefix force 强制尝试执行。error抛出异常或是返回值 forceCreate, forceStop    异步相关方法    位置 单词 意义 例     Prefix blocking 线程阻塞方法 blockingGetUser   Suffix InBackground 执行在后台的线程 doInBackground   Suffix Async 异步方法 sendAsync   Suffix Sync 对应已有异步方法的同步方法 sendSync   Prefix or Alone schedule Job和Task放入队列 schedule, scheduleJob   Prefix or Alone post 同上 postJob   Prefix or Alone execute 执行异步方法（注：我一般拿这个做同步方法名） execute, executeTask   Prefix or Alone start 同上 start, startJob   Prefix or Alone cancel 停止异步方法 cancel, cancelJob   Prefix or Alone stop 同上 stop, stopJob    回调方法    位置 单词 意义 例     Prefix on 事件发生时执行 onCompleted   Prefix before 事件发生前执行 beforeUpdate   Prefix pre 同上 preUpdate   Prefix will 同上 willUpdate   Prefix after 事件发生后执行 afterUpdate   Prefix post 同上 postUpdate   Prefix did 同上 didUpdate   Prefix should 确认事件是否可以发生时执行 shouldUpdate    操作对象生命周期的方法    单词 意义 例     initialize 初始化。也可作为延迟初始化使用 initialize   pause 暂停 onPause ，pause   stop 停止 onStop，stop   abandon 销毁的替代 abandon   destroy 同上 destroy   dispose 同上 dispose    与集合操作相关的方法    单词 意义 例     contains 是否持有与指定对象相同的对象 contains   add 添加 addJob   append 添加 appendJob   insert 插入到下标n insertJob   put 添加与key对应的元素 putJob   remove 移除元素 removeJob   enqueue 添加到队列的最末位 enqueueJob   dequeue 从队列中头部取出并移除 dequeueJob   push 添加到栈头 pushJob   pop 从栈头取出并移除 popJob   peek 从栈头取出但不移除 peekJob   find 寻找符合条件的某物 findById    与数据相关的方法    单词 意义 例     create 新创建 createAccount   new 新创建 newAccount   from 从既有的某物新建，或是从其他的数据新建 fromConfig   to 转换 toString   update 更新既有某物 updateAccount   load 读取 loadAccount   fetch 远程读取 fetchAccount   delete 删除 deleteAccount   remove 删除 removeAccount   save 保存 saveAccount   store 保存 storeAccount   commit 保存 commitChange   apply 保存或应用 applyChange   clear 清除数据或是恢复到初始状态 clearAll   reset 清除数据或是恢复到初始状态 resetAll    成对出现的动词    单词 意义     get获取 set 设置   add 增加 remove 删除   create 创建 destory 移除   start 启动 stop 停止   open 打开 close 关闭   read 读取 write 写入   load 载入 save 保存   create 创建 destroy 销毁   begin 开始 end 结束   backup 备份 restore 恢复   import 导入 export 导出   split 分割 merge 合并   inject 注入 extract 提取   attach 附着 detach 脱离   bind 绑定 separate 分离   view 查看 browse 浏览   edit 编辑 modify 修改   select 选取 mark 标记   copy 复制 paste 粘贴   undo 撤销 redo 重做   insert 插入 delete 移除   add 加入 append 添加   clean 清理 clear 清除   index 索引 sort 排序   find 查找 search 搜索   increase 增加 decrease 减少   play 播放 pause 暂停   launch 启动 run 运行   compile 编译 execute 执行   debug 调试 trace 跟踪   observe 观察 listen 监听   build 构建 publish 发布   input 输入 output 输出   encode 编码 decode 解码   encrypt 加密 decrypt 解密   compress 压缩 decompress 解压缩   pack 打包 unpack 解包   parse 解析 emit 生成   connect 连接 disconnect 断开   send 发送 receive 接收   download 下载 upload 上传   refresh 刷新 synchronize 同步   update 更新 revert 复原   lock 锁定 unlock 解锁   check out 签出 check in 签入   submit 提交 commit 交付   push 推 pull 拉   expand 展开 collapse 折叠   begin 起始 end 结束   start 开始 finish 完成   enter 进入 exit 退出   abort 放弃 quit 离开   obsolete 废弃 depreciate 废旧   collect 收集 aggregate 聚集    变量\u0026amp;常量命名 变量命名 变量是指在程序运行中可以改变其值的量，包括成员变量和局部变量。变量名由多单词组成时，第一个单词的首字母小写，其后单词的首字母大写，俗称骆驼式命名法（也称驼峰命名法），如 computedValues，index、变量命名时，尽量简短且能清楚的表达变量的作用，命名体现具体的业务含义即可。\n变量名不应以下划线或美元符号开头，尽管这在语法上是允许的。变量名应简短且富于描述。变量名的选用应该易于记忆，即，能够指出其用途。尽量避免单个字符的变量名，除非是一次性的临时变量。pojo中的布尔变量，都不要加is(数据库中的布尔字段全都要加 is_ 前缀)。\n常量命名 常量命名CONSTANT_CASE，一般采用全部大写（作为方法参数时除外），单词间用下划线分割。那么什么是常量呢？\n常量是在作用域内保持不变的值，一般使用final进行修饰。一般分为三种，全局常量（public static final修饰），类内常量（private static final 修饰）以及局部常量（方法内，或者参数中的常量），局部常量比较特殊，通常采用小驼峰命名即可。\nCopy/** * 一个demo * * @author Jann Lee * @date 2019-12-07 00:25 **/ public class HelloWorld { /** * 局部常量(正例) */ public static final long USER_MESSAGE_CACHE_EXPIRE_TIME = 3600; /** * 局部常量(反例，命名不清晰） */ public static final long MESSAGE_CACHE_TIME = 3600; /** * 全局常量 */ private static final String ERROR_MESSAGE = \u0026#34; error message\u0026#34;; /** * 成员变量 */ private int currentUserId; /** * 控制台打印 {@code message} 信息 * * @param message 消息体，局部常量 */ public void sayHello(final String message){ System.out.println(\u0026#34;Hello world!\u0026#34;); } } 常量一般都有自己的业务含义,不要害怕长度过长而进行省略或者缩写。如，用户消息缓存过期时间的表示，那种方式更佳清晰，交给你来评判。\n通用命名规则  尽量不要使用拼音；杜绝拼音和英文混用。对于一些通用的表示或者难以用英文描述的可以采用拼音，一旦采用拼音就坚决不能和英文混用。 正例： BeiJing， HangZhou 反例： validateCanShu 命名过程中尽量不要出现特殊的字符，常量除外。 尽量不要和jdk或者框架中已存在的类重名，也不能使用java中的关键字命名。 妙用介词，如for(可以用同音的4代替), to(可用同音的2代替), from, with，of等。 如类名采用User4RedisDO，方法名getUserInfoFromRedis，convertJson2Map等。  代码注解 注解的原则 好的命名增加代码阅读性，代码的命名往往有严格的限制。而注解不同，程序员往往可以自由发挥，单并不意味着可以为所欲为之胡作非为。优雅的注解通常要满足三要素。\n Nothing is strange 没有注解的代码对于阅读者非常不友好，哪怕代码写的在清除，阅读者至少从心理上会有抵触，更何况代码中往往有许多复杂的逻辑，所以一定要写注解，不仅要记录代码的逻辑，还有说清楚修改的逻辑。 Less is more 从代码维护角度来讲，代码中的注解一定是精华中的精华。合理清晰的命名能让代码易于理解，对于逻辑简单且命名规范，能够清楚表达代码功能的代码不需要注解。滥用注解会增加额外的负担，更何况大部分都是废话。  Copy// 根据id获取信息【废话注解】 getMessageById(id)  Advance with the time 注解应该随着代码的变动而改变，注解表达的信息要与代码中完全一致。通常情况下修改代码后一定要修改注解。  注解格式 注解大体上可以分为两种，一种是javadoc注解，另一种是简单注解。javadoc注解可以生成JavaAPI为外部用户提供有效的支持javadoc注解通常在使用IDEA，或者Eclipse等开发工具时都可以自动生成，也支持自定义的注解模板，仅需要对对应的字段进行解释。参与同一项目开发的同学，尽量设置成相同的注解模板。\na. 包注解 包注解在工作中往往比较特殊，通过包注解可以快速知悉当前包下代码是用来实现哪些功能，强烈建议工作中加上，尤其是对于一些比较复杂的包，包注解一般在包的根目录下，名称统一为package-info.java。\nCopy/** * 落地也质量检测 * 1. 用来解决什么问题 * 对广告主投放的广告落地页进行性能检测，模拟不同的系统，如Android，IOS等; 模拟不同的网络：2G，3G，4G，wifi等 * * 2. 如何实现 * 基于chrome浏览器，用chromedriver驱动浏览器，设置对应的网络，OS参数，获取到浏览器返回结果。 * * 注意： 网络环境配置信息{@link cn.mycookies.landingpagecheck.meta.NetWorkSpeedEnum}目前使用是常规速度，可以根据实际情况进行调整 * * @author cruder * @time 2019/12/7 20:3 下午 */ package cn.mycookies.landingpagecheck; b. 类注解 javadoc注解中，每个类都必须有注解。\nCopy/** * Copyright (C), 2019-2020, Jann balabala... * * 类的介绍：这是一个用来做什么事情的类，有哪些功能，用到的技术..... * * @author 类创建者姓名 保持对齐 * @date 创建日期 保持对齐 * @version 版本号 保持对齐 */ c. 属性注解 在每个属性前面必须加上属性注释，通常有一下两种形式，至于怎么选择，你高兴就好，不过一个项目中要保持统一。\nCopy/** 提示信息 */ private String userName; /** * 密码 */ private String password; d. 方法注释 在每个方法前面必须加上方法注释，对于方法中的每个参数，以及返回值都要有说明。\nCopy/** * 方法的详细说明，能干嘛，怎么实现的，注意事项... * * @param xxx 参数1的使用说明， 能否为null * @return 返回结果的说明， 不同情况下会返回怎样的结果 * @throws 异常类型 注明从此类方法中抛出异常的说明 */ e. 构造方法注释 在每个构造方法前面必须加上注释，注释模板如下：\nCopy/** * 构造方法的详细说明 * * @param xxx 参数1的使用说明， 能否为null * @throws 异常类型 注明从此类方法中抛出异常的说明 */ 而简单注解往往是需要工程师字节定义，在使用注解时应该注意一下几点：\n 枚举类的各个属性值都要使用注解，枚举可以理解为是常量，通常不会发生改变，通常会被在多个地方引用，对枚举的修改和添加属性通常会带来很大的影响。 保持排版整洁，不要使用行尾注释；双斜杠和星号之后要用1个空格分隔。  Copyint id = 1;// 反例：不要使用行尾注释 //反例：换行符与注释之间没有缩进 int age = 18; // 正例：姓名 String name; /** * 1. 多行注释 * * 2. 对于不同的逻辑说明，可以用空行分隔 */ 总结 无论是命名和注解，他们的目的都是为了让代码和工程师进行对话，增强代码的可读性，可维护性。优秀的代码往往能够见名知意，注解往往是对命名的补充和完善。命名太南了！\n","date":"2021-10-23T22:26:26+08:00","permalink":"https://example.com/p/java%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E5%8F%82%E8%80%83/","title":"Java命名规范参考"},{"content":"1、REST的概念 REST为“Representational State Transfer”的缩写，中文释义为“表现层状态转换”，REST不是一种标准，而是一种设计风格。是目前最流行的一种互联网软件架构风格。它倡导结构清晰、符合标准、易于理解、扩展方便的Web架构体系，主张严格按照HTTP协议中定义的规范设计结构严谨的Web应用架构体系。由于REST所倡导的理念让Web应用更易于开发和维护，更加优雅简洁，所以正得到越来越多网站的采用。\n  资源（Resources）：网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的存在。可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的 URI 。要获取这个资源，访问它的URI就可以，因此 URI 即为每一个资源的独一无二的识别符。\n  表现层（Representation）：把资源具体呈现出来的形式，叫做它的表现层（Representation）。比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式。\n  状态转化\n（State Transfer）：每发出一个请求，就代表了客户端和服务器的一次交互过程。HTTP协议，是一个无状态协议，即所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生“状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是 “表现层状态转化”。\n具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：\n GET 用来获取资源 POST 用来新建资源 PUT 用来更新资源 DELETE 用来删除资源       HTTP方法名 使用场景 资源操作 是否幂等 是否安全     GET 从服务器取出资源（一项或多项） SELECT 是 是   POST 在服务器新建一个资源 INSERT 否 否   PUT 在服务器更新资源（客户端提供完整资源数据） UPDATE 是 否   DELETE 从服务器删除资源 DELETE 是 否     幂等性：对同一REST接口的多次访问，得到的资源状态是相同的。 安全性：对该REST接口访问，不会使服务器端资源的状态发生改变。   RESTful：就是符合REST原则的架构方式即可称为RESTful。\n 2、REST 风格的 URL 请求 一般在非RESTful风格设计的应用中基本上只使用POST、GET类型的HTTP动作方法，而在RESTful风格设计的应用中充分利用了HTTP协议的另外动作方法，统一了数据操作的接口，使得URL请求变得简洁化、透明化。\n  get/user 查询整个列表 get/user/user_id 查询一条记录 post/user 添加数据 put/user/user_id 更新全部数据 patch/user/user_id 更新部分数据 delete/user/user_id 删除一条数据   3、REST风格URL的好处 ①、含蓄，安全：使用问号键值对的方式给服务器传递数据太明显，容易被人利用来对系统进行破坏。使用REST风格携带数据不再需要明显的暴露数据的名称。\n②、风格统一：URL地址整体格式统一，从前到后始终都使用斜杠划分各个内容部分，用简单一致的格式表达语义。\n③、无状态：在调用一个接口（访问、操作资源）的时候，可以不用考虑上下文，不用考虑当前状态，极大的降低了系统设计的复杂度。\n④、严谨，规范：严格按照HTTP1.1协议中定义的请求方式本身的语义进行操作。\n⑤、简洁，优雅：过去做增删改查操作需要设计4个不同的URL，现在一个就够了。\n⑥、丰富的语义：通过URL地址就可以知道资源之间的关系，如下所示：\n http://localhost:8080/shop http://localhost:8080/shop/product http://localhost:8080/shop/product/cellPhone http://localhost:8080/shop/product/cellPhone/iPhone\n 4、SpringMVC对四种请求方式的支持 在@RequestMapping注解中，我们可以使用method熟悉来设置对四种请求的支持：\n @RequestMapping(value = \u0026ldquo;/get\u0026rdquo;,method = RequestMethod.GET) @RequestMapping(value = \u0026ldquo;/post\u0026rdquo;,method = RequestMethod.POST) @RequestMapping(value = \u0026ldquo;/put\u0026rdquo;,method = RequestMethod.PUT) @RequestMapping(value = \u0026ldquo;/delete\u0026rdquo;,method = RequestMethod.DELETE)  但是可以发现上面的注解中大体都是相似了，所以SpringMVC给我们提供了简化的版本：\n @GetMapping(value = \u0026ldquo;/get\u0026rdquo;)：对应GET请求 @PostMapping(value = \u0026ldquo;/post\u0026rdquo;)：对应POST请求 @PutMapping(value = \u0026ldquo;/put\u0026rdquo;)：对应PUT请求 @DeleteMapping(value = \u0026ldquo;/delete\u0026rdquo;)：对应DELETE请求  注：在SpringMVC中对RESTful支持，主要通过注解来实现，所以下面再介绍三个相关注解：\n @ResponseBody：响应内容转换为JSON格式 @RequestBody：请求内容转换为JSON格式 @RestContrller：等同@Controller+@ResponsrBody 标识这个类的所有方法只返回数据，而不进行视图跳转  @RequestMapping请求映射地址，它存在几个子注解对于实现 REST风格来说更加具有语义性\n4.1 返回 HTTP状态码 REST风格 API一个最鲜明的特点通过返回对应的 HTTPStatus来判断客户端的操作是否完成\n下面是spring中关于 Http状态码描述的枚举类，一些常见的状态码\npublic enum HttpStatus{ OK(200, \u0026#34;OK\u0026#34;),//用于服务器有实体响应  CREATED(201, \u0026#34;Created\u0026#34;),//创建了新实体，响应该实体  NO_CONTENT(204, \u0026#34;No Content\u0026#34;),//服务器正常响应，但无实体响应  BAD_REQUEST(400, \u0026#34;Bad Request\u0026#34;),//客户端请求语法错误  NOT_FOUND(404, \u0026#34;Not Found\u0026#34;),//目标资源不存在  INTERNAL_SERVER_ERROR(500, \u0026#34;Internal Server Error\u0026#34;),//服务器内部错误  NOT_IMPLEMENTED(501, \u0026#34;Not Implemented\u0026#34;),//服务器不支持当前请求 } Spring返回状态码是通过 @ResponseStatus注解或者 ResponseEntity\u0026lt;?\u0026gt;类实现的。\n@ResponseStatus方式\n@GetMapping(path = \u0026#34;/user/{id}\u0026#34; , produces = \u0026#34;application/json;charset=utf-8\u0026#34;) @ResponseStatus(HttpStatus.OK) public User findUserById(@PathVariable(\u0026#34;id\u0026#34;)Integer id){ User user = userService.findUserById(id); return user ; } ResponseEntity\u0026lt;?\u0026gt;方式\n@GetMapping(produces = \u0026#34;application/json;charset=utf-8\u0026#34;) public ResponseEntity\u0026lt;List\u0026lt;User\u0026gt;\u0026gt; findAll(){ List\u0026lt;User\u0026gt; users = userService.findAll(); return new ResponseEntity\u0026lt;List\u0026lt;User\u0026gt;\u0026gt;(users , HttpStatus.OK); } 浏览器对REST的支持：\n由于浏览器表单只支持 GET 和 POST 请求，所以为了让浏览器实现 DELETE 和 PUT 请求，Spring 为我们提供了一个过滤器：org.springframework.web.filter.HiddenHttpMethodFilter，可以为我们将 GET 和 POST 请求通过过滤器转化成 PUT 或 DELETE 等其他形式。\n下面是HiddenHttpMethodFilter的使用方法：\n①在web.xml中进行配置，拦截所有资源，注意：它必须作用于解决乱码过滤器CharacterEncodingFilter的后面，否则处理乱码的过滤器就会失效。\n\u0026lt;!-- 配置 org.springframework.web.filter.HiddenHttpMethodFilter 过滤器 --\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;hiddenHttpMethodFilter\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.HiddenHttpMethodFilter\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;hiddenHttpMethodFilter\u0026lt;/filter-name\u0026gt; \u0026lt;!-- 拦截所有请求 --\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; [1]、转PUT请求：\nPOST请求转为PUT请求非常简单，只需在表单隐藏域中通过_method请求参数附带请求方式名称即可。\n\u0026lt;!-- 将POST请求转为PUT请求 --\u0026gt; \u0026lt;!-- 表单需要按照HiddenHttpMethodFilter的要求来写 --\u0026gt; \u0026lt;!-- 要求1：请求本身是必须是POST --\u0026gt; \u0026lt;!-- 要求2：指定新请求方式的请求参数名称必须是_method --\u0026gt; \u0026lt;form action=\u0026#34;${pageContext.request.contextPath}/update/emp\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;_method\u0026#34; value=\u0026#34;PUT\u0026#34; /\u0026gt; ....... \u0026lt;/form\u0026gt; [2]、转DELETE请求：\n通过点击超链接执行删除操作。这是一个难点，超链接中没有表单隐藏域，所以需要将超链接转换为表单进行提交，这就需要借助于JavaScript。\n①、在页面上创建一个action属性为空的form表单\n\u0026lt;!-- 将超链接的GET请求转换为DELETE请求 --\u0026gt; \u0026lt;!-- 1、提供一个通用的表单，用来将GET请求先转换为POST，然后再发送_method请求参数 --\u0026gt; \u0026lt;!-- action属性不能写死，将来点击哪一个超链接，目标地址就和那个超链接一致 --\u0026gt; \u0026lt;form id=\u0026#34;commonForm\u0026#34; action=\u0026#34;\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;_method\u0026#34; value=\u0026#34;delete\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; ②、给所有超链接绑定单击响应函数\n\u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;${pageContext.request.contextPath}/script/jquery-1.7.2.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; $(function () { $(\u0026#34;.removeEmp\u0026#34;).click(function () { // 在单击响应函数中获取当前点击的超链接的URL地址 \tvar targetUrl = this.href; console.log(targetUrl); // 通过id获取到表单的jQuery对象，然后设置action属性值，再提交表单 \t$(\u0026#34;#commonForm\u0026#34;).attr(\u0026#34;action\u0026#34;, targetUrl).submit(); // 取消控件的默认行为 \treturn false; }); }); \u0026lt;/script\u0026gt; ③、超链接\n\u0026lt;a class=\u0026#34;removeEmp\u0026#34; href=\u0026#34;${pageContext.request.contextPath}/remove/emp/1\u0026#34;\u0026gt;模拟删除\u0026lt;/a\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;a class=\u0026#34;removeEmp\u0026#34; href=\u0026#34;${pageContext.request.contextPath}/remove/emp/2\u0026#34;\u0026gt;模拟删除\u0026lt;/a\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;a class=\u0026#34;removeEmp\u0026#34; href=\u0026#34;${pageContext.request.contextPath}/remove/emp/3\u0026#34;\u0026gt;模拟删除\u0026lt;/a\u0026gt;\u0026lt;br/\u0026gt; 5、@PathVariable注解 @PathVariable作用：通过URL地址携带的数据需要通过@PathVariable注解来获取。它的用法如下：\n\u0026lt;a href=\u0026#34;${pageContext.request.contextPath}/emp/2\u0026#34;\u0026gt;一个参数情况\u0026lt;/a\u0026gt;\u0026lt;br/\u0026gt; //请求路径为：/emp/2 @RequestMapping(\u0026#34;/emp/{empId}\u0026#34;) public String testPathVariable(@PathVariable(\u0026#34;empId\u0026#34;) Integer empId) { System.out.println(\u0026#34;empId=\u0026#34;+empId); return \u0026#34;result\u0026#34;; } 对于请求路径中有多个数据，@PathVariable注解也是支持的。\n\u0026lt;a href=\u0026#34;${pageContext.request.contextPath}/send/message/tom/tell/jerry\u0026#34;\u0026gt;多个参数情况\u0026lt;/a\u0026gt;\u0026lt;br/\u0026gt; 复制//请求路径为：/send/message/tom/tell/jerry @RequestMapping(\u0026#34;/send/message/{foo}/tell/{bar}\u0026#34;) public String sendMessage(@PathVariable(\u0026#34;foo\u0026#34;) String foo, @PathVariable(\u0026#34;bar\u0026#34;) String bar) { System.out.println(\u0026#34;foo = \u0026#34; + foo); System.out.println(\u0026#34;bar = \u0026#34; + bar); return \u0026#34;target\u0026#34;; } Restful API设计 Restful API 对于URL的约定 在Restful 架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表名相对应。一般来说，数据库中的表都是同种记录的“集合”（collection）,所以API中的名词也可以使用复数。\nURL的设计规则如下：\n/模块/资源/{标识}/集合1/….\n比如：\n/user/{uid}/friends -\u0026gt; 好友列表\n/user/{uid}/followers -\u0026gt; 关注者列表\n再举个栗子：\n与秒杀相关的操作的接口：\nGET /seckill/list 秒杀列表\nGET /seckill/{id}/detail 详情页\nGET /seckill/time/now 系统时间\nPOST /seckill/{id}/exposer 暴露秒杀\nPOST /seckill/{id}/{md5}/execution 执行秒杀\n不友好的设计如下：\nPOST /seckill/execute/{seckillId} (不友好，execute是动词)\nGET /seckill/delete/{id} (不友好，应该用DELETE提交,可改为如下：)\nDELETE /seckill/{id}/delete (友好)\nRestful API 在Spring MVC中的实现 Spring中的@RequestMapping注解，分析如下：\n@RequestMapping注解的特点如下：\n（1）支持标准的URL\n（2）Ant风格URL（即？和**等字符）\n（3）带{×××}占位符的URL\n例如：\n/user/*/creation\n 匹配： /user/aaa/creation、/user/bbb/creation等URL。  /user/**/creation\n 匹配： /user/creation、/user/aaa/bbb/creation等URL。  /user/{userId}\n 匹配： /user/123、/user/abc等URL。  /company/{campanyId}/user/{userId}/detail\n 匹配：/company/123/user/323/detail等的URL ","date":"2021-10-21T21:51:22+08:00","permalink":"https://example.com/p/springmvc%E5%AE%9E%E7%8E%B0restful%E9%A3%8E%E6%A0%BC/","title":"springMVC实现restful风格"},{"content":"配置DispatcherServlet 在进行Spring MVC的配置时，通常会配置一个dispatcher-servlet.xml用于处理对应的URL。web.xml中配置如下：\n\u0026lt;!--springmvc默认拦截器拦截请求--\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;SpringMVC\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:dispatcher-servlet.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;!--tomcat启动时立即初始化拦截器--\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;!-- url-pattern拦截地址的区别 / 会匹配url请求/index等 ,也会匹配静态资源*.js,*.html等, 不会匹配*.jsp文件。 /* 会匹配url请求/index等 ,也会匹配静态资源*.js,*.html等, 会匹配*.jsp文件。 在实际开发中可能遇到 *.do、*.cation 等拦截代后缀的请求 --\u0026gt; \u0026lt;servlet-name\u0026gt;SpringMVC\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;!-- 只拦截.do请求 \u0026lt;url-pattern\u0026gt;*.do\u0026lt;/url-pattern\u0026gt; --\u0026gt; \u0026lt;/servlet-mapping\u0026gt; 优雅 REST 风格的 URL 不希望带 .html 或 .do 等后缀，而如果将 DispatcherServlet 请求映射配置为\u0026quot;/\u0026quot;，则Spring MVC将捕获Web容器所有的请求，静态资源的请求找不到对应处理器将导致错误。\nspringMvc过滤静态资源文件 1、使用Tomcat的defaultServlet来处理静态文件 web.xml里添加如下的配置\n\u0026lt;!--在springmvc拦截所有请求之前放行所有静态资源文件--\u0026gt; \u0026lt;!--每一个\u0026lt;url-pattern\u0026gt;代表一种静态资源文件--\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;default\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;*.html\u0026lt;/url-pattern\u0026gt; \u0026lt;url-pattern\u0026gt;*.css\u0026lt;/url-pattern\u0026gt; \u0026lt;url-pattern\u0026gt;*.js\u0026lt;/url-pattern\u0026gt; \u0026lt;url-pattern\u0026gt;*.ico\u0026lt;/url-pattern\u0026gt; \u0026lt;url-pattern\u0026gt;*.jpg\u0026lt;/url-pattern\u0026gt; \u0026lt;url-pattern\u0026gt;*.png\u0026lt;/url-pattern\u0026gt; \u0026lt;url-pattern\u0026gt;*.gif\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt;  要写在DispatcherServlet的前面， 让defaultServlet先拦截，这个就不会进入Spring了，我想性能是最好的吧。\n Tomcat, Jetty, JBoss, and GlassFish 默认 Servlet的名字 \u0026ndash; \u0026ldquo;default\u0026rdquo; Google App Engine 默认 Servlet的名字 \u0026ndash; \u0026ldquo;_ah_default\u0026rdquo; Resin 默认 Servlet的名字 \u0026ndash; \u0026ldquo;resin-file\u0026rdquo; WebLogic 默认 Servlet的名字 \u0026ndash; \u0026ldquo;FileServlet\u0026rdquo; WebSphere 默认 Servlet的名字 \u0026ndash; \u0026ldquo;SimpleFileServlet\u0026rdquo;   2、使用\u0026lt;mvc:resources\u0026gt;标签 在dispatcher-servlet.xml中插入以下配置：\n\u0026lt;mvc:annotation-driven /\u0026gt; \u0026lt;mvc:resources location=\u0026#34;/resources/\u0026#34; mapping=\u0026#34;/resources/**\u0026#34;/\u0026gt; \u0026lt;mvc:resources location=\u0026#34;/classpath:/META-INF/publicResources/\u0026#34; mapping=\u0026#34;/resources/**\u0026#34;/\u0026gt;   mapping ：映射路径。 location ：本地资源路径。 ** ：它表示映射resources/下所有的URL，包括子路径（即接多个/）  配置将Web根路径 \u0026ldquo;/\u0026rdquo; 及类路径下 /META-INF/publicResources/ 的目录映射为 /resources 路径。假设Web根路径下拥有 images、js 这两个资源目录,在 images下面有 bg.gif 图片，在 js下面有 test.js 文件，则可以通过 /resources/images/bg.gif 和 /resources/js/test.js 访问这二个静态资源。\n另外需要注意的一点是,不要对 SimpleUrlHandlerMapping 设置 defaultHandler. 因为对 static uri 的 defaultHandler 就是ResourceHttpRequestHandler,否则无法处理static resources request.\n首先，\u0026lt;mvc:resources /\u0026gt;允许静态资源放在任何地方，如WEB-INF目录下、类路径下等，你甚至可以将JavaScript等静态文件打到JAR包中。通过location属性指定静态资源的位置，由于location属性是Resources类型，因此可以使用诸如\u0026quot;classpath:\u0026ldquo;等的资源前缀指定资源位置。传统Web容器的静态资源只能放在Web容器的根路径下，\u0026lt;mvc:resources /\u0026gt;完全打破了这个限制。\n其次，\u0026lt;mvc:resources /\u0026gt;依据当前著名的Page Speed、YSlow等浏览器优化原则对静态资源提供优化。你可以通过cacheSeconds属性指定静态资源在浏览器端的缓存时间，一般可将该时间设置为一年，以充分利用浏览器端的缓存。在输出静态资源时，会根据配置设置好响应报文头的Expires 和 Cache-Control值。\n在接收到静态资源的获取请求时，会检查请求头的Last-Modified值，如果静态资源没有发生变化，则直接返回303相应状态码，提示客户端使用浏览器缓存的数据，而非将静态资源的内容输出到客户端，以充分节省带宽，提高程序性能。\n 3、使用\u0026lt;mvc:default-servlet-handler /\u0026gt;标签 在dispatcher-servlet.xml中插入以下配置：\n\u0026lt;mvc:default-servlet-handler /\u0026gt;  在xml文件中配置mvc:default-servlet-handler/，Spring MVC上下文中定义一个org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler，对进入 DispatcherServlet 的 URL 进行筛查，静态资源由 Web 服务器默认的Servlet 处理，非静态资源的请求，由 DispatcherServlet 处理\n一般Web应用服务器默认的Servlet名称是\u0026quot;default\u0026rdquo;，因此DefaultServletHttpRequestHandler可以找到它。如果你所有的Web应用服务器的默认Servlet名称不是\u0026quot;default\u0026quot;，则需要通过default-servlet-name属性显示指定：\n\u0026lt;mvc:default-servlet-handler default-servlet-name=\u0026ldquo;所使用的Web服务器默认使用的Servlet名称\u0026rdquo; /\u0026gt;\n ","date":"2021-10-21T20:07:06+08:00","permalink":"https://example.com/p/springmvc%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%BF%87%E6%BB%A4/","title":"SpringMvc静态资源过滤"},{"content":"java中的date 1、java.sql.date   格式为``2016-02-01` 是针对SQL语句使用的，它只包含日期而没有时间部分 一般是在数据库的时间字段   2、java.util.date   格式为 Wed Oct 20 15:02:35 CST 2021 在除SQL语句外的情况下面使用 一般是日常日期字段   sqlDate和UtilDate 1、java.util.Date 是 java.sql.Date 的父类 2、相互转化 java.sql.Date sqlDate=new Java.sql.Date(); java.util.Date utilDate=new java.util.Date (sqlDate.getTime()); 3、继承关系  java.lang.Object -\u0026gt; java.util.Date -\u0026gt; java.sql.Date\n 4、 使用环境   java.sql.Date主要是用于sql中！ java.util.Date一般的环境下都可以使用！    5、转化 SimpleDateFormat bartDateFormat = new SimpleDateFormat(\u0026#34;yyyy-MM-dd\u0026#34;); String dateStringToParse = \u0026#34;2007-7-12\u0026#34;; //utilDate to sqlDate  try { //使用符合格式的字符串构建一个utilDate  java.util.Date utilDate = bartDateFormat.parse(dateStringToParse); //utilDate.getTime()获取时间戳并构建一个sqlDate  java.sql.Date sqlDate = new java.sql.Date(date.getTime()); System.out.println(sqlDate.getTime()); }catch (Exception ex) { System.out.println(ex.getMessage()); } //反之依然 ps：所有时间日期都可以被SimpleDateFormat格式化format()\n其他时间类格式   java.util.Date 是 年-月-日 時:分:秒.毫秒 java.sql.Date 是 年-月-日 java.sql.Time 是 時:分:秒 java.sql.Timestamp 是 年-月-日 時:分:秒   ","date":"2021-10-19T21:16:55+08:00","permalink":"https://example.com/p/java%E4%B8%AD%E7%9A%84date%E5%92%8Cmysql%E4%B8%AD%E7%9A%84datetime/","title":"Java中的Date和Mysql中的datetime"},{"content":"根报错 Cause: com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure org.apache.ibatis.exceptions.PersistenceException: ### Error querying database. Cause: com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure The last packet successfully received from the server was 128 milliseconds ago. The last packet sent successfully to the server was 125 milliseconds ago. ### The error may exist in com/xxgc/mybatis/mapper/MoneyMapper.java (best guess) ### The error may involve com.xxgc.mybatis.mapper.MoneyMapper.selectMoneyAndUser_COUNT ### The error occurred while executing a query ### Cause: com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure The last packet successfully received from the server was 128 milliseconds ago. The last packet sent successfully to the server was 125 milliseconds ago. at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:30) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:153) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:145) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:140) at org.apache.ibatis.binding.MapperMethod.executeForMany(MapperMethod.java:147) at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:80) at org.apache.ibatis.binding.MapperProxy$PlainMethodInvoker.invoke(MapperProxy.java:145) at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:86) at jdk.proxy2/jdk.proxy2.$Proxy21.selectMoneyAndUser(Unknown Source) at com.xxgc.mybatis.test.MyTest.test11(MyTest.java:139) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.base/java.lang.reflect.Method.invoke(Method.java:568) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69) at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33) at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:235) at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:54) Caused by: com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure The last packet successfully received from the server was 128 milliseconds ago. The last packet sent successfully to the server was 125 milliseconds ago. at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77) at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499) at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480) at com.mysql.jdbc.Util.handleNewInstance(Util.java:425) at com.mysql.jdbc.SQLError.createCommunicationsException(SQLError.java:989) at com.mysql.jdbc.ExportControlled.transformSocketToSSLSocket(ExportControlled.java:203) at com.mysql.jdbc.MysqlIO.negotiateSSLConnection(MysqlIO.java:4901) at com.mysql.jdbc.MysqlIO.proceedHandshakeWithPluggableAuthentication(MysqlIO.java:1659) at com.mysql.jdbc.MysqlIO.doHandshake(MysqlIO.java:1226) at com.mysql.jdbc.ConnectionImpl.coreConnect(ConnectionImpl.java:2191) at com.mysql.jdbc.ConnectionImpl.connectOneTryOnly(ConnectionImpl.java:2222) at com.mysql.jdbc.ConnectionImpl.createNewIO(ConnectionImpl.java:2017) at com.mysql.jdbc.ConnectionImpl.\u0026lt;init\u0026gt;(ConnectionImpl.java:779) at com.mysql.jdbc.JDBC4Connection.\u0026lt;init\u0026gt;(JDBC4Connection.java:47) at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77) at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499) at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480) at com.mysql.jdbc.Util.handleNewInstance(Util.java:425) at com.mysql.jdbc.ConnectionImpl.getInstance(ConnectionImpl.java:389) at com.mysql.jdbc.NonRegisteringDriver.connect(NonRegisteringDriver.java:330) at java.sql/java.sql.DriverManager.getConnection(DriverManager.java:681) at java.sql/java.sql.DriverManager.getConnection(DriverManager.java:190) at org.apache.ibatis.datasource.unpooled.UnpooledDataSource.doGetConnection(UnpooledDataSource.java:224) at org.apache.ibatis.datasource.unpooled.UnpooledDataSource.doGetConnection(UnpooledDataSource.java:219) at org.apache.ibatis.datasource.unpooled.UnpooledDataSource.getConnection(UnpooledDataSource.java:95) at org.apache.ibatis.datasource.pooled.PooledDataSource.popConnection(PooledDataSource.java:432) at org.apache.ibatis.datasource.pooled.PooledDataSource.getConnection(PooledDataSource.java:89) at org.apache.ibatis.transaction.jdbc.JdbcTransaction.openConnection(JdbcTransaction.java:139) at org.apache.ibatis.transaction.jdbc.JdbcTransaction.getConnection(JdbcTransaction.java:61) at org.apache.ibatis.executor.BaseExecutor.getConnection(BaseExecutor.java:337) at org.apache.ibatis.executor.SimpleExecutor.prepareStatement(SimpleExecutor.java:86) at org.apache.ibatis.executor.SimpleExecutor.doQuery(SimpleExecutor.java:62) at org.apache.ibatis.executor.BaseExecutor.queryFromDatabase(BaseExecutor.java:325) at org.apache.ibatis.executor.BaseExecutor.query(BaseExecutor.java:156) at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:109) at com.github.pagehelper.util.ExecutorUtil.executeAutoCount(ExecutorUtil.java:169) at com.github.pagehelper.PageInterceptor.count(PageInterceptor.java:178) at com.github.pagehelper.PageInterceptor.intercept(PageInterceptor.java:121) at org.apache.ibatis.plugin.Plugin.invoke(Plugin.java:62) at jdk.proxy2/jdk.proxy2.$Proxy20.query(Unknown Source) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:151) ... 30 more Caused by: javax.net.ssl.SSLHandshakeException: No appropriate protocol (protocol is disabled or cipher suites are inappropriate) at java.base/sun.security.ssl.HandshakeContext.\u0026lt;init\u0026gt;(HandshakeContext.java:172) at java.base/sun.security.ssl.ClientHandshakeContext.\u0026lt;init\u0026gt;(ClientHandshakeContext.java:98) at java.base/sun.security.ssl.TransportContext.kickstart(TransportContext.java:240) at java.base/sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:443) at java.base/sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:421) at com.mysql.jdbc.ExportControlled.transformSocketToSSLSocket(ExportControlled.java:188) ... 67 more  我的MySql版本为5.7，新装的，没有配MySQL SSL，但是连接池链接的时候默认加密了，所以一直连不上。\n解决方案：在配置JDBC链接时把\u0026amp;useSSL=false加上，不使用SSL加密，配置后连接正常，如果安全性较高的数据建议在MySQL端还是把SSL配上。\n ","date":"2021-10-19T19:43:35+08:00","permalink":"https://example.com/p/mybatis%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E5%90%88%E9%9B%86/","title":"Mybatis报错解决合集"},{"content":"jackson maven引入依赖 \u0026lt;!-- object to json Gson是Google所维护，功能全。 JackSon是Spring的御用工具，和Spring无缝集成，提供灵活的定制化开发的注解。 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.13.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; jackson-databind 依赖 jackson-core 和 jackson-annotations，可以只显示地添加jackson-databind依赖，jackson-core 和 jackson-annotations 也随之添加到 Java 项目工程中。\n创建 ObjectMapper Jackson 最常用的 API 就是基于\u0026quot;对象绑定\u0026quot; 的 ObjectMapper：\n ObjectMapper可以从字符串，流或文件中解析JSON，并创建表示已解析的JSON的Java对象。 将JSON解析为Java对象也称为从JSON反序列化Java对象。 ObjectMapper也可以从Java对象创建JSON。 从Java对象生成JSON也称为将Java对象序列化为JSON。 Object映射器可以将JSON解析为自定义的类的对象，也可以解析置JSON树模型的对象。  之所以称为ObjectMapper是因为它将JSON映射到Java对象（反序列化），或者将Java对象映射到JSON（序列化）。\n将 java Object转化为 json 字符串 ObjectMapper objectMapper = new ObjectMapper(); String json = objectMapper.writeValueAsString(要转化为json的对象); System.out.println(json);//打印转化后的json对象 参考\n","date":"2021-10-19T14:48:39+08:00","permalink":"https://example.com/p/jackson/","title":"jackson"},{"content":"优点   索引大大减小了服务器需要扫描的数据量\n  索引可以帮助服务器避免排序和临时表\n  索引可以将随机IO变成顺序IO\n  索引对于InnoDB（对索引支持行级锁）非常重要，因为它可以让查询锁更少的元组。在MySQL5.1和更新的版本中，InnoDB可以在服务器端过滤掉行后就释放锁，但在早期的MySQL版本中，InnoDB直到事务提交时才会解锁。对不需要的元组的加锁，会增加锁的开销，降低并发性。 InnoDB仅对需要访问的元组加锁，而索引能够减少InnoDB访问的元组数。但是只有在存储引擎层过滤掉那些不需要的数据才能达到这种目的。一旦索引不允许InnoDB那样做（即索引达不到过滤的目的），MySQL服务器只能对InnoDB返回的数据进行WHERE操作，此时，已经无法避免对那些元组加锁了。如果查询不能使用索引，MySQL会进行全表扫描，并锁住每一个元组，不管是否真正需要。\n关于InnoDB、索引和锁：InnoDB在二级索引上使用共享锁（读锁），但访问主键索引需要排他锁（写锁）\n  缺点  虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存索引文件。 建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。 如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。 对于非常小的表，大部分情况下简单的全表扫描更高效；  索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句。因此应该只为最经常查询和最经常排序的数据列建立索引。\nMySQL里同一个数据表里的索引总数限制为16个。\n索引的分类 在一个表中，主键索引只能有一个，唯一索引可以有多个。\n 主键索引（PRIMARY KEY）  唯一的标识，主键不可重复，只能有一个列作为主键   唯一索引（UNIQUE KEY）  避免重读的列出现，唯一索引可以重复，多个列都可以标识为唯一索引   常规索引（KEY / INDEX）  默认的，通过index或key关键字来设置   全文索引（FULLTEXT）  在特定的数据库引擎下采用，之前只有MYISAM有 快速定位数据    基础语法\n-- 索引的使用 -- 方式1：在创建表的时候给字段增加索引 -- 方式2：表创建完毕后，增加索引 -- 显示所有的索引信息 SHOWINDEXFROM`student`-- 增加一个全文索引：格式：索引类型 索引名（列名），主键索引只要有索引名就行了 ALTERTABLE`school`.`student`ADDFULLTEXTINDEX`StudentName`(`StudentName`)-- 删除索引 DROPINDEX索引名ON表名-- EXPLAIN分析sql执行的情况 EXPLAINSELECT*FROM`student`;-- 非全文索引 EXPLAINSELECT*FROM`student`WHEREMATCH(`StudentName`)AGAINST(\u0026#39;郭\u0026#39;)-- 通过全文索引进行查找 创建表结构 CREATETABLE`demo`.`users`(`u_id`BIGINT(20)NOTNULLAUTO_INCREMENTCOMMENT\u0026#39;用户id\u0026#39;,`name`VARCHAR(50)NOTNULLDEFAULT\u0026#39;用户昵称\u0026#39;COMMENT\u0026#39;用户昵称\u0026#39;,`email`VARCHAR(50)NOTNULLCOMMENT\u0026#39;用户邮箱\u0026#39;,`phone`VARCHAR(20)NOTNULLCOMMENT\u0026#39;电话号码\u0026#39;,`sex`TINYINT(4)DEFAULT0COMMENT\u0026#39;0男1女\u0026#39;,`password`VARCHAR(100)NOTNULLCOMMENT\u0026#39;密码\u0026#39;,`age`TINYINT(4)DEFAULT0COMMENT\u0026#39;年龄\u0026#39;,`create_time`DATETIMECOMMENT\u0026#39;创建时间\u0026#39;,`update_time`TIMESTAMPNOTNULLDEFAULTCURRENT_TIMESTAMPONUPDATECURRENT_TIMESTAMPCOMMENT\u0026#39;更新时间\u0026#39;,PRIMARYKEY(`u_id`));创建函数添加模拟数据 DELIMITER$$CREATEFUNCTION`demo`.`mock_data`()RETURNSINTBEGIN-- 创建变量为i DECLAREiINT(11)DEFAULT1;WHILEi\u0026lt;1000000DO-- 获取当前系统时间 SELECTCURRENT_TIMESTAMPINTO@time;-- 插入语句 -- CONCAT(a,b) 把a和b两个字符串拼接 -- RAND() 随机数 -- FLOOR() 向下取整 -- UUID() 唯一ID INSERTINTO`users`(`name`,`email`,`phone`,`sex`,`password`,`age`,`create_time`,`update_time`)VALUE(CONCAT(\u0026#39;用户\u0026#39;,i),CONCAT(FLOOR((RAND()*9999)),i,\u0026#39;@qq.com\u0026#39;),CONCAT(\u0026#39;13\u0026#39;,FLOOR(RAND()*999999999)),FLOOR(RAND()*2),UUID(),FLOOR(RAND()*100),@time,@time);SETi=i+1;ENDWHILE;RETURNi;END$$DELIMITER;执行函数 SELECT`mock_data`();执行语句查看耗时 SELECT*FROM`users`WHERENAME=\u0026#34;用户99999\u0026#34;;创建索引 CREATE INDEX 索引名 ON 表(字段)  索引名起名规范 : id_表名_字段名\nCREATEINDEXid_users_nameON`users`(`name`);1.再次执行语句查看耗时 SELECT*FROM`users`WHERE`phone`=\u0026#34;1330039060\u0026#34;;","date":"2021-10-02T11:39:05+08:00","permalink":"https://example.com/p/mysql%E7%B4%A2%E5%BC%95/","title":"Mysql索引"},{"content":"什么是存储过程 是一种在数据库中存储复杂程序，以便外部调用的一种数据库对象 存储过程思想上很简单，就是数据库SQL语言层面的代码封装与重用。\n优点  可封装，并隐藏复杂的商业逻辑。 并可以接受参数，可以有返回值。 存储过程无法使用 SELECT 指令来运行，因为它是子程序，与查看表，数据表或用户定义函数不同。 存储过程可以用在数据检验，强制实行商业逻辑等。  缺点  存储过程，往往定制化于特定的数据库上，因为支持的编程语言不同。当切换到其他厂商的数据库系统时，需要重写原有的存储过程。 存储过程的性能调校与撰写，受限于各种数据库系统。  声明一个存储过程 DELIMITER$$CREATE-- 声明一个储存过程 PROCEDURE 库名.函数名(参数) -- in：这个参数是一个传入值 -- out：这个参数是个返回值 -- outin：表示这个参数既是输入值，也是返回值（使用时需要传入的是变量，而不是一个确切的数值） PROCEDURE`demo`.`myinout`(INidINT,OUTucommINT,INOUTnumberINT)BEGINSETucomm=number;SETnumber=number+100;END$$DELIMITER;SET@number=100;CALLmyinout(1,100,@number);SELECT@number;","date":"2021-09-29T17:06:44+08:00","permalink":"https://example.com/p/mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/","title":"Mysql存储过程"},{"content":"什么是函数？ 函数类似于Java方法，可以传值，也有返回值，配合查询做一些复杂计算。\n创建一个自定义函数 DELIMITER$$CREATE/*函数 库+函数名(参数名 类型)*/FUNCTION`demo`.`usermoney`(numberINT)/*返回值类型(varchar类型需要指定长度)*/RETURNSINT/*开始*/BEGIN/*返回 要执行的sql语句*/RETURN(number*100);/*结束*/END$$DELIMITER;函数的使用 select之后接函数名(参数)，与mysql内置函数使用方法一致\nSELECTusermoney(`u_money`)FROM`users`在函数中创建变量 变量的声明需要放在要执行的sql语句的头部\n/*创建一个变量 使用 DECLARE 关键字*/DECLAREnewmenberVARCHAR(30)DEFAULT\u0026#34;普通用户\u0026#34;;mysql内置常用函数 MySQL 数值型函数    函数名称 作 用     ABS 求绝对值   SQRT 求二次方根   MOD 求余数   CEIL 和 CEILING 两个函数功能相同，都是返回不小于参数的最小整数，即向上取整   FLOOR 向下取整，返回值转化为一个BIGINT   RAND 生成一个0~1之间的随机数，传入整数参数是，用来产生重复序列   ROUND 对所传参数进行四舍五入   SIGN 返回参数的符号   POW 和 POWER 两个函数的功能相同，都是所传参数的次方的结果值   SIN 求正弦值   ASIN 求反正弦值，与函数 SIN 互为反函数   COS 求余弦值   ACOS 求反余弦值，与函数 COS 互为反函数   TAN 求正切值   ATAN 求反正切值，与函数 TAN 互为反函数   COT 求余切值    MySQL 字符串函数    函数名称 作 用     LENGTH 计算字符串长度函数，返回字符串的字节长度   CONCAT 合并字符串函数，返回结果为连接参数产生的字符串，参数可以使一个或多个   INSERT 替换字符串函数   LOWER 将字符串中的字母转换为小写   UPPER 将字符串中的字母转换为大写   LEFT 从左侧字截取符串，返回字符串左边的若干个字符   RIGHT 从右侧字截取符串，返回字符串右边的若干个字符   TRIM 删除字符串左右两侧的空格   REPLACE 字符串替换函数，返回替换后的新字符串   SUBSTRING 截取字符串，返回从指定位置开始的指定长度的字符换   REVERSE 字符串反转（逆序）函数，返回与原始字符串顺序相反的字符串    MySQL 日期和时间函数    函数名称 作 用     CURDATE 和 CURRENT_DATE 两个函数作用相同，返回当前系统的日期值   CURTIME 和 CURRENT_TIME 两个函数作用相同，返回当前系统的时间值   NOW 和 SYSDATE 两个函数作用相同，返回当前系统的日期和时间值   UNIX_TIMESTAMP 获取UNIX时间戳函数，返回一个以 UNIX 时间戳为基础的无符号整数   FROM_UNIXTIME 将 UNIX 时间戳转换为时间格式，与UNIX_TIMESTAMP互为反函数   MONTH 获取指定日期中的月份   MONTHNAME 获取指定日期中的月份英文名称   DAYNAME 获取指定曰期对应的星期几的英文名称   DAYOFWEEK 获取指定日期对应的一周的索引位置值   WEEK 获取指定日期是一年中的第几周，返回值的范围是否为 0〜52 或 1〜53   DAYOFYEAR 获取指定曰期是一年中的第几天，返回值范围是1~366   DAYOFMONTH 获取指定日期是一个月中是第几天，返回值范围是1~31   YEAR 获取年份，返回值范围是 1970〜2069   TIME_TO_SEC 将时间参数转换为秒数   SEC_TO_TIME 将秒数转换为时间，与TIME_TO_SEC 互为反函数   DATE_ADD 和 ADDDATE 两个函数功能相同，都是向日期添加指定的时间间隔   DATE_SUB 和 SUBDATE 两个函数功能相同，都是向日期减去指定的时间间隔   ADDTIME 时间加法运算，在原始时间上添加指定的时间   SUBTIME 时间减法运算，在原始时间上减去指定的时间   DATEDIFF 获取两个日期之间间隔，返回参数 1 减去参数 2 的值   DATE_FORMAT 格式化指定的日期，根据参数返回指定格式的值   WEEKDAY 获取指定日期在一周内的对应的工作日索引    MySQL 聚合函数    函数名称 作用     MAX 查询指定列的最大值   MIN 查询指定列的最小值   COUNT 统计查询结果的行数   SUM 求和，返回指定列的总和   AVG 求平均值，返回指定列数据的平均值    MySQL 流程控制函数    函数名称 作用     IF 判断，流程控制   IFNULL 判断是否为空   CASE 搜索语句    ","date":"2021-09-28T23:11:13+08:00","permalink":"https://example.com/p/mysql%E5%87%BD%E6%95%B0/","title":"Mysql函数"},{"content":"什么是事件？ 是MySQL5.1新增的事件也叫做定时任务，事件调度器,是一组SQL集，用来执行定时任务，跟触发器很像，都是被动执行的，事件由时间触发执行，而触发器是由事件（增删改）触发执行；\n查看事件是否开启  SHOW VARIABLES LIKE 'event_scheduler';\n开启事件:SET GLOBAL event_scheduler = ON/1; SET @@global.event_scheduler = ON/1;\n关闭事件:SET GLOBAL event_scheduler = OFF/0; SET @@global.event_scheduler = OFF/0;\n 查看事件  查看当前所在数据库的事件:\nSHOW EVENTS; SHOW PROCESSLIST; \n查看数据库中所有的事件:\nSELECT * FROM mysql.event;\n 事件的控制  临时关闭/打开事件 ALTER EVENT 事件名 DISABLE/ENABLE; 删除事件 DROP EVENT 事件名;\n 定时执行事件 DELIMITER$$/*创建定时事件*/CREATEEVENT`demo`.`comm`/*指定时间执行*/ONSCHEDULEAT\u0026#39;2021-09-27 16:34:00\u0026#39;/*完成时不保留启用 执行完成之后删除事件*/ONCOMPLETIONNOTPRESERVEENABLEDOBEGINUPDATE`commodity`SET`c_number`=1;END$$DELIMITER;循环执行事件 DELIMITER$$/*创建事件*/CREATEEVENT`demo`.`addmoeny`/*循环执行 间隔时间为1天*/ONSCHEDULEEVERY\u0026#39;1\u0026#39;DAY/*SECOND(秒)*//*循环的开始时间*/STARTS\u0026#39;2021-09-27 00:00:00\u0026#39;/*循环的结束时间*/ENDS\u0026#39;2022-04-29 00:00:00\u0026#39;/*完成时不保留启用*/ONCOMPLETIONNOTPRESERVEENABLE/*开始*/DOBEGINUPDATEmyuserSET`u_money`=`u_money`+10;/*结束*/END$$DELIMITER;","date":"2021-09-27T20:01:36+08:00","permalink":"https://example.com/p/mysql%E4%BA%8B%E4%BB%B6/","title":"Mysql事件"},{"content":"数据库主从异常问题不同步问题 数据库主从异常问题\n场景描述：在使用web功能时发现刚添加的数据在列表中没有展示，或者有时候展示有时候不展示（多个从库时出现）\n如何查找问题：  这时我们已经怀疑可能从库延迟了，我们需要确认下是延迟问题还是同步中断\n我们需要链接到从库执行命令：\nshow slave status\\G\n来查看从库同步情况\n 同步中断问题  如果Slave_IO_Running （负责与主机的io通信）\nSlave_SQL_Running （负责自己的slave mysql进程）\n这两个参数如果有一个是no的，说明同步已经中断了。\n这时我们需要去看Last_Errno(错误码) Last_Error（错误信息），来确定什么原因导致的错误。\n接下来我们可以通过以下命令跳过错误，让同步正常执行\n/*停止同步*/stopslave/*设置跳过错误*/setglobalsql_slave_skip_counter=1;/*开始同步*/startslave 同步延迟问题  当我们发现Master_Log_File参数和Relay_Master_Log_File参数不一致或者Read_Master_Log_Pos和Relay_Log_Pos参数相差很大时，这表明从库延迟了\n  这时我们先确认是主库导致的还是从库自身导致的，我们可以通过查看服务器负载来定位问题，使用命令top和iotop来分别查看cpu和io的使用情况\n  定位到具体服务器后，在数据库中执行show full processlist来查看当前查询语句中执行时间较长的语句，定位后再做优化就可以了，有时可能慢sql已经执行完了，\n  我们使用命令看不到慢sql，那我们就需要到mysql慢日志中去查看最近产生的慢日志，对慢sql进行优化\n ","date":"2021-09-27T19:55:16+08:00","permalink":"https://example.com/p/mysql%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8D%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/","title":"Mysql主从数据库不同步问题"},{"content":"说明： 在项目部署到生产环境时，会有很多不可抗力的因素，数据库会出现崩溃停止运行数据丢失，数据对不上的问题，这个时候就需要两个数据库同步运行，来确保一个数据库崩溃另一个能马上顶上。\n部署步骤： 在windows下部署: 配置文件位于mysql的安装目录下\n在linux下部署: 配置文件位于/etc/my.cnf (不同linux发行版可能会有所不同)\n配置主库    停止主库的mysql进程\nnet stop mysql1\n  配置my.ini文件\n#主数据库端ID号 server_id=1#开启二进制日志 log-bin=mysql-bin#需要复制的数据库名，如果复制多个数据库，重复设置这个选项即可(或者多个库用逗号隔开) #binlog-do-db = db #不需要复制的库，和上项同理 #binlog-ignore-db=mysql #将从服务器从主服务器收到的更新记入到从服务器自己的二进制日志文件中 #log-slave-updates #控制binlog的写入频率。每执行多少次事务写入一次(这个参数性能消耗很大，但可减小MySQL崩溃造成的损失) #sync_binlog = 1 #这个参数一般用在主主同步中，用来错开自增值, 防止键值冲突 #auto_increment_offset = 1 #这个参数一般用在主主同步中，用来错开自增值, 防止键值冲突 #auto_increment_increment = 1 #二进制日志自动删除的天数，默认值为0,表示“没有自动删除”，启动时和二进制日志循环时可能删除 #expire_logs_days = 7 #将函数复制到slave #log_bin_trust_function_creators = 1   保存修改后的配置，重启mysql服务\nnet start mysql\n  登陆到主机的数据库，并建立一个用户给从库连接使用\n允许所有ip连接GRANTREPLICATIONSLAVEON*.*TO\u0026#39;myslave\u0026#39;@\u0026#39;%\u0026#39;IDENTIFIEDBY\u0026#39;123456\u0026#39;;指定ip的做法GRANTREPLICATIONSLAVEON*.*TOmyslave@\u0026#39;192.168.41.0/255.255.255.0\u0026#39;IDENTIFIEDBY\u0026#39;123456\u0026#39;;  myslave是用户名\n  123456密码是用户对应的密码\n  192.168.41.0是ip地址\n    更新数据库权限\nflush privileges;\n  找到File 和 Position 的值\nshow master status\\G;\n   配置从库    停止从库mysql服务\nnet stop mysql\n  配置从库my.ini\nserver_id=2#log-bin = mysql-bin #log-slave-updates #sync_binlog = 0 #log buffer将每秒一次地写入log file中，并且log file的flush(刷到磁盘)操作同时进行。该模式下在事务提交的时候，不会主动触发写入磁盘的操作 #innodb_flush_log_at_trx_commit = 0 #指定slave要复制哪个库 #replicate-do-db = db #MySQL主从复制的时候，当Master和Slave之间的网络中断，但是Master和Slave无法察觉的情况下（比如防火墙或者路由问题）。Slave会等待slave_net_timeout设置的秒数后，才能认为网络出现故障，然后才会重连并且追赶这段时间主库的数据 #slave-net-timeout = 60 #log_bin_trust_function_creators = 1   重启从库mysql服务\nnet start mysql\n  登陆到从库的数据库并执行同步命令\n#执行同步命令，设置主服务器ip，同步账号密码，同步位置 changemastertomaster_host=\u0026#39;ip地址\u0026#39;,master_user=\u0026#39;用户名\u0026#39;,master_password=\u0026#39;密码\u0026#39;,master_log_file=\u0026#39;mysql-bin.主库查看的值\u0026#39;,master_log_pos=主库查询出来的值;#开启同步功能 startslave;#关闭 stopslave;  查看从库状态\nmysql\u0026gt;showslavestatus\\G;***************************1.row***************************Slave_IO_State:WaitingformastertosendeventMaster_Host:10.10.20.111Master_User:accountMaster_Port:3306Connect_Retry:60Master_Log_File:mysql-bin.000033Read_Master_Log_Pos:337523Relay_Log_File:db2-relay-bin.000002Relay_Log_Pos:337686Relay_Master_Log_File:mysql-bin.000033Slave_IO_Running:YesSlave_SQL_Running:YesReplicate_Do_DB:Replicate_Ignore_DB:...Slave_IO_Running及Slave_SQL_Running进程必须正常运行，即Yes状态，否则说明同步失败 若失败查看mysql错误日志中具体报错详情来进行问题定位 最后可以去主服务器上的数据库中创建表或者更新表数据来测试同步\n   ","date":"2021-09-26T21:02:53+08:00","permalink":"https://example.com/p/mysql%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE/","title":"Mysql主从数据库配置"},{"content":"什么是视图？ mysql的视图的5.0.1版本之后开始提供的。 视图（View）是一种虚拟存在的表，并不在数据库中实际存在，视图中的数据会在使用视图时动态生成。\n/*创建视图*/CREATE/*视图算法*//*[ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] 视图定义者 [DEFINER = { user | CURRENT_USER }] sql的安全性 [SQL SECURITY { DEFINER | INVOKER }]*//*数据库+视图名字*/VIEW`demo`.`statisticsview`AS/*要使用哪些数据生成视图*/(SELECTCOUNT(*)ASusers,SUM(`f_quota`)ASflowersFROM`user`,`flowers`WHERE`f_mapping_user`=`u_id`);查询视图 和普通的表查询一样，使用SELECT 即可\nSELECT*FROMstatisticsview","date":"2021-09-26T20:56:53+08:00","permalink":"https://example.com/p/mysql%E8%A7%86%E5%9B%BE/","title":"Mysql视图"},{"content":"事务\n  是什么是事务？ 事务就是一个完整的业务逻辑。\n 举例： 假如张三向李四转账100元。\n​\t1）张三账户扣100元\n​\t2）李四的账户加100元\n以上操作就是一个最小工作单元，要么同时成功要么同时失败，不可拆分。\n   事务支持\n 只有 INSERT DELETE UPDATE 以上三种语句和事务有关系。\n   事务是如何实现同时成功或同时失败？\n   \u0026gt; InnoDB存储引擎；提供一组用来记录事务性活动日志文件。 \u0026gt; \u0026gt; 提交事务： \u0026gt; \u0026gt; ​\t清空事务性活动日志文件，并彻底把数据持久化到表中。 \u0026gt; \u0026gt; 回滚事务： \u0026gt; \u0026gt; ​\t按文件进行回滚操作，并清空事务性活动日志文件。   如何提交事务，回滚事务？\n 提交事务： COMMIT 语句\n回滚事务： ROLLBACK 语句\n关闭默认提交： START TRANSACTION\n   事务包括4个特性\n A：原子性\n​\t说明事务是最小工作单元，不可再分。\nC：一致性\n​\t所有任务要求，在同一事务当中，所有操作必须同时成功，同时失败。\nI：隔离性\n​\tA事务和B事务之间有一定的隔离。\nD：\n​\t持久性 事务结束的一个保障。\n   重点研究事务的隔离性\n A和B事务之间有一道墙，墙可以很厚也可以很薄，墙越厚代表隔离级别越高。\n查询当前事务隔离级别\nSELECT @@tx_isolation\n设置全局事务隔离级别\nSET GLOBAL TRANSACTION ISOLATION LEVEL + 事务隔离级别\n   事务的隔离级别：\n   读未提交：``read uncommitted`。（最低隔离级别）\n什么叫读未提交： 事务A可以读取到事务B未提交的数据。\n问题： 脏读现象\n  读已提交 READ COMMITTED （只能读到提交之后的数据）\n解决的问题： 解决了脏读现象\n存在的问题： 第一次查询数据是三条，第二次查询数据可能是四条。\n不能重复读。 每一次读取的数据都是绝对真实的数据。 oracle数据库的默认隔离级别READ COMMITTED\n  可重复读 REPEATABLE READ 什么是可重复读？\n提交之后也读不到，永远读取的都是开启事务之前的数据。 mysql的默认事务级别 REPEATABLE READ 事务A开启之后，不管多久，每一次在数据A中读取的数据都是一致的。 即使事务B已经将数据修改，事务A读到的数据还是没有改变，这就叫 可重复读。\n问题：\n​\t出现幻影 读取到的数据都是幻象，不够真实。\n  序列化/串行化：``serializable` 这种是最高隔离级别，效率低，但是解决了所有问题。 这种隔离级别表示，事务排队，不能并发。\n优点：每一次读取到的都真实数据。\n缺点：效率太低。\n     ","date":"2021-09-23T14:04:12+08:00","permalink":"https://example.com/p/mysql%E4%BA%8B%E5%8A%A1/","title":"Mysql事务"},{"content":"触发器的概念：\n​\t触发器是一种特殊的存储过程，不同于存储过程，触发器是通过事件触发执行，而不是手动调用执行的。 什么事触发事件？ 触发器（trigger），是指表中内容发生改变（增、删、改）时，系统会自动触发并执行的事件。 作用： 1、可以在触发时，校验或转换数据，保证数据安全。 2、触发器发生错误时，前面用户执行成功的操作会被回滚。 \u0026hellip;\n表结构 CREATEDATABASEdemo;USE`demo`;CREATETABLE`user`(`u_id`BIGINT(18)NOTNULLAUTO_INCREMENTCOMMENT\u0026#39;用户id\u0026#39;,`u_name`VARCHAR(15)NOTNULLCOMMENT\u0026#39;用户名\u0026#39;,`u_sex`CHAR(1)NOTNULLDEFAULT\u0026#39;男\u0026#39;COMMENT\u0026#39;性别\u0026#39;,`u_createtime`DATETIMENOTNULLCOMMENT\u0026#39;创建时间\u0026#39;,`u_eff`INT(1)NOTNULLDEFAULT\u0026#39;1\u0026#39;COMMENT\u0026#39;有效\u0026#39;,PRIMARYKEY(`u_id`))CREATETABLE`flowers`(`f_id`BIGINT(18)NOTNULLAUTO_INCREMENTCOMMENT\u0026#39;花呗表id\u0026#39;,`f_credit_points`INT(4)NOTNULLCOMMENT\u0026#39;信用积分\u0026#39;,`f_quota`INT(5)NOTNULLCOMMENT\u0026#39;花呗额度\u0026#39;,`f_mapping_user`BIGINT(18)NOTNULLCOMMENT\u0026#39;用户id\u0026#39;,PRIMARYKEY(`f_id`))创建触发器 DELIMITER$$/*自定义结束符号*//*创建*/CREATE/*TRIGGER 触发器*//*库名+触发器名*//*BEFORE/AFTER 在sql之前执行还是之后执行*//*INSERT/UPDATE/DELETE触发条件*/TRIGGER`demo`.`userflowers`AFTERINSERT/*作用于哪个表*/ON`demo`.`user`/*每行都受影响，都执行，行级触发器*/FOREACHROWBEGIN/*触发执行的语句*/INSERTINTO`flowers`(`f_credit_points`,`f_quota`,`f_mapping_user`)VALUE(100,1000,new.u_id);END$$DELIMITER;执行语句 INSERTINTO`user`(`u_name`,`u_sex`,`u_createtime`)VALUE(\u0026#34;张三\u0026#34;,\u0026#34;女\u0026#34;,\u0026#34;2021-09-23 09:34:00\u0026#34;);1.   new和old的使用       INSERT 没有old只有new new表示将要插入或者已经插入的数据   UPDATE 既有old也有new old表示更新之前的数据 new表示更新之后的数据   DELETE 没有new只有old old表示删除前或已经被删除的数据    触发器条件使用if elseif else DELIMITER$$CREATETRIGGER`demo`.`userupdate`AFTERUPDATEON`demo`.`user`FOREACHROWBEGIN/*判断是否有效字段变为0*/IFnew.`u_eff`=0THEN/*删除花呗*/DELETEFROM`flowers`WHERE`f_mapping_user`=new.u_id;ELSEIFnew.`u_eff`=1THEN/*添加花呗*/INSERTINTO`flowers`(`f_credit_points`,`f_quota`,`f_mapping_user`)VALUE(100,1000,new.u_id);ELSE/*其它情况*/ENDIF;END$$DELIMITER;变量的使用 DELIMITER$$USE`demo`$$DROPTRIGGER/*!50032 IF EXISTS */`userflowers`$$CREATE/*!50017 DEFINER = \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; */TRIGGER`userflowers`AFTERINSERTON`user`FOREACHROWBEGIN/*触发执行的语句*/INSERTINTO`flowers`(`f_credit_points`,`f_quota`,`f_mapping_user`)VALUE(100,1000,new.u_id);/* 用户变量：以@开始，形式为 @变量名 用户变量只针对当前客户端生效 全局变量：定义方式 set GLOBAL 变量名，或者 set @@global.变量名 对所有客户端生效，但是具有super权限才可以设置全局变量 */SELECTCOUNT(*)FROMUSERINTO@num;UPDATE`statistics`SET`users`=@numWHEREs_id=1;END;$$DELIMITER;","date":"2021-09-23T13:31:02+08:00","permalink":"https://example.com/p/mysql%E8%A7%A6%E5%8F%91%E5%99%A8/","title":"Mysql触发器"},{"content":"AOP  什么是AOP  AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\n Aop在Spring中的作用  提供声明式事务；允许用户自定义切面\n以下名词需要了解下：\n 横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 \u0026hellip;. 切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。 通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。 目标（Target）：被通知对象。 代理（Proxy）：向目标对象应用通知之后创建的对象。 切入点（PointCut）：切面通知 执行的 “地点”的定义。 连接点（JointPoint）：与切入点匹配的执行点。  SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice:\n 前置增强 BeforeAdvice 代表前置增强，因为spring只支持方法级的增强，所以MethodBeforeAdvice 是目前可用前置增强，表示在目标方法执行前实施增强。 后置增强 AfterAdvice 代表后增强，表示目标方法在执行后实施增强 环绕增强 MethodInterceptor 代表环绕增强，表示目标方法执行前后实施增强 异常抛出增强 ThrowsAdvice 代表抛出异常增强，表示目标方法抛出异常后实施增强 引介增强 IntroductionInterceptor 代表引介增强，表示在目标类中添加一些新的方法和属性  即 Aop 在 不改变原有代码的情况下 , 去增加新的功能 .\n 使用Spring实现Aop  【重点】使用AOP织入，需要导入一个依赖包！\n\u0026lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 第一种方式\n通过 Spring API 实现\n首先编写我们的业务接口和实现类\npublic interface UserService { public void add(); public void delete(); public void update(); public void search(); } public class UserServiceImpl implements UserService{ @Override public void add() { System.out.println(\u0026#34;增加用户\u0026#34;); } @Override public void delete() { System.out.println(\u0026#34;删除用户\u0026#34;); } @Override public void update() { System.out.println(\u0026#34;更新用户\u0026#34;); } @Override public void search() { System.out.println(\u0026#34;查询用户\u0026#34;); } } 然后去写我们的增强类 , 我们编写两个 , 一个前置增强 一个后置增强\npublic class Log implements MethodBeforeAdvice { //method : 要执行的目标对象的方法  //objects : 被调用的方法的参数  //Object : 目标对象  @Override public void before(Method method, Object[] objects, Object o) throws Throwable { System.out.println( o.getClass().getName() + \u0026#34;的\u0026#34; + method.getName() + \u0026#34;方法被执行了\u0026#34;); } } public class AfterLog implements AfterReturningAdvice { //returnValue 返回值  //method被调用的方法  //args 被调用的方法的对象的参数  //target 被调用的目标对象  @Override public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable{ System.out.println(\u0026#34;执行了\u0026#34; + target.getClass().getName() +\u0026#34;的\u0026#34;+method.getName()+\u0026#34;方法,\u0026#34; +\u0026#34;返回值：\u0026#34;+returnValue); } } 最后去spring的文件中注册 , 并实现aop切入实现 , 注意导入约束 .\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;!--注册bean--\u0026gt; \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;com.kuang.service.UserServiceImpl\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;log\u0026#34; class=\u0026#34;com.kuang.log.Log\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;afterLog\u0026#34; class=\u0026#34;com.kuang.log.AfterLog\u0026#34;/\u0026gt; \u0026lt;!--aop的配置--\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!--切入点 expression:表达式匹配要执行的方法--\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;pointcut\u0026#34; expression=\u0026#34;execution(* com.kuang.service.UserServiceImpl.*(..))\u0026#34;/\u0026gt; \u0026lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026#34;log\u0026#34; pointcut-ref=\u0026#34;pointcut\u0026#34;/\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026#34;afterLog\u0026#34; pointcut-ref=\u0026#34;pointcut\u0026#34;/\u0026gt; \u0026lt;/aop:config\u0026gt; \u0026lt;/beans\u0026gt; 测试\npublic class MyTest { @Test public void test(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans.xml\u0026#34;); UserService userService = (UserService) context.getBean(\u0026#34;userService\u0026#34;); userService.search(); } } Aop的重要性 : 很重要 . 一定要理解其中的思路 , 主要是思想的理解这一块 .\nSpring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 .\n第二种方式\n自定义类来实现Aop\n目标业务类不变依旧是userServiceImpl\n第一步 : 写我们自己的一个切入类\npublic class DiyPointcut { public void before(){ System.out.println(\u0026#34;---------方法执行前---------\u0026#34;); } public void after(){ System.out.println(\u0026#34;---------方法执行后---------\u0026#34;); } } 去spring中配置\n\u0026lt;!--第二种方式自定义实现--\u0026gt; \u0026lt;!--注册bean--\u0026gt; \u0026lt;bean id=\u0026#34;diy\u0026#34; class=\u0026#34;com.kuang.config.DiyPointcut\u0026#34;/\u0026gt; \u0026lt;!--aop的配置--\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!--第二种方式：使用AOP的标签实现--\u0026gt; \u0026lt;aop:aspect ref=\u0026#34;diy\u0026#34;\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;diyPonitcut\u0026#34; expression=\u0026#34;execution(* com.kuang.service.UserServiceImpl.*(..))\u0026#34;/\u0026gt; \u0026lt;aop:before pointcut-ref=\u0026#34;diyPonitcut\u0026#34; method=\u0026#34;before\u0026#34;/\u0026gt; \u0026lt;aop:after pointcut-ref=\u0026#34;diyPonitcut\u0026#34; method=\u0026#34;after\u0026#34;/\u0026gt; \u0026lt;/aop:aspect\u0026gt; \u0026lt;/aop:config\u0026gt; 测试：\npublic class MyTest { @Test public void test(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans.xml\u0026#34;); UserService userService = (UserService) context.getBean(\u0026#34;userService\u0026#34;); userService.add(); } } 第三种方式\n使用注解实现\n第一步：编写一个注解实现的增强类\npackage com.kuang.config; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.After; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; @Aspect public class AnnotationPointcut { @Before(\u0026#34;execution(* com.kuang.service.UserServiceImpl.*(..))\u0026#34;) public void before(){ System.out.println(\u0026#34;---------方法执行前---------\u0026#34;); } @After(\u0026#34;execution(* com.kuang.service.UserServiceImpl.*(..))\u0026#34;) public void after(){ System.out.println(\u0026#34;---------方法执行后---------\u0026#34;); } @Around(\u0026#34;execution(* com.kuang.service.UserServiceImpl.*(..))\u0026#34;) public void around(ProceedingJoinPoint jp) throws Throwable { System.out.println(\u0026#34;环绕前\u0026#34;); System.out.println(\u0026#34;签名:\u0026#34;+jp.getSignature()); //执行目标方法proceed  Object proceed = jp.proceed(); System.out.println(\u0026#34;环绕后\u0026#34;); System.out.println(proceed); } } 第二步：在Spring配置文件中，注册bean，并增加支持注解的配置\n\u0026lt;!--第三种方式:注解实现--\u0026gt; \u0026lt;bean id=\u0026#34;annotationPointcut\u0026#34; class=\u0026#34;com.kuang.config.AnnotationPointcut\u0026#34;/\u0026gt; \u0026lt;aop:aspectj-autoproxy/\u0026gt; aop:aspectj-autoproxy：说明\n通过aop命名空间的\u0026lt;aop:aspectj-autoproxy /\u0026gt;声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。当然，spring 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工作，但具体实现的细节已经被\u0026lt;aop:aspectj-autoproxy /\u0026gt;隐藏起来了 \u0026lt;aop:aspectj-autoproxy /\u0026gt;有一个proxy-target-class属性，默认为false，表示使用jdk动态代理织入增强，当配为\u0026lt;aop:aspectj-autoproxy poxy-target-class=\u0026#34;true\u0026#34;/\u0026gt;时，表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。 到了这里，AOP的思想和使用相信大家就没问题了！\n","date":"2021-09-11T17:48:58+08:00","permalink":"https://example.com/p/spring07-aop%E4%BD%BF%E7%94%A8/","title":"Spring07 AOP使用"},{"content":"代理模式 为什么要学习代理模式，因为AOP的底层机制就是动态代理！\n代理模式：\n 静态代理 动态代理   静态代理  静态代理角色分析\n  抽象角色 : 一般使用接口或者抽象类来实现\n  真实角色 : 被代理的角色\n  代理角色 : 代理真实角色 ; 代理真实角色后 , 一般会做一些附属的操作 .\n  客户 : 使用代理角色来进行一些操作 .\n  代码实现\nRent . java 即抽象角色\n//抽象角色：租房 public interface Rent { public void rent(); } Host . java 即真实角色\n//真实角色: 房东，房东要出租房子 public class Host implements Rent{ public void rent() { System.out.println(\u0026#34;房屋出租\u0026#34;); } } Proxy . java 即代理角色\n//代理角色：中介 public class Proxy implements Rent { private Host host; public Proxy() { } public Proxy(Host host) { this.host = host; } //租房  public void rent(){ seeHouse(); host.rent(); fare(); } //看房  public void seeHouse(){ System.out.println(\u0026#34;带房客看房\u0026#34;); } //收中介费  public void fare(){ System.out.println(\u0026#34;收中介费\u0026#34;); } } Client . java 即客户\n//客户类，一般客户都会去找代理！ public class Client { public static void main(String[] args) { //房东要租房  Host host = new Host(); //中介帮助房东  Proxy proxy = new Proxy(host); //你去找中介！  proxy.rent(); } } 分析：在这个过程中，你直接接触的就是中介，就如同现实生活中的样子，你看不到房东，但是你依旧租到了房东的房子通过代理，这就是所谓的代理模式，程序源自于生活，所以学编程的人，一般能够更加抽象的看待生活中发生的事情。\n静态代理的好处:\n 可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 . 公共的业务由代理来完成 . 实现了业务的分工 , 公共业务发生扩展时变得更加集中和方便 .  缺点 :\n 类多了 , 多了代理类 , 工作量变大了 . 开发效率降低 .  我们想要静态代理的好处，又不想要静态代理的缺点，所以 , 就有了动态代理 !\n 静态代理再理解  同学们练习完毕后，我们再来举一个例子，巩固大家的学习！\n练习步骤：\n1、创建一个抽象角色，比如咋们平时做的用户业务，抽象起来就是增删改查！\n//抽象角色：增删改查业务 public interface UserService { void add(); void delete(); void update(); void query(); } 2、我们需要一个真实对象来完成这些增删改查操作\n//真实对象，完成增删改查操作的人 public class UserServiceImpl implements UserService { public void add() { System.out.println(\u0026#34;增加了一个用户\u0026#34;); } public void delete() { System.out.println(\u0026#34;删除了一个用户\u0026#34;); } public void update() { System.out.println(\u0026#34;更新了一个用户\u0026#34;); } public void query() { System.out.println(\u0026#34;查询了一个用户\u0026#34;); } } 3、需求来了，现在我们需要增加一个日志功能，怎么实现！\n 思路1 ：在实现类上增加代码 【麻烦！】 思路2：使用代理来做，能够不改变原来的业务情况下，实现此功能就是最好的了！  4、设置一个代理类来处理日志！代理角色\n//代理角色，在这里面增加日志的实现 public class UserServiceProxy implements UserService { private UserServiceImpl userService; public void setUserService(UserServiceImpl userService) { this.userService = userService; } public void add() { log(\u0026#34;add\u0026#34;); userService.add(); } public void delete() { log(\u0026#34;delete\u0026#34;); userService.delete(); } public void update() { log(\u0026#34;update\u0026#34;); userService.update(); } public void query() { log(\u0026#34;query\u0026#34;); userService.query(); } public void log(String msg){ System.out.println(\u0026#34;执行了\u0026#34;+msg+\u0026#34;方法\u0026#34;); } } 5、测试访问类：\npublic class Client { public static void main(String[] args) { //真实业务  UserServiceImpl userService = new UserServiceImpl(); //代理类  UserServiceProxy proxy = new UserServiceProxy(); //使用代理类实现日志功能！  proxy.setUserService(userService); proxy.add(); } } OK，到了现在代理模式大家应该都没有什么问题了，重点大家需要理解其中的思想；\n我们在不改变原来的代码的情况下，实现了对原有功能的增强，这是AOP中最核心的思想.\n 动态代理    动态代理的角色和静态代理的一样 .\n  动态代理的代理类是动态生成的 . 静态代理的代理类是我们提前写好的\n  动态代理分为两类 : 一类是基于接口动态代理 , 一类是基于类的动态代理\n   基于接口的动态代理\u0026mdash;-JDK动态代理 基于类的动态代理\u0026ndash;cglib 现在用的比较多的是 javasist 来生成动态代理 . 百度一下javasist 我们这里使用JDK的原生代码来实现，其余的道理都是一样的！、    JDK的动态代理需要了解两个类\n核心 : InvocationHandler 和 Proxy ， 打开JDK帮助文档看看\n【InvocationHandler：调用处理程序】是由代理实例去调用处理程序的接口，每个代理实例都有一个关联的抵用处理程序\nObject invoke(Object proxy, 方法 method, Object[] args)； //参数 //proxy - 调用该方法的代理实例 //method -所述方法对应于调用代理实例上的接口方法的实例。方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口。 //args -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean 。 【Proxy : 代理】提供了创建动态代理和实例的静态方法，他也就是由这些方法创建的所有动态代理程序的超类，每个代理实例程序都有一个关联的调用处理程序对象，他实现了InvocationHandler接口\n//生成代理类 // 参数1 - Loader 类加载器定义的代理类 // 参数2 - nterfaces 代理类实现的接口列表 // 参数3 - h 调度方法调用的调用处理函数 public Object getProxy(){ return Proxy.newProxyInstance(this.getClass().getClassLoader(),rent.getClass().getInterfaces(),this); } 代码实现\n抽象角色和真实角色和之前的一样！\nRent . java 即抽象角色\n//抽象角色：租房 public interface Rent { public void rent(); } Host . java 即真实角色\n//真实角色: 房东，房东要出租房子 public class Host implements Rent{ public void rent() { System.out.println(\u0026#34;房屋出租\u0026#34;); } } ProxyInvocationHandler. java 即代理角色\npublic class ProxyInvocationHandler implements InvocationHandler { private Rent rent; public void setRent(Rent rent) { this.rent = rent; } //生成代理类，重点是第二个参数，获取要代理的抽象角色！之前都是一个角色，现在可以代理一类角色  public Object getProxy(){ return Proxy.newProxyInstance(this.getClass().getClassLoader(), rent.getClass().getInterfaces(),this); } // proxy : 代理类 method : 代理类的调用处理程序的方法对象.  // 处理代理实例上的方法调用并返回结果  @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { seeHouse(); //核心：本质利用反射实现！  Object result = method.invoke(rent, args); fare(); return result; } //看房  public void seeHouse(){ System.out.println(\u0026#34;带房客看房\u0026#34;); } //收中介费  public void fare(){ System.out.println(\u0026#34;收中介费\u0026#34;); } } Client . java\n//租客 public class Client { public static void main(String[] args) { //真实角色  Host host = new Host(); //代理实例的调用处理程序  ProxyInvocationHandler pih = new ProxyInvocationHandler(); pih.setRent(host); //将真实角色放置进去！  Rent proxy = (Rent)pih.getProxy(); //动态生成对应的代理类！  proxy.rent(); } } 核心：一个动态代理 , 一般代理某一类业务 , 一个动态代理可以代理多个类，代理的是接口！、\n 深化理解  我们来使用动态代理实现代理我们后面写的UserService！\n我们也可以编写一个通用的动态代理实现的类！所有的代理对象设置为Object即可！\npublic class ProxyInvocationHandler implements InvocationHandler { private Object target; public void setTarget(Object target) { this.target = target; } //生成代理类  public Object getProxy(){ return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(),this); } // proxy : 代理类  // method : 代理类的调用处理程序的方法对象.  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { log(method.getName()); Object result = method.invoke(target, args); return result; } public void log(String methodName){ System.out.println(\u0026#34;执行了\u0026#34;+methodName+\u0026#34;方法\u0026#34;); } } 测试！\npublic class Test { public static void main(String[] args) { //真实对象  UserServiceImpl userService = new UserServiceImpl(); //代理对象的调用处理程序  ProxyInvocationHandler pih = new ProxyInvocationHandler(); pih.setTarget(userService); //设置要代理的对象  UserService proxy = (UserService)pih.getProxy(); //动态生成代理类！  proxy.delete(); } } 测试，增删改查，查看结果！\n 动态代理的好处  静态代理有的它都有，静态代理没有的，它也有！\n 可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 . 公共的业务由代理来完成 . 实现了业务的分工 , 公共业务发生扩展时变得更加集中和方便 . 一个动态代理 , 一般代理某一类业务 一个动态代理可以代理多个类，代理的是接口！  ","date":"2021-09-11T17:48:54+08:00","permalink":"https://example.com/p/spring06-%E5%8A%A8/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/","title":"Spring06 动/静态代理"},{"content":"使用注解开发  说明  在spring4之后，想要使用注解形式，必须得要引入aop的包\n`spring-aop\n在配置文件当中，还得要引入一个context约束\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;/beans\u0026gt;  Bean的实现  我们之前都是使用 bean 的标签进行bean注入，但是实际开发中，我们一般都会使用注解！\n1、配置扫描哪些包下的注解\n\u0026lt;!--指定注解扫描包--\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.kuang.pojo\u0026#34;/\u0026gt; 2、在指定包下编写类，增加注解\n@Component(\u0026#34;user\u0026#34;) // 相当于配置文件中 \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;当前注解的类\u0026#34;/\u0026gt; public class User { public String name = \u0026#34;秦疆\u0026#34;; } 3、测试\n@Test public void test(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\u0026#34;beans.xml\u0026#34;); User user = (User) applicationContext.getBean(\u0026#34;user\u0026#34;); System.out.println(user.name); }  属性注入  使用注解注入属性\n1、可以不用提供set方法，直接在直接名上添加@value(\u0026ldquo;值\u0026rdquo;)\n@Component(\u0026#34;user\u0026#34;) // 相当于配置文件中 \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;当前注解的类\u0026#34;/\u0026gt; public class User { @Value(\u0026#34;秦疆\u0026#34;) // 相当于配置文件中 \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;秦疆\u0026#34;/\u0026gt;  public String name; } 2、如果提供了set方法，在set方法上添加@value(\u0026ldquo;值\u0026rdquo;);\n@Component(\u0026#34;user\u0026#34;) public class User { public String name; @Value(\u0026#34;秦疆\u0026#34;) public void setName(String name) { this.name = name; } }  衍生注解  我们这些注解，就是替代了在配置文件当中配置步骤而已！更加的方便快捷！\n@Component三个衍生注解\n为了更好的进行分层，Spring可以使用其它三个注解，功能一样，目前使用哪一个功能都一样。\n @Controller：web层 @Service：service层 @Repository：dao层  写上这些注解，就相当于将这个类交给Spring管理装配了！\n 自动装配注解  在Bean的自动装配已经讲过了，可以回顾！\n 作用域  @scope\n singleton：默认的，Spring会采用单例模式创建这个对象。关闭工厂 ，所有的对象都会销毁。 prototype：多例模式。关闭工厂 ，所有的对象不会销毁。内部的垃圾回收机制会回收  @Controller(\u0026#34;user\u0026#34;) @Scope(\u0026#34;prototype\u0026#34;) public class User { @Value(\u0026#34;秦疆\u0026#34;) public String name; }  小结  XML与注解比较\n XML可以适用任何场景 ，结构清晰，维护方便 注解不是自己提供的类使用不了，开发简单方便  xml与注解整合开发 ：推荐最佳实践\n xml管理Bean 注解完成属性注入 使用过程中， 可以不用扫描，扫描是为了类上的注解  \u0026lt;context:annotation-config/\u0026gt; 作用：\n  进行注解驱动注册，从而使注解生效\n  用于激活那些已经在spring容器里注册过的bean上面的注解，也就是显示的向Spring注册\n  如果不扫描包，就需要手动配置bean\n  如果不加注解驱动，则注入的值为null！\n   基于Java类进行配置  JavaConfig 原来是 Spring 的一个子项目，它通过 Java 类的方式提供 Bean 的定义信息，在 Spring4 的版本， JavaConfig 已正式成为 Spring4 的核心功能 。\n测试：\n1、编写一个实体类，Dog\n@Component //将这个类标注为Spring的一个组件，放到容器中！ public class Dog { public String name = \u0026#34;dog\u0026#34;; } 2、新建一个config配置包，编写一个MyConfig配置类\n@Configuration //代表这是一个配置类 public class MyConfig { @Bean //通过方法注册一个bean，这里的返回值就Bean的类型，方法名就是bean的id！  public Dog dog(){ return new Dog(); } } 3、测试\n@Test public void test2(){ ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MyConfig.class); Dog dog = (Dog) applicationContext.getBean(\u0026#34;dog\u0026#34;); System.out.println(dog.name); } 4、成功输出结果！\n导入其他配置如何做呢？\n1、我们再编写一个配置类！\n@Configuration //代表这是一个配置类 public class MyConfig2 { } 2、在之前的配置类中我们来选择导入这个配置类\n@Configuration @Import(MyConfig2.class) //导入合并其他配置类，类似于配置文件中的 inculde 标签 public class MyConfig { @Bean public Dog dog(){ return new Dog(); } } 关于这种Java类的配置方式，我们在之后的SpringBoot 和 SpringCloud中还会大量看到，我们需要知道这些注解的作用即可！\n","date":"2021-09-11T17:48:51+08:00","permalink":"https://example.com/p/spring05-%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/","title":"Spring05 使用注解开发"},{"content":"Bean的自动装配  自动装配说明   自动装配是使用spring满足bean依赖的一种方法 spring会在应用上下文中为某个bean寻找其依赖的bean。  Spring中bean有三种装配机制，分别是：\n 在xml中显式配置； 在java中显式配置； 隐式的bean发现机制和自动装配。  这里我们主要讲第三种：自动化的装配bean。\nSpring的自动装配需要从两个角度来实现，或者说是两个操作：\n 组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean； 自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC/DI；  组件扫描和自动装配组合发挥巨大威力，使得显示的配置降低到最少。\n**不推荐使用xml配置 , 而使用注解 **\n 测试环境搭建  1、新建一个项目\n2、新建两个实体类，Cat Dog 都有一个叫的方法\npublic class Cat { public void shout() { System.out.println(\u0026#34;miao~\u0026#34;); } } public class Dog { public void shout() { System.out.println(\u0026#34;wang~\u0026#34;); } } 3、新建一个用户类 User\npublic class User { private Cat cat; private Dog dog; private String str; } 4、编写Spring配置文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;dog\u0026#34; class=\u0026#34;com.kuang.pojo.Dog\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;cat\u0026#34; class=\u0026#34;com.kuang.pojo.Cat\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.kuang.pojo.User\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;cat\u0026#34; ref=\u0026#34;cat\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;dog\u0026#34; ref=\u0026#34;dog\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;str\u0026#34; value=\u0026#34;qinjiang\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 5、测试\npublic class MyTest { @Test public void testMethodAutowire() { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans.xml\u0026#34;); User user = (User) context.getBean(\u0026#34;user\u0026#34;); user.getCat().shout(); user.getDog().shout(); } } 结果正常输出，环境OK\n byName  autowire byName (按名称自动装配)\n由于在手动配置xml过程中，常常发生字母缺漏和大小写等错误，而无法对其进行检查，使得开发效率降低。\n采用自动装配将避免这些错误，并且使配置简单化。\n测试：\n1、修改bean配置，增加一个属性 autowire=\u0026ldquo;byName\u0026rdquo;\n\u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.kuang.pojo.User\u0026#34; autowire=\u0026#34;byName\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;str\u0026#34; value=\u0026#34;qinjiang\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 2、再次测试，结果依旧成功输出！\n3、我们将 cat 的bean id修改为 catXXX\n4、再次测试， 执行时报空指针java.lang.NullPointerException。因为按byName规则找不对应set方法，真正的setCat就没执行，对象就没有初始化，所以调用时就会报空指针错误。\n小结：\n当一个bean节点带有 autowire byName的属性时。\n  将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。\n  去spring容器中寻找是否有此字符串名称id的对象。\n  如果有，就取出注入；如果没有，就报空指针异常。\n   byType  autowire byType (按类型自动装配)\n使用autowire byType首先需要保证：同一类型的对象，在spring容器中唯一。如果不唯一，会报不唯一的异常。\nNoUniqueBeanDefinitionException 测试：\n1、将user的bean配置修改一下 ： autowire=\u0026ldquo;byType\u0026rdquo;\n2、测试，正常输出\n3、在注册一个cat 的bean对象！\n\u0026lt;bean id=\u0026#34;dog\u0026#34; class=\u0026#34;com.kuang.pojo.Dog\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;cat\u0026#34; class=\u0026#34;com.kuang.pojo.Cat\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;cat2\u0026#34; class=\u0026#34;com.kuang.pojo.Cat\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.kuang.pojo.User\u0026#34; autowire=\u0026#34;byType\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;str\u0026#34; value=\u0026#34;qinjiang\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 4、测试，报错：NoUniqueBeanDefinitionException\n5、删掉cat2，将cat的bean名称改掉！测试！因为是按类型装配，所以并不会报异常，也不影响最后的结果。甚至将id属性去掉，也不影响结果。\n这就是按照类型自动装配！\n使用注解\n 使用注解  jdk1.5开始支持注解，spring2.5开始全面支持注解。\n准备工作：利用注解的方式注入属性。\n1、在spring配置文件中引入context文件头\nxmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd 2、开启属性注解支持！\n\u0026lt;context:annotation-config/\u0026gt; @Autowired  @Autowired是按类型自动转配的，不支持id匹配。 需要导入 spring-aop的包！  测试：\n1、将User类中的set方法去掉，使用@Autowired注解\npublic class User { @Autowired private Cat cat; @Autowired private Dog dog; private String str; public Cat getCat() { return cat; } public Dog getDog() { return dog; } public String getStr() { return str; } } 2、此时配置文件内容\n\u0026lt;context:annotation-config/\u0026gt; \u0026lt;bean id=\u0026#34;dog\u0026#34; class=\u0026#34;com.kuang.pojo.Dog\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;cat\u0026#34; class=\u0026#34;com.kuang.pojo.Cat\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.kuang.pojo.User\u0026#34;/\u0026gt; 3、测试，成功输出结果！\n【小狂神科普时间】\n@Autowired(required=false) 说明：false，对象可以为null；true，对象必须存对象，不能为null。\n//如果允许对象为null，设置required = false,默认为true @Autowired(required = false) private Cat cat; @Qualifier  @Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配 @Qualifier不能单独使用。  测试实验步骤：\n1、配置文件修改内容，保证类型存在对象。且名字不为类的默认名字！\n\u0026lt;bean id=\u0026#34;dog1\u0026#34; class=\u0026#34;com.kuang.pojo.Dog\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;dog2\u0026#34; class=\u0026#34;com.kuang.pojo.Dog\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;cat1\u0026#34; class=\u0026#34;com.kuang.pojo.Cat\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;cat2\u0026#34; class=\u0026#34;com.kuang.pojo.Cat\u0026#34;/\u0026gt; 2、没有加Qualifier测试，直接报错\n3、在属性上添加Qualifier注解\n@Autowired @Qualifier(value = \u0026#34;cat2\u0026#34;) private Cat cat; @Autowired @Qualifier(value = \u0026#34;dog2\u0026#34;) private Dog dog; 测试，成功输出！\n@Resource  @Resource如有指定的name属性，先按该属性进行byName方式查找装配； 其次再进行默认的byName方式进行装配； 如果以上都不成功，则按byType的方式自动装配。 都不成功，则报异常。  实体类：\npublic class User { //如果允许对象为null，设置required = false,默认为true  @Resource(name = \u0026#34;cat2\u0026#34;) private Cat cat; @Resource private Dog dog; private String str; } beans.xml\n\u0026lt;bean id=\u0026#34;dog\u0026#34; class=\u0026#34;com.kuang.pojo.Dog\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;cat1\u0026#34; class=\u0026#34;com.kuang.pojo.Cat\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;cat2\u0026#34; class=\u0026#34;com.kuang.pojo.Cat\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.kuang.pojo.User\u0026#34;/\u0026gt; 测试：结果OK\n配置文件2：beans.xml ， 删掉cat2\n\u0026lt;bean id=\u0026#34;dog\u0026#34; class=\u0026#34;com.kuang.pojo.Dog\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;cat1\u0026#34; class=\u0026#34;com.kuang.pojo.Cat\u0026#34;/\u0026gt; 实体类上只保留注解\n@Resource private Cat cat; @Resource private Dog dog; 结果：OK\n结论：先进行byName查找，失败；再进行byType查找，成功。\n小结 @Autowired与@Resource异同：\n1、@Autowired与@Resource都可以用来装配bean。都可以写在字段上，或写在setter方法上。\n2、@Autowired默认按类型装配（属于spring规范），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用\n3、@Resource（属于J2EE复返），默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。\n它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired先byType，@Resource先byName。\n","date":"2021-09-11T17:48:33+08:00","permalink":"https://example.com/p/spring04-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/","title":"Spring04 自动装配"},{"content":"Dependency Injection  概念   依赖注入（Dependency Injection,DI）。 依赖 : 指Bean对象的创建依赖于容器 . Bean对象的依赖资源 . 注入 : 指Bean对象所依赖的资源 , 由容器来设置和装配 .   构造器注入  我们在之前的案例已经讲过了\n Set 注入 （重点）  要求被注入的属性 , 必须有set方法 , set方法的方法名由set + 属性首字母大写 , 如果属性是boolean类型 , 没有set方法 , 是 is .\n测试pojo类 :\nAddress.java\npublic class Address { private String address; public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } } Student.java\npackage com.kuang.pojo; import java.util.List; import java.util.Map; import java.util.Properties; import java.util.Set; public class Student { private String name; private Address address; private String[] books; private List\u0026lt;String\u0026gt; hobbys; private Map\u0026lt;String,String\u0026gt; card; private Set\u0026lt;String\u0026gt; games; private String wife; private Properties info; public void setName(String name) { this.name = name; } public void setAddress(Address address) { this.address = address; } public void setBooks(String[] books) { this.books = books; } public void setHobbys(List\u0026lt;String\u0026gt; hobbys) { this.hobbys = hobbys; } public void setCard(Map\u0026lt;String, String\u0026gt; card) { this.card = card; } public void setGames(Set\u0026lt;String\u0026gt; games) { this.games = games; } public void setWife(String wife) { this.wife = wife; } public void setInfo(Properties info) { this.info = info; } public void show(){ System.out.println(\u0026#34;name=\u0026#34;+ name + \u0026#34;,address=\u0026#34;+ address.getAddress() + \u0026#34;,books=\u0026#34; ); for (String book:books){ System.out.print(\u0026#34;\u0026lt;\u0026lt;\u0026#34;+book+\u0026#34;\u0026gt;\u0026gt;\\t\u0026#34;); } System.out.println(\u0026#34;\\n爱好:\u0026#34;+hobbys); System.out.println(\u0026#34;card:\u0026#34;+card); System.out.println(\u0026#34;games:\u0026#34;+games); System.out.println(\u0026#34;wife:\u0026#34;+wife); System.out.println(\u0026#34;info:\u0026#34;+info); } } 1、常量注入\n\u0026lt;bean id=\u0026#34;student\u0026#34; class=\u0026#34;com.kuang.pojo.Student\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;小明\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 测试：\n@Test public void test01(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); Student student = (Student) context.getBean(\u0026#34;student\u0026#34;); System.out.println(student.getName()); } 2、Bean注入\n注意点：这里的值是一个引用，ref\n\u0026lt;bean id=\u0026#34;addr\u0026#34; class=\u0026#34;com.kuang.pojo.Address\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;address\u0026#34; value=\u0026#34;重庆\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;student\u0026#34; class=\u0026#34;com.kuang.pojo.Student\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;小明\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;address\u0026#34; ref=\u0026#34;addr\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 3、数组注入\n\u0026lt;bean id=\u0026#34;student\u0026#34; class=\u0026#34;com.kuang.pojo.Student\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;小明\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;address\u0026#34; ref=\u0026#34;addr\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;books\u0026#34;\u0026gt; \u0026lt;array\u0026gt; \u0026lt;value\u0026gt;西游记\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;红楼梦\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;水浒传\u0026lt;/value\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 4、List注入\n\u0026lt;property name=\u0026#34;hobbys\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;听歌\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;看电影\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;爬山\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; 5、Map注入\n\u0026lt;property name=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026#34;中国邮政\u0026#34; value=\u0026#34;456456456465456\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;建设\u0026#34; value=\u0026#34;1456682255511\u0026#34;/\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; 6、set注入\n\u0026lt;property name=\u0026#34;games\u0026#34;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;value\u0026gt;LOL\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;BOB\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;COC\u0026lt;/value\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt; 7、Null注入\n\u0026lt;property name=\u0026#34;wife\u0026#34;\u0026gt;\u0026lt;null/\u0026gt;\u0026lt;/property\u0026gt; 8、Properties注入\n\u0026lt;property name=\u0026#34;info\u0026#34;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026#34;学号\u0026#34;\u0026gt;20190604\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;性别\u0026#34;\u0026gt;男\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;姓名\u0026#34;\u0026gt;小明\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt;  p命名和c命名注入  User.java ：【注意：这里没有有参构造器！】\npublic class User { private String name; private int age; public void setName(String name) { this.name = name; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } 1、P命名空间注入 : 需要在头文件中加入约束文件\n导入约束 : xmlns:p=\u0026#34;http://www.springframework.org/schema/p\u0026#34; \u0026lt;!--P(属性: properties)命名空间 , 属性依然要设置set方法--\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.kuang.pojo.User\u0026#34; p:name=\u0026#34;狂神\u0026#34; p:age=\u0026#34;18\u0026#34;/\u0026gt; 2、c 命名空间注入 : 需要在头文件中加入约束文件\n导入约束 : xmlns:c=\u0026#34;http://www.springframework.org/schema/c\u0026#34; \u0026lt;!--C(构造: Constructor)命名空间 , 属性依然要设置set方法--\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.kuang.pojo.User\u0026#34; c:name=\u0026#34;狂神\u0026#34; c:age=\u0026#34;18\u0026#34;/\u0026gt; 发现问题：爆红了，刚才我们没有写有参构造！\n解决：把有参构造器加上，这里也能知道，c 就是所谓的构造器注入！\n测试代码：\n@Test public void test02(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); User user = (User) context.getBean(\u0026#34;user\u0026#34;); System.out.println(user); }  Bean的作用域  在Spring中，那些组成应用程序的主体及由Spring IoC容器所管理的对象，被称之为bean。简单地讲，bean就是由IoC容器初始化、装配及管理的对象 .\nSingleton 当一个bean的作用域为Singleton，那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。注意，Singleton作用域是Spring中的缺省作用域。要在XML中将bean定义成singleton，可以这样配置：\n\u0026lt;bean id=\u0026#34;ServiceImpl\u0026#34; class=\u0026#34;cn.csdn.service.ServiceImpl\u0026#34; scope=\u0026#34;singleton\u0026#34;\u0026gt; 测试：\n@Test public void test03(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); User user = (User) context.getBean(\u0026#34;user\u0026#34;); User user2 = (User) context.getBean(\u0026#34;user\u0026#34;); System.out.println(user==user2); } Prototype 当一个bean的作用域为Prototype，表示一个bean定义对应多个对象实例。Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。在XML中将bean定义成prototype，可以这样配置：\n\u0026lt;bean id=\u0026#34;account\u0026#34; class=\u0026#34;com.foo.DefaultAccount\u0026#34; scope=\u0026#34;prototype\u0026#34;/\u0026gt; 或者 \u0026lt;bean id=\u0026#34;account\u0026#34; class=\u0026#34;com.foo.DefaultAccount\u0026#34; singleton=\u0026#34;false\u0026#34;/\u0026gt; Request 当一个bean的作用域为Request，表示在一次HTTP请求中，一个bean定义对应一个实例；即每个HTTP请求都会有各自的bean实例，它们依据某个bean定义创建而成。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：\n\u0026lt;bean id=\u0026#34;loginAction\u0026#34; class=cn.csdn.LoginAction\u0026#34; scope=\u0026#34;request\u0026#34;/\u0026gt; 针对每次HTTP请求，Spring容器会根据loginAction bean的定义创建一个全新的LoginAction bean实例，且该loginAction bean实例仅在当前HTTP request内有效，因此可以根据需要放心的更改所建实例的内部状态，而其他请求中根据loginAction bean定义创建的实例，将不会看到这些特定于某个请求的状态变化。当处理请求结束，request作用域的bean实例将被销毁。\nSession 当一个bean的作用域为Session，表示在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：\n\u0026lt;bean id=\u0026#34;userPreferences\u0026#34; class=\u0026#34;com.foo.UserPreferences\u0026#34; scope=\u0026#34;session\u0026#34;/\u0026gt; 针对某个HTTP Session，Spring容器会根据userPreferences bean定义创建一个全新的userPreferences bean实例，且该userPreferences bean仅在当前HTTP Session内有效。与request作用域一样，可以根据需要放心的更改所创建实例的内部状态，而别的HTTP Session中根据userPreferences创建的实例，将不会看到这些特定于某个HTTP Session的状态变化。当HTTP Session最终被废弃的时候，在该HTTP Session作用域内的bean也会被废弃掉。\n几种作用域中，request、session作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架），只能用在基于web的Spring ApplicationContext环境。\n","date":"2021-09-11T17:41:44+08:00","permalink":"https://example.com/p/spring03-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5di/","title":"Spring03 依赖注入(DI)"},{"content":"HelloSpring  导入Jar包  注 : spring 需要导入commons-logging进行日志记录 . 我们利用maven , 他会自动下载对应的依赖项 .\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.10.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  编写代码  1、编写一个Hello实体类\npublic class Hello { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } public void show(){ System.out.println(\u0026#34;Hello,\u0026#34;+ name ); } } 2、编写我们的spring文件 , 这里我们命名为beans.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!--bean就是java对象 , 由Spring创建和管理--\u0026gt; \u0026lt;bean id=\u0026#34;hello\u0026#34; class=\u0026#34;com.kuang.pojo.Hello\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;Spring\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 3、我们可以去进行测试了 .\n@Test public void test(){ //解析beans.xml文件 , 生成管理相应的Bean对象  ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans.xml\u0026#34;); //getBean : 参数即为spring配置文件中bean的id .  Hello hello = (Hello) context.getBean(\u0026#34;hello\u0026#34;); hello.show(); }  思考   Hello 对象是谁创建的 ? 【hello 对象是由Spring创建的 Hello 对象的属性是怎么设置的 ? hello 对象的属性是由Spring容器设置的  这个过程就叫控制反转 :\n 控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的 反转 : 程序本身不创建对象 , 而变成被动的接收对象 .  依赖注入 : 就是利用set方法来进行注入的.\nIOC是一种编程思想，由主动的编程变成被动的接收\n可以通过newClassPathXmlApplicationContext去浏览一下底层源码 .\n 修改案例一  我们在案例一中， 新增一个Spring配置文件beans.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;MysqlImpl\u0026#34; class=\u0026#34;com.kuang.dao.impl.UserDaoMySqlImpl\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;OracleImpl\u0026#34; class=\u0026#34;com.kuang.dao.impl.UserDaoOracleImpl\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;ServiceImpl\u0026#34; class=\u0026#34;com.kuang.service.impl.UserServiceImpl\u0026#34;\u0026gt; \u0026lt;!--注意: 这里的name并不是属性 , 而是set方法后面的那部分 , 首字母小写--\u0026gt; \u0026lt;!--引用另外一个bean , 不是用value 而是用 ref--\u0026gt; \u0026lt;property name=\u0026#34;userDao\u0026#34; ref=\u0026#34;OracleImpl\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 测试！\n@Test public void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans.xml\u0026#34;); UserServiceImpl serviceImpl = (UserServiceImpl) context.getBean(\u0026#34;ServiceImpl\u0026#34;); serviceImpl.getUser(); } OK , 到了现在 , 我们彻底不用再程序中去改动了 , 要实现不同的操作 , 只需要在xml配置文件中进行修改 , 所谓的IoC,一句话搞定 : 对象由Spring 来创建 , 管理 , 装配 !\nIOC创建对象方式  通过无参构造方法来创建  1、User.java\npublic class User { private String name; public User() { System.out.println(\u0026#34;user无参构造方法\u0026#34;); } public void setName(String name) { this.name = name; } public void show(){ System.out.println(\u0026#34;name=\u0026#34;+ name ); } } 2、beans.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.kuang.pojo.User\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;kuangshen\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 3、测试类\n@Test public void test(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans.xml\u0026#34;); //在执行getBean的时候, user已经创建好了 , 通过无参构造  User user = (User) context.getBean(\u0026#34;user\u0026#34;); //调用对象的方法 .  user.show(); } 结果可以发现，在调用show方法之前，User对象已经通过无参构造初始化了！\n 通过有参构造方法来创建  1、UserT . java\npublic class UserT { private String name; public UserT(String name) { this.name = name; } public void setName(String name) { this.name = name; } public void show(){ System.out.println(\u0026#34;name=\u0026#34;+ name ); } } 2、beans.xml 有三种方式编写\n\u0026lt;!-- 第一种根据index参数下标设置 --\u0026gt; \u0026lt;bean id=\u0026#34;userT\u0026#34; class=\u0026#34;com.kuang.pojo.UserT\u0026#34;\u0026gt; \u0026lt;!-- index指构造方法 , 下标从0开始 --\u0026gt; \u0026lt;constructor-arg index=\u0026#34;0\u0026#34; value=\u0026#34;kuangshen2\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 第二种根据参数名字设置 --\u0026gt; \u0026lt;bean id=\u0026#34;userT\u0026#34; class=\u0026#34;com.kuang.pojo.UserT\u0026#34;\u0026gt; \u0026lt;!-- name指参数名 --\u0026gt; \u0026lt;constructor-arg name=\u0026#34;name\u0026#34; value=\u0026#34;kuangshen2\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 第三种根据参数类型设置 --\u0026gt; \u0026lt;bean id=\u0026#34;userT\u0026#34; class=\u0026#34;com.kuang.pojo.UserT\u0026#34;\u0026gt; \u0026lt;constructor-arg type=\u0026#34;java.lang.String\u0026#34; value=\u0026#34;kuangshen2\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 3、测试\n@Test public void testT(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans.xml\u0026#34;); UserT user = (UserT) context.getBean(\u0026#34;userT\u0026#34;); user.show(); } 结论：在配置文件加载的时候。其中管理的对象都已经初始化了！\nSpring配置  别名  alias 设置别名 , 为bean设置别名 , 可以设置多个别名\n\u0026lt;!--设置别名：在获取Bean的时候可以使用别名获取--\u0026gt; \u0026lt;alias name=\u0026#34;userT\u0026#34; alias=\u0026#34;userNew\u0026#34;/\u0026gt;  Bean的配置  \u0026lt;!--bean就是java对象,由Spring创建和管理--\u0026gt; \u0026lt;!-- id 是bean的标识符,要唯一,如果没有配置id,name就是默认标识符 如果配置id,又配置了name,那么name是别名 name可以设置多个别名,可以用逗号,分号,空格隔开 如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象; class是bean的全限定名=包名+类名 --\u0026gt; \u0026lt;bean id=\u0026#34;hello\u0026#34; name=\u0026#34;hello2 h2,h3;h4\u0026#34; class=\u0026#34;com.kuang.pojo.Hello\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;Spring\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;  import  团队的合作通过import来实现 .\n\u0026lt;import resource=\u0026#34;{path}/beans.xml\u0026#34;/\u0026gt; ","date":"2021-09-11T17:23:33+08:00","permalink":"https://example.com/p/spring02-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/","title":"Spring02 快速上手"},{"content":"Hugo 简介 Hugo是由Steve Francis基于Go语言开发的静态网站构建工具。\n为什么选择Hexo  编译文章生成速度快 Hugo的官方文档写的非常好，部署简洁。 前两者部署时需要安装很多依赖，而hugo可以直接提供二进制文件运行，甚至不需要root权限。 颜值相对较高  安装 官方安装教程(推荐)\nMac安装   安装 brew\nruby -e \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\u0026#34;   运行brew命令进行安装hugo\nbrew install hugo 如果 Homebrew 工作正常，您应该会看到类似于以下内容的内容：\n==\u0026gt; Downloading https://homebrew.bintray.com/bottles/hugo-0.21.sierra.bottle.tar.gz ######################################################################### 100.0% ==\u0026gt; Pouring hugo-0.21.sierra.bottle.tar.gz 🍺 /usr/local/Cellar/hugo/0.21: 32 files, 17.4MB   创建新站点 hugo new site quickstart 添加主题 有关要考虑的主题列表，请参阅themes.gohugo.io。本快速入门使用漂亮的Ananke 主题。\n首先，从 GitHub 下载主题并将其添加到您网站的themes目录中：\ncd quickstart git init git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke 然后，将主题添加到站点配置中：\necho theme = \\\u0026#34;ananke\\\u0026#34; \u0026gt;\u0026gt; config.toml 添加一些内容 您可以手动创建内容文件（例如 as content/\u0026lt;CATEGORY\u0026gt;/\u0026lt;FILE\u0026gt;.\u0026lt;FORMAT\u0026gt;）并在其中提供元数据，但是您可以使用该new命令为您做一些事情（例如添加标题和日期）：\nhugo new posts/my-first-post.md 如果需要，编辑新创建的内容文件，它将以如下内容开头：\n--- title: \u0026#34;My First Post\u0026#34; date: 2019-03-26T08:47:11+01:00 draft: true --- 草稿不会被部署；完成帖子后，更新帖子的标题以说draft: false。更多信息在这里。\n启动 Hugo 服务器 现在，在启用草稿的情况下启动 Hugo 服务器：\nhugo server -D 查看部署的站点http://localhost:1313/ 的\n随意编辑或添加新内容，只需在浏览器中刷新即可快速查看更改（您可能需要在 webbrowser 中强制刷新）。\n自定义主题 您的新网站看起来不错，但在向公众发布之前，您需要对其进行一些调整。\n站点配置 config.toml在文本编辑器中打开：\nbaseURL = \u0026quot;https://example.org/\u0026quot; languageCode = \u0026quot;en-us\u0026quot; title = \u0026quot;My New Hugo Site\u0026quot; theme = \u0026quot;ananke\u0026quot; 用title更个性化的东西替换上面的内容。此外，如果您已经准备好域，请将baseURL. 请注意，运行本地开发服务器时不需要此值。\n**提示：**在 Hugo 服务器运行时对站点配置或站点中的任何其他文件进行更改，您将立即在浏览器中看到更改，但您可能需要清除缓存。\n有关特定于主题的配置选项，请参阅主题站点。\n如需进一步的主题定制，请参阅定制主题。\n构建静态页面 很简单。只需致电：\nhugo -D ./public/默认情况下输出将在目录中（-d/--destination标志更改它，或publishdir在配置文件中设置）。\n","date":"2021-09-10T13:37:10+08:00","permalink":"https://example.com/p/%E8%AE%B0%E4%B8%80%E6%AC%A1-hugo-%E5%AE%89%E8%A3%85/","title":"记一次 Hugo 安装"},{"content":"Filter和Listener FIlter 指过滤器  概念   生活中的过滤器:空气过滤器 净水器 web中的过滤器:当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能 过滤器的一些功能: 一般用于完整通用的操作：  比如登录验证 统一编码设置 敏感字符过滤     快速入门:\n  步骤:\n 定义一个类 实现Filter接口， 复写方法 配置拦截资源: 注解配置 @WebFilter(\u0026quot;/*\u0026quot;) web.xml配置    @WebFilter(\u0026#34;/*\u0026#34;) public class FilterDemo implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(\u0026#34;执行了filter\u0026#34;); chain.doFilter(request, response); } }     过滤器细节\n  web.xml\n  \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;demo1\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;com.edu.web.filter.FilterDemo\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;demo1\u0026lt;/filter-name\u0026gt; \u0026lt;!-- 拦截的请求路径 --\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt;   过滤器执行流程\n 执行 doFilter方法() 对request对象进行 增强 chain.doFilter() 放行 执行对应的Servlet 对response对象进行增强 执行 doFilter后的方法      过滤器生命周期方法\n init 应用服务器启动时执行一次 doFilter 每一次请求被拦截时 执行 destroy 在服务器关闭后，Filter对象被销毁。    过滤器配置详解\n  拦截路径配置\n 具体的资源路径 :1 /index.jsp 只有访问index.jsp时 过滤器才会被执行 拦截目录 /user/* 访问user下的所有执行时过滤器被拦截 拦截指定类型文件 .jsp 注意不加/ 拦截所有资源 /* 拦截方式    指的是资源被访问的方式:\n 可以直接通过浏览器发送请求 资源 可以在服务端通过 转发访问资源      注解配置:\n  设置 WebFilter()\n  dispatcherType:\n  REQUEST 浏览器请求\n  FORWARD 转发\n  INCLUDE 包含访问资源\n  ERROR 错误跳转专员\n  ASYNC: 异步访问资源\nweb.xml\n\u0026lt;filter-mapping\u0026gt; \u0026lt;dispatcher\u0026gt;REQUEST(同上)\u0026lt;/dispatcher\u0026gt; \u0026lt;/filter-mapping\u0026gt;       过滤器链\n 一个项目里可以配置多个过滤器  如果有两个过滤器 分别为过滤器A 过滤器B 执行顺序 A 过滤器B 资源 过滤器B 过滤器A   过滤器先后顺序：  注解配置：按照类名的字符串比较规则，值小的先执行 Afilter和Bfilter 分别比较 A先执行 Web.xml里的配置 谁配置在上面谁先执行。      ","date":"2021-05-11T15:29:19+08:00","permalink":"https://example.com/p/filter%E5%92%8Clistener/","title":"Filter和Listener"},{"content":"MySQL中的数据类型 MySQL支持多种数据类型，主要有数值类型、日期/时间类型和字符串类型。\n数值类型 数值类型包括：\n  整数类型：TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT\n  浮点数类型有FLOAT和DOUBLE\n  定点小数类型DECIMAL\n  日期/时间类型：包括YEAR、TIME、DATE、DATATIME和TIMESTAMP。\n  字符串类型：CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET等。字符串类型又分为文本字符串和二进制字符串。\n  整数类型 数值型数据类型主要用来存储数字，不同的数据类型提供不同的取值范围，可以存储的值的范围越大，其所需要的存储空间也会越大。整数类型的字段可以添加AUTO_INCREMENT自增约束条件。\n   类型名称 存储需求（B）     TINYINT tinyint 1   SMALLINT smallint 2   MEDIUMINT mediumint 3   INT 4   BIGINT 8    需要注意的是，在设计数据库的时候，在实体类中long型的变量对应BIGINT,INT对应int类型的成员变量。\n例：\nCREATE TABLE tb_emp1( id INT(11), name VARCHAR(25). deptId INT(11), salary FLOAT ); id字段的数据类型为INT（11），“11”表示该数据类型指定的显示宽度，指定能显示的数值中数字的个数。\n注意：**显示宽度和数据类型的取值范围是无关的。**显示宽度只是指明MySQL最大可能显示的数字个数，数值的位数小于指定宽度时会有空格填充。但是，如果插入了大于显示宽度的值，只要该值不超过取值范围，数值依然可以插入，而且在查询该列值的时候，将会显示完整的插入值，而不会进行显示宽度处理。例如下列语句创建表user：\nmysql\u0026gt; CREATE TABLE user( -\u0026gt; id INT(4), -\u0026gt; name VARCHAR(20) -\u0026gt; ); 插入数据：\nmysql\u0026gt; INSERT INTO user VALUES(19999,'qing'); 查询结果显示：\n+-------+------+ | id | name | +-------+------+ | 19999 | qing | +-------+------+ INT默认显示4，但是插入19999依然正常显示。请牢记：INT（3）中的数字3仅仅限制显示而已。\n浮点数类型和定点数类型 浮点类型有2中：单精度（FLOAT）和双精度（DOUBLE）。定点类型只有DECIMAL。二者都可以用（M,D）来表示，其中M称为精度，表示总的位数，D称为标度，表示小数点后的位数。\n   类型名称 存储需求（B）     FLOAT 4   DOUBLE 8   DECIMAL（M,D） M+2    DECIMAL类型不同于FLOAT和DOUBLE，DECIMAL类型实际上是以串存放的。\n不论是定点类型还是浮点类型，如果用户指定的数据超出精度范围，则会进行四舍五入处理。\n 问：如果不指定精度，系统如何处理？ 答：FLOAT和DOUBLE在不指定精度的时候，默认按照实际的精度（由计算机硬件和操作系统决定），DECIMAL默认为（10，0）。  日期与时间类型 这里只是简单说一下DATE和TIMESTAMP类型：\n   类型名称 日期格式 存储空间（B）     DATE YYYY-MM-DD 3   TIMESTAMP YYYY-MM-DD HH:MM:SS 4   DATETIME YYYY-MM-DD HH:MM:SS 4     使用CURRENT_DATE或者NOW()插入当前系统日期。 字符串格式自定义添加：“yyyy-MM-dd HH:mm:ss” \u0026ldquo;yyyyMMddHHmmss\u0026rdquo; 应该注意的是，CURRENT_DATE只返回当前日期值，不包括时间部分；NOW()函数返回日期和时间，但是在保存到数据库时，只保留其日期部分。  TIMESTAMP类型显示宽度固定在19个字符，且其值的存储是以UTC（世界标准时间）格式保存的，存储时间时对当前时区进行转换，检索时再次进行转换。即查询时，当前时区不同，显示的时间值是不同的。\n时间搓保存的是当前日期对应毫秒值。范围1970年的1月1日 \u0026mdash;\u0026ndash; 2038年\n文本字符串类型 字符串类型用来存储字符串数据，也可以用来存储其他数据，比如图片和音频的二进制数据等等。 文本字符串分为两类：\n 文本字符串 二进制字符串 一般图片音频视频等数据都是先保存在服务器的硬盘，然后再将地址保存到数据库中  MySQL中文本字符串数据类型\n   类型名称 说明 存储需求     CHAR(M) 固定长度的非二进制字符串 M字节，1\u0026lt;=M\u0026lt;=255   VARCHAR(M) 变长的非二进制字符串 L+1字节，这里L\u0026lt;=M和1\u0026lt;=M\u0026lt;=255   ENUM 枚举类型，只能有一个枚举字符串值 1或2个字节，取决于枚举值的数目(最大值是65535)   SET 一个设置，字符串对象可以有零个或多个SET成员 1，2，3，4或8个字节，取决于集合成员的数量（最多64个成员）   TINYTEXT 非常小的非二进制字符串 L+1个字节，这里L\u0026lt;2 8   TEXT 小的非二进制字符串 L+2个字节，这里L\u0026lt;2^{16}   MEDIUMTEXT 中等大小的非二进制字符串 L+3个字节，这里L\u0026lt;2^{24}   LONGTEXT 大的非二进制字符串 L+4个字节，这里L\u0026lt;2^{32}    blob\n上面几种数据类型，我们着重说一下CHAR和VARCHAR,ENUM,SET\nCHAR(M)为固定长度的字符串，定义时指定字符串列长，保存时右侧填充空格以达到指定长度。M表示列长度，M的范围是0-255个字符。**检索时，尾部的空格将会被删除。**如果存入了一个超过M长度的字符串，会导致该字符串被截断，只保留前M位。\nVARCHAR(M)是长度可变的字符串，M表示最大列的长度。M的范围是0-65535。\n例如，VARCHAR(50) 定义了一个最大长度为50的字符串，如果输入的字符串只有10个字符，那么只需要实际存储的是10个字符和一个长度信息字符。VARCHAR在值保存和值检索的时候，空格保存。\n看下面的例子：\nmysql\u0026gt; create table tmp8( -\u0026gt; ch CHAR(4),varch VARCHAR(4) -\u0026gt; ); mysql\u0026gt; INSERT INTO tmp8('ab ','ab '); mysql\u0026gt; SELECT concat('(',ch,')'),concat('(',varch,')') FROM tmp8; +--------------------+-----------------------+ | concat('(',ch,')') | concat('(',varch,')') | +--------------------+-----------------------+ | (ab) | (ab ) | +--------------------+-----------------------+ 1 row in set (0.02 sec) 从上面可以看出，检索时，CHAR型会删掉尾部的空格，而VARCHAR不会。\nENUM类型：\n来个实际的例子：\nmysql\u0026gt; CREATE TABLE tmp9( -\u0026gt; name CHAR(4), -\u0026gt; sex ENUM('male','female','other','renyao') -\u0026gt; ); Query OK, 0 rows affected (0.33 sec) mysql\u0026gt; DESC tmp9; +-------+-----------------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-----------------------+------+-----+---------+-------+ | name | char(4) | YES | | NULL | | | sex | enum('male','female') | YES | | NULL | | +-------+-----------------------+------+-----+---------+-------+ 2 rows in set (0.01 sec) mysql\u0026gt; INSERT INTO tmp9 VALUES('aaaa','male'); Query OK, 1 row affected (0.06 sec) mysql\u0026gt; INSERT INTO tmp9 VALUES('bbbb','female'); Query OK, 1 row affected (0.07 sec) mysql\u0026gt; SELECT sex,sex+0 FROM tmp9; +--------+-------+ | sex | sex+0 | +--------+-------+ | male | 1 | | female | 2 | +--------+-------+ 2 rows in set (0.00 sec) mysql\u0026gt; INSERT INTO tmp9 VALUES('bbbb',NULL); Query OK, 1 row affected (0.06 sec) mysql\u0026gt; SELECT sex,sex+0 FROM tmp9; +--------+-------+ | sex | sex+0 | +--------+-------+ | male | 1 | | female | 2 | | NULL | NULL | +--------+-------+ 3 rows in set (0.00 sec) 从上面我们可以看到，数据库中存储的是ENUM类型数据的索引值。\n另外，如果ENUM列总有一个默认值，如果该列可以为NULL，那么默认值为NULL,如果NOT NULL，那么为允许列表中的第一个值。\n枚举每个值对应一个整数下标，是从1开始\nSET类型：\nSET也是一个字符串对象，不过跟ENUM不同的是，SET类型的字段可以取 SET列表中的0个或者多个值。SET列最多有64个成员。\n如果插入的的值有重复，那么MySQL会自动删除重复的值，插入SET字段的值的顺序并不重要，MySQL在存储的时候，会按照定义的顺序显示；如果插入不正确的值，MySQL会阻止插入。\nmysql\u0026gt; CREATE TABLE tmp10( -\u0026gt; se SET('A','C','X','D') -\u0026gt; ); Query OK, 0 rows affected (0.30 sec) mysql\u0026gt; INSERT INTO tmp10 VALUES('A,D,X'); Query OK, 1 row affected (0.11 sec) mysql\u0026gt; SELECT * FROM tmp10; +-------+ | se | +-------+ | A,X,D | +-------+ 1 row in set (0.00 sec) 1 注意A,X,D的顺序，是和创建表时的顺序一样的。\n","date":"2021-05-11T15:29:19+08:00","permalink":"https://example.com/p/mysql%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","title":"MySQL中的数据类型"},{"content":"Spring介绍  简介  Spring : 春天 \u0026mdash;\u0026gt;给软件行业带来了春天\n2002年，Rod Jahnson首次推出了Spring框架雏形interface21框架。\n2004年3月24日，Spring框架以interface21框架为基础，经过重新设计，发布了1.0正式版。\n很难想象Rod Johnson的学历 , 他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学。\nSpring理念 : 使现有技术更加实用 . 本身就是一个大杂烩 , 整合现有的框架技术\n官网 : http://spring.io/\n官方下载地址 : https://repo.spring.io/libs-release-local/org/springframework/spring/\nGitHub : https://github.com/spring-projects\n 优点    Spring是一个开源免费的框架 , 容器 .\n  Spring是一个轻量级的框架 , 非侵入式的 .\n  控制反转 IoC , 面向切面 Aop\n  对事物的支持 , 对框架的支持\n  一句话概括：\nSpring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）。\n 组成  Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式 .\n组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下：\n 核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。 Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。 Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。 Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。 Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。 Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。 Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。   拓展  Spring Boot与Spring Cloud\n Spring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务; Spring Cloud是基于Spring Boot实现的； Spring Boot专注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架； Spring Boot使用了约束优于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置 , Spring Cloud很大的一部分是基于Spring Boot来实现，Spring Boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开Spring Boot，属于依赖的关系。 SpringBoot在SpringClound中起到了承上启下的作用，如果你要学习SpringCloud必须要学习SpringBoot。  IoC推导 新建一个空白的maven项目\n 分析实现  我们先用我们原来的方式写一段代码 .\n1、先写一个UserDao接口\npublic interface UserDao { public void getUser(); } 2、再去写Dao的实现类\npublic class UserDaoImpl implements UserDao { @Override public void getUser() { System.out.println(\u0026#34;获取用户数据\u0026#34;); } } 3、然后去写UserService的接口\npublic interface UserService { public void getUser(); } 4、最后写Service的实现类\npublic class UserServiceImpl implements UserService { private UserDao userDao = new UserDaoImpl(); @Override public void getUser() { userDao.getUser(); } } 5、测试一下\n@Test public void test(){ UserService service = new UserServiceImpl(); service.getUser(); } 这是我们原来的方式 , 开始大家也都是这么去写的对吧 . 那我们现在修改一下 .\n把Userdao的实现类增加一个 .\npublic class UserDaoMySqlImpl implements UserDao { @Override public void getUser() { System.out.println(\u0026#34;MySql获取用户数据\u0026#34;); } } 紧接着我们要去使用MySql的话 , 我们就需要去service实现类里面修改对应的实现\npublic class UserServiceImpl implements UserService { private UserDao userDao = new UserDaoMySqlImpl(); @Override public void getUser() { userDao.getUser(); } } 在假设, 我们再增加一个Userdao的实现类 .\npublic class UserDaoOracleImpl implements UserDao { @Override public void getUser() { System.out.println(\u0026#34;Oracle获取用户数据\u0026#34;); } } 那么我们要使用Oracle , 又需要去service实现类里面修改对应的实现 . 假设我们的这种需求非常大 , 这种方式就根本不适用了, 甚至反人类对吧 , 每次变动 , 都需要修改大量代码 . 这种设计的耦合性太高了, 牵一发而动全身 .\n那我们如何去解决呢 ?\n我们可以在需要用到他的地方 , 不去实现它 , 而是留出一个接口 , 利用set , 我们去代码里修改下 .\npublic class UserServiceImpl implements UserService { private UserDao userDao; // 利用set实现  public void setUserDao(UserDao userDao) { this.userDao = userDao; } @Override public void getUser() { userDao.getUser(); } } 现在去我们的测试类里 , 进行测试 ;\n@Test public void test(){ UserServiceImpl service = new UserServiceImpl(); service.setUserDao( new UserDaoMySqlImpl() ); service.getUser(); //那我们现在又想用Oracle去实现呢  service.setUserDao( new UserDaoOracleImpl() ); service.getUser(); } 大家发现了区别没有 ? 可能很多人说没啥区别 . 但是同学们 , 他们已经发生了根本性的变化 , 很多地方都不一样了 . 仔细去思考一下 , 以前所有东西都是由程序去进行控制创建 , 而现在是由我们自行控制创建对象 , 把主动权交给了调用者 . 程序不用去管怎么创建,怎么实现了 . 它只负责提供一个接口 .\n这种思想 , 从本质上解决了问题 , 我们程序员不再去管理对象的创建了 , 更多的去关注业务的实现 . 耦合性大大降低 . 这也就是IOC的原型 !\n IOC本质  控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。\nIoC是Spring框架的核心内容，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。\nSpring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。\n采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。\n控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。\nps:明白IOC的思想，是理解Spring的核心技巧\n","date":"2021-05-11T15:29:19+08:00","permalink":"https://example.com/p/spring01-%E6%A6%82%E8%BF%B0%E5%8F%8Aioc%E7%90%86%E8%AE%BA%E6%8E%A8%E5%AF%BC/","title":"Spring01 概述及IOC理论推导"},{"content":"EL（Expression Language） JSP表达式语言（EL）使得访问存储在JavaBean中的数据变得非常简单。JSP EL既可以用来创建算术表达式也可以用来创建逻辑表达式。在JSP EL表达式内可以使用整型数，浮点数，字符串，常量true、false，还有null。\n一个简单的语法 ${expr} {expr} 其中，expr指的是表达式。在JSP EL中通用的操作符是 . 和 {} 。这两个操作符允许您通过内嵌的JSP对象访问各种各样的JavaBean属性。\n\u0026lt;jsp:setProperty name=\u0026quot;box\u0026quot; property=\u0026quot;perimeter\u0026quot; name=\u0026quot;box\u0026quot; property=\u0026quot;perimeter\u0026quot; value=\u0026quot;${2*box.width+2*box.height}\u0026quot;/\u0026gt;value=\u0026quot;${2*box.width+2*box.height}\u0026quot;/\u0026gt; 当JSP编译器在属性中见到\u0026quot;${}\u0026ldquo;格式后，它会产生代码来计算这个表达式，并且产生一个替代品来代替表达式的值。\n您也可以在标签的模板文本中使用表达式语言。比如jsp:text标签简单地将其主体中的文本插入到JSP输出中：\n\u0026lt;jsp:text\u0026gt; \u0026lt;h1\u0026gt;Hello JSP!\u0026lt;/h1\u0026gt;\u0026lt;h1\u0026gt;Hello JSP!\u0026lt;/h1\u0026gt; \u0026lt;/jsp:text\u0026gt;\u0026lt;/jsp:text\u0026gt; 现在，在jsp:text标签主体中使用表达式，就像这样：\n\u0026lt;jsp:text\u0026gt; Box Perimeter is: ${2*box.width + 2*box.height} \u0026lt;/jsp:text\u0026gt;\u0026lt;/jsp:text\u0026gt; 在EL表达式中可以使用圆括号来组织子表达式。比如${(1 + 2) * 3}等于9，但是${1 + (2 * 3)} 等于7。\n想要停用对EL表达式的评估的话，需要使用page指令将isELIgnored属性值设为true：\n\u0026lt;%@ page isELIgnored =\u0026quot;true|false\u0026quot; %\u0026gt; 这样，EL表达式就会被忽略。若设为false，则容器将会计算EL表达式。\n EL中的基础操作符 EL表达式支持大部分Java所提供的算术和逻辑操作符：\n   操作符 描述     . 访问一个Bean属性或者一个映射条目   [] 访问一个数组或者链表的元素   ( ) 组织一个子表达式以改变优先级   + 加   - 减或负   * 乘   / or div 除   % or mod 取模   == or eq 测试是否相等   != or ne 测试是否不等   \u0026lt; or lt 测试是否小于   \u0026gt; or gt 测试是否大于   \u0026lt;= or le 测试是否小于等于   \u0026gt;= or ge 测试是否大于等于   \u0026amp;\u0026amp; or and 测试逻辑与   || or or 测试逻辑或   ! or not 测试取反   empty 测试是否空值     JSP EL中的函数 JSP EL允许您在表达式中使用函数。这些函数必须被定义在自定义标签库中。函数的使用语法如下：\n${ns:func(param1, param2, ...)} ns指的是命名空间（namespace），func指的是函数的名称，param1指的是第一个参数，param2指的是第二个参数，以此类推。比如，有函数fn:length，在JSTL库中定义，可以像下面这样来获取一个字符串的长度：\n${fn:length(\u0026quot;Get my length\u0026quot;)} 要使用任何标签库中的函数，您需要将这些库安装在服务器中，然后使用标签在JSP文件中包含这些库。\n JSP EL隐含对象 JSP EL支持下表列出的隐含对象：\n   隐含对象 描述     pageScope page 作用域   requestScope request 作用域   sessionScope session 作用域   applicationScope application 作用域   param Request 对象的参数，字符串   paramValues Request对象的参数，字符串集合   header HTTP 信息头，字符串   headerValues HTTP 信息头，字符串集合   initParam 上下文初始化参数   cookie Cookie值   pageContext 当前页面的pageContext    您可以在表达式中使用这些对象，就像使用变量一样。接下来会给出几个例子来更好的理解这个概念。\n pageContext对象 pageContext对象是JSP中pageContext对象的引用。通过pageContext对象，您可以访问request对象。比如，访问request对象传入的查询字符串，就像这样：\n${pageContext.request.queryString}  Scope对象 pageScope，requestScope，sessionScope，applicationScope变量用来访问存储在各个作用域层次的变量。\n举例来说，如果您需要显式访问在applicationScope层的box变量，可以这样来访问：applicationScope.box。\n param和paramValues对象 param和paramValues对象用来访问参数值，通过使用request.getParameter方法和request.getParameterValues方法。\n举例来说，访问一个名为order的参数，可以这样使用表达式：${param.order}，或者${param[\u0026ldquo;order\u0026rdquo;]}。\n接下来的例子表明了如何访问request中的username参数：\n\u0026lt;%@ page import=\u0026quot;java.io.*,java.util.*\u0026quot; %\u0026gt; \u0026lt;% String title = \u0026quot;Accessing Request Param\u0026quot;; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;\u0026lt;% out.print(title); %\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;center\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;% out.print(title); %\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;/center\u0026gt; \u0026lt;div align=\u0026quot;center\u0026quot;\u0026gt; \u0026lt;p\u0026gt;${param[\u0026quot;username\u0026quot;]}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; param对象返回单一的字符串，而paramValues对象则返回一个字符串数组。\n header和headerValues对象 header和headerValues对象用来访问信息头，通过使用 request.getHeader方法和request.getHeaders方法。\n举例来说，要访问一个名为user-agent的信息头，可以这样使用表达式：${header.user-agent}，或者${header[\u0026ldquo;user-agent\u0026rdquo;]}。\n接下来的例子表明了如何访问user-agent信息头：\n\u0026lt;%@ page import=\u0026quot;java.io.*,java.util.*\u0026quot; %\u0026gt; \u0026lt;% String title = \u0026quot;User Agent Example\u0026quot;;String title = \u0026quot;User Agent Example\u0026quot;; %\u0026gt; \u0026lt;html\u0026gt;\u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;head\u0026gt; \u0026lt;title\u0026gt;\u0026lt;% out.print(title); %\u0026gt;\u0026lt;/title\u0026gt;\u0026lt;title\u0026gt;\u0026lt;% out.print(title); %\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;\u0026lt;body\u0026gt; \u0026lt;center\u0026gt;\u0026lt;center\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;% out.print(title); %\u0026gt;\u0026lt;/h1\u0026gt;\u0026lt;h1\u0026gt;\u0026lt;% out.print(title); %\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;/center\u0026gt;\u0026lt;/center\u0026gt; \u0026lt;div align=\u0026quot;center\u0026quot;\u0026gt;\u0026lt;div align=\u0026quot;center\u0026quot;\u0026gt; \u0026lt;p\u0026gt;${header[\u0026quot;user-agent\u0026quot;]}\u0026lt;/p\u0026gt;\u0026lt;p\u0026gt;${header[\u0026quot;user-agent\u0026quot;]}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;\u0026lt;/html\u0026gt; 运行结果如下：\n jsp-expression-language \nheader对象返回单一值，而headerValues则返回一个字符串数组。\nEl函数库 导入标签库:\njsp页面需要引入fn函数声明： \u0026lt;%@ taglib prefix=\u0026quot;fn\u0026quot; uri=\u0026quot;http://java.sun.com/jsp/jstl/functions\u0026quot; %\u0026gt; 一般需要C标签配合使用，同时引入C标签声明： \u0026lt;%@ taglib prefix=\u0026quot;c\u0026quot; uri=\u0026quot;http://java.sun.com/jsp/jstl/core\u0026quot; %\u0026gt; 函数:\nString toUpperCase(String input); //把参数转换为大写 String toLowerCase(String input); //把参数转换为小写 int indexOf(String input,String substring); //从大字符串，输出小字符串的位置 boolean contains(String input,String substring); //查看大字符串中是否包含小字符串 boolean containsIgnoreCase(String input,String substring); //忽略大小写的，是否包含 boolean startsWith(String input,String substring); //是否以小串为前缀 boolean endsWith(String input,String substring); //是否以小串为后缀 String substring(String input,int beginIndex, int endIndex); //截取子串 String substringAfter(String input, String substring); //截取大串中，小串所在位置后面的字符串 String substringBefore(String input, String substring); //获取大串中，小串所在位置前面的字符串 substring escapeXml(String input); //把input\u0026quot;\u0026lt;\u0026quot;、\u0026quot;\u0026gt;\u0026quot;、\u0026quot;\u0026amp;\u0026quot;、\u0026quot;'\u0026quot;、\u0026quot;\u0026quot;\u0026quot;,进行转义 String trim(String input); //去除前后空格 String replace(String input,String substringBefore, String substringAfter); //替换 String[] split(String input,String delimiters); //分割字符串，得到字符串数组 int length(Object obj); //可以获取字符串、数组、各种集合的长度 String join(String array[],String separator); //联合字符串数组 1.确保maven中添加了以下依赖：\n \u0026lt;!-- 添加jstl依赖，使其支持\u0026lt;%@taglib prefix=\u0026quot;c\u0026quot; uri=\u0026quot;http://java.sun.com/jsp/jstl/core\u0026quot; %\u0026gt;jstl语法 --\u0026gt; \u0026lt;!-- jstl标签库相关 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;jstl\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jstl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.apache.taglibs/taglibs-standard-impl --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.taglibs\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;taglibs-standard-jstlel\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; ","date":"2021-05-11T15:29:19+08:00","permalink":"https://example.com/p/%E4%BD%BF%E7%94%A8el%E8%A1%A8%E8%BE%BE%E5%BC%8F/","title":"使用EL表达式"},{"content":"还原系统配置步骤： 1、下载Git 2、IDEA和Git关联 3、去仓库拉工程 4、配置Maven 5、修改主题颜色 6、修改字体大小 7、IDEA下载lombok插件 8、数据库 9、自动导包 10、快捷键调为eclipse\n一、Mybatis 3的学习  MyBatis logo \n img \n1.1 什么是Mybatis MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。\n官网：https://mybatis.org/mybatis-3/zh/index.html\n用来学习最新的API\n中文网：http://www.mybatis.cn/\n用来查看使用技巧\n1.2 Mybatis的历史 原是apache的一个开源项目iBatis，2010年6月这个项目由apache迁移到了google code，随着开发团队转投Google code旗下，ibatis3.x正式更名为Mybatis，代码于2013年11月迁移到Github。\n1.3 Mybatis的优势  基于sql语句编程，使用灵活，sql与程序代码的解耦 与JDBC相比减少50%代码，减少大量冗余代码，不需要手动开关连接 只要支持jdbc的数据库都支持Mybatis 与spring集成 支持面向对象编程，对象与ORM表映射  二、Mybaits环境搭建 2.1 创建数据库和表 /* SQLyog Ultimate v12.09 (64 bit) MySQL - 5.5.54 : Database - mybatis ********************************************************************* *//*!40101 SET NAMES utf8 */;/*!40101 SET SQL_MODE=\u0026#39;\u0026#39;*/;/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=\u0026#39;NO_AUTO_VALUE_ON_ZERO\u0026#39; */;/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;CREATEDATABASE/*!32312 IF NOT EXISTS*/`mybatis`/*!40100 DEFAULT CHARACTER SET utf8 */;USE`mybatis`;/*Table structure for table `users` */DROPTABLEIFEXISTS`users`;CREATETABLE`users`(`u_id`BIGINT(18)NOTNULLAUTO_INCREMENT,`u_name`VARCHAR(30)NOTNULLCOMMENT\u0026#39;用户名\u0026#39;,`u_pass`VARCHAR(100)NOTNULLCOMMENT\u0026#39;密码\u0026#39;,PRIMARYKEY(`u_id`))ENGINE=INNODBAUTO_INCREMENT=6DEFAULTCHARSET=utf8;/*Data for the table `users` */insertinto`users`(`u_id`,`u_name`,`u_pass`)values(1,\u0026#39;张三\u0026#39;,\u0026#39;9033241\u0026#39;),(2,\u0026#39;李四\u0026#39;,\u0026#39;3333241\u0026#39;),(3,\u0026#39;王五\u0026#39;,\u0026#39;12156241\u0026#39;),(4,\u0026#39;赵六\u0026#39;,\u0026#39;1111\u0026#39;),(5,\u0026#39;铁蛋\u0026#39;,\u0026#39;23233241\u0026#39;);/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;2.2 创建Maven工程  image-20211009103139363 \n2.3 IDEA自带数据库管理工具  image-20211009103816538 \n2.4 配置Maven  image-20211009105236094 \n2.5 创建表映射类PO package com.xxgc.mybatis.po; /* alt + insert 生成构造函数 */ public class User { private long uId; private String uName; private String uPass; public long getuId() { return uId; } public void setuId(long uId) { this.uId = uId; } public String getuName() { return uName; } public void setuName(String uName) { this.uName = uName; } public String getuPass() { return uPass; } public void setuPass(String uPass) { this.uPass = uPass; } } 2.6 创建Mybaits配置文件 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;!--核心配置文件--\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!--environments 环境 --\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;!--事务 JDBC的事务--\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;!--serverTimezone=GMT 时区--\u0026gt; \u0026lt;!--useSSL=true 通道加密--\u0026gt; \u0026lt;!--useUnicode=true 自定义编码--\u0026gt; \u0026lt;!--characterEncoding=UTF-8 设置编码为UTF-8--\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis?serverTimezone=GMT\u0026amp;amp; useSSL=true\u0026amp;amp;useUnicode=true\u0026amp;amp;characterEncoding=UTF-8\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;123456\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;/configuration\u0026gt; 2.7 创建一个工具类来获取SqlSession package com.xxgc.mybatis.util; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.InputStream; //Mybaits工具类，用来获取sqlSession public class MyBatisUtils { private static SqlSessionFactory sqlSessionFactory; static { try { //以下三步通过配置文件来获取sqlSessionFactory  String resource = \u0026#34;mybatis-config.xml\u0026#34;; InputStream inputStream = Resources.getResourceAsStream(resource); /* ctrl + alt + f 提取/抽取 全局变量 */ sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e){ e.printStackTrace(); } } public static SqlSession getSqlSession(){ /* ctrl + alt + v 自动生成返回结果 */ SqlSession sqlSession = sqlSessionFactory.openSession(); return sqlSession; } } 2.8 创建Dao层接口 package com.xxgc.mybatis.dao; import com.xxgc.User; import java.util.List; //用户表Dao层接口 public interface UserDao { //查询所有用户  List\u0026lt;User\u0026gt; selectAllUsers(); } 2.9 创建映射文件 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;!--映射一个/绑定一个 dao层接口--\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.xxgc.UserDao\u0026#34;\u0026gt; \u0026lt;!--id 对应接口里的方法名 --\u0026gt; \u0026lt;!--resultType 返回结果类型--\u0026gt; \u0026lt;select id=\u0026#34;selectAllUsers\u0026#34; resultType=\u0026#34;com.xxgc.User\u0026#34;\u0026gt; select * from users; \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; @Test public void test(){ //调用工具类 得到sqlSession  SqlSession sqlSession = MyBatisUtils.getSqlSession(); //加载dao层映射  UserDao mapper = sqlSession.getMapper(UserDao.class); //通过调用接口执行语句  List\u0026lt;User\u0026gt; users = mapper.selectAllUsers(); //循环打印内容  for (User user : users) { System.out.println(\u0026#34;user = \u0026#34; + user); } //手动关闭sqlsession(学到了spring过后就不需要了)  sqlSession.close(); } 添加Mapper映射\n\u0026lt;!--每一个持久层接口都对应一个mapper文件 mapper文件需要手动注入--\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;com\\xxgc\\mybatis\\dao\\UserDaoMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; 开启驼峰命名\n\u0026lt;!--开启驼峰命名--\u0026gt; \u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026#34;mapUnderscoreToCamelCase\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; 工程环境目录结构 http://www.shijiayi.top/article/268.html?t=1634010066341\n三、Mybatis增删改查 3.1 select select标签属性\n id 相应dao层方法 parameterType 传入参数类型 resultType 返回对象  \u0026lt;!--resultType 返回结果类型--\u0026gt; \u0026lt;select id=\u0026#34;selectAllUsers\u0026#34; resultType=\u0026#34;com.xxgc.User\u0026#34;\u0026gt; select * from users; \u0026lt;/select\u0026gt; \u0026lt;!--通过用户id查询--\u0026gt; \u0026lt;select id=\u0026#34;selectUserById\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;com.xxgc.User\u0026#34;\u0026gt; select * from users where u_id = #{uId}; \u0026lt;/select\u0026gt; 3.2 insert 需要提交事务\nsqlSession.commit(); \u0026lt;!--对象中的属性值可以直接取出来--\u0026gt; \u0026lt;insert id=\u0026#34;addUser\u0026#34; parameterType=\u0026#34;com.xxgc.User\u0026#34;\u0026gt; insert into users(u_name,u_pass) value (#{uName},#{uPass}); \u0026lt;/insert\u0026gt; 3.3 update 需要提交事务\nsqlSession.commit(); \u0026lt;update id=\u0026#34;updateUser\u0026#34; parameterType=\u0026#34;com.xxgc.User\u0026#34;\u0026gt; update users set u_name = #{uName},u_pass = #{uPass} where u_id = #{uId}; \u0026lt;/update\u0026gt; 3.4 delete 需要提交事务\nsqlSession.commit(); \u0026lt;delete id=\u0026#34;deleteUserById\u0026#34; parameterType=\u0026#34;int\u0026#34;\u0026gt; delete from users where u_id = #{uId}; \u0026lt;/delete\u0026gt; 3.5 特殊使用 在参数不确定的情况下，可以使用Map集合来进行参数传递\n//特殊的参数传递 int addUserByMap(Map\u0026lt;String, Object\u0026gt; map); \u0026lt;insert id=\u0026#34;addUserByMap\u0026#34; parameterType=\u0026#34;map\u0026#34;\u0026gt; insert into users(u_name,u_pass) value (#{myName},#{myPass}); \u0026lt;/insert\u0026gt; Map\u0026lt;String,Object\u0026gt; map = new HashMap\u0026lt;String, Object\u0026gt;(); map.put(\u0026#34;myName\u0026#34;,\u0026#34;阿强\u0026#34;); map.put(\u0026#34;myPass\u0026#34;,\u0026#34;156165156\u0026#34;); int i = mapper.addUserByMap(map); 模糊查询 like查询有点特殊需要用到CONCA()函数\n\u0026lt;select id=\u0026#34;selectUsersByLike\u0026#34; parameterType=\u0026#34;String\u0026#34; resultType=\u0026#34;com.xxgc.User\u0026#34;\u0026gt; select * from users where u_name like CONCAT(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;); \u0026lt;/select\u0026gt; 三、常用配置 3.1 mybatis环境配置 \u0026lt;!--environments 环境 default 默认环境 修改default可以切换当前工程环境 --\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;!--开发环境--\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;!--事务 JDBC的事务--\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;${driver}\u0026#34;/\u0026gt; \u0026lt;!--serverTimezone=GMT 时区--\u0026gt; \u0026lt;!--useSSL=true 通道加密--\u0026gt; \u0026lt;!--useUnicode=true 自定义编码--\u0026gt; \u0026lt;!--characterEncoding=UTF-8 设置编码为UTF-8--\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${password}\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;!--生产环境--\u0026gt; \u0026lt;environment id=\u0026#34;production\u0026#34;\u0026gt; \u0026lt;!--事务 JDBC的事务--\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;${pdriver}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${purl}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${pusername}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${ppassword}\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中， 现实情况下有多种理由需要这么做。例如，开发、测试和生产环境需要有不同的配置；\n不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。\n3.2 MyBatis自动扫描Bean类 \u0026lt;typeAliases\u0026gt; \u0026lt;!-- type 包路径 alias 别名--\u0026gt; \u0026lt;!--\u0026lt;typeAlias type=\u0026#34;com.xxgc.mybatis.po.User\u0026#34; alias=\u0026#34;User\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;!--自动扫描po包下面的类--\u0026gt; \u0026lt;package name=\u0026#34;com.xxgc.mybatis.po\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; 3.3 映射器（mappers） 既然 MyBatis 的行为已经由上述元素配置完了，我们现在就要来定义 SQL 映射语句了。 但首先，我们需要告诉 MyBatis 到哪里去找到这些语句。 在自动查找资源方面，Java 并没有提供一个很好的解决方案，所以最好的办法是直接告诉 MyBatis 到哪里去找映射文件。 你可以使用相对于类路径的资源引用，或完全限定资源定位符（包括 file:/// 形式的 URL），或类名和包名等。例如：\n\u0026lt;!-- 使用相对于类路径的资源引用 --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;org/mybatis/builder/AuthorMapper.xml\u0026#34;/\u0026gt; \u0026lt;mapper resource=\u0026#34;org/mybatis/builder/BlogMapper.xml\u0026#34;/\u0026gt; \u0026lt;mapper resource=\u0026#34;org/mybatis/builder/PostMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;!-- 使用完全限定资源定位符（URL） --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper url=\u0026#34;file:///var/mappers/AuthorMapper.xml\u0026#34;/\u0026gt; \u0026lt;mapper url=\u0026#34;file:///var/mappers/BlogMapper.xml\u0026#34;/\u0026gt; \u0026lt;mapper url=\u0026#34;file:///var/mappers/PostMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;!-- 使用映射器接口实现类的完全限定类名 --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper class=\u0026#34;org.mybatis.builder.AuthorMapper\u0026#34;/\u0026gt; \u0026lt;mapper class=\u0026#34;org.mybatis.builder.BlogMapper\u0026#34;/\u0026gt; \u0026lt;mapper class=\u0026#34;org.mybatis.builder.PostMapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;!-- 将包内的映射器接口实现全部注册为映射器 --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;package name=\u0026#34;org.mybatis.builder\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; 3.4 MyBatis生命周期  image-20211014091204372 \nSqlSessionFactoryBuilder 这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。\n因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。\nSqlSessionFactory 相当于一个饮料工厂，用于生产SqlSession。\n被创建后在应该在程序运行期间一直存在（使用静态单例模式）。\nSqlSession 使用后必须关闭。（饮料瓶有限，不归还无法继续生产。饮料瓶数量等于mysql最大连接数）\n作用于最好是在方法层面。\n3.5 ResultMap(结果集/结果图) 创建表\nCREATETABLE`money`(`m_id`bigint(18)NOTNULLAUTO_INCREMENTCOMMENT\u0026#39;金额表id\u0026#39;,`m_user_id`bigint(18)NOTNULLCOMMENT\u0026#39;用户id\u0026#39;,`m_money`int(11)NOTNULLDEFAULT\u0026#39;0\u0026#39;COMMENT\u0026#39;金额\u0026#39;,`m_type`varchar(200)NOTNULLDEFAULT\u0026#39;人民币\u0026#39;COMMENT\u0026#39;钱的类型\u0026#39;,PRIMARYKEY(`m_id`))ENGINE=InnoDBDEFAULTCHARSET=utf8创建触发器\nDELIMITER$$CREATE/*[DEFINER = { user | CURRENT_USER }]*/TRIGGER`mybatis`.`usermoney`AFTERINSERTON`mybatis`.`users`FOREACHROWBEGININSERTINTO`money`(`m_user_id`,`m_money`,`m_type`)VALUES(new.u_id,0,\u0026#39;人民币\u0026#39;),(new.u_id,0,\u0026#39;美元\u0026#39;),(new.u_id,0,\u0026#39;英镑\u0026#39;);END$$DELIMITER;创建扩展类\npackage com.xxgc.mybatis.po.extend; //User实体类的扩展 public class UserEx { private String name; private int money; private String type; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getMoney() { return money; } public void setMoney(int money) { this.money = money; } public String getType() { return type; } public void setType(String type) { this.type = type; } } \u0026lt;resultMap id=\u0026#34;UserExMap\u0026#34; type=\u0026#34;UserEx\u0026#34;\u0026gt; \u0026lt;!--column 数据库字段 property 实体类字段--\u0026gt; \u0026lt;result column=\u0026#34;u_name\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;m_money\u0026#34; property=\u0026#34;money\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;m_type\u0026#34; property=\u0026#34;type\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; 3.6 Log4j日志框架 Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件\u0026hellip;等；\n我们也可以控制每一条日志的输出格式，定义每一条日志信息的级别。\n可以通过一个配置文件（log4j.properties）来灵活地进行配置，而不需要修改应用的代码。\nMaven包查询 如果访问不了需要修改DNS为 114.114.114.114 8.8.8.8\n（https://mvnrepository.com/）\n image-20211014110207888 \nlog4j.properties #将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码 log4j.rootLogger=WARN,console,file #控制台输出的相关设置 log4j.appender.console = org.apache.log4j.ConsoleAppender log4j.appender.console.Target = System.out log4j.appender.console.Threshold=DEBUG log4j.appender.console.layout = org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern=[%p][%c]-%m%n #文件输出的相关设置 log4j.appender.file = org.apache.log4j.RollingFileAppender log4j.appender.file.File=C://logs/error.log log4j.appender.file.Append = true #输出门槛 log4j.appender.file.Threshold=WARM log4j.appender.file.layout=org.apache.log4j.PatternLayout log4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd HH:mm:ss}][%c]%m%n #日志输出级别 log4j.logger.org.mybatis=DEBUG log4j.logger.java.sql=DEBUG log4j.logger.java.sql.Statement=DEBUG log4j.logger.java.sql.ResultSet=DEBUG mybatis配置\n\u0026lt;!--常用设置--\u0026gt; \u0026lt;settings\u0026gt; \u0026lt;!--开启驼峰命名--\u0026gt; \u0026lt;setting name=\u0026#34;mapUnderscoreToCamelCase\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;!--配置mybatis的日志输出方式--\u0026gt; \u0026lt;setting name=\u0026#34;logImpl\u0026#34; value=\u0026#34;LOG4J\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; 常见的日志等级\nERROR、WARN、INFO、DEBUG\n ERROR 为严重错误 主要是程序的错误 WARN 为一般警告，比如session丢失 INFO 为一般要显示的信息，比如登录登出 DEBUG 为程序的调试信息  简单使用 private Logger logger = Logger.getLogger(类名.class); logger.debug(\u0026#34;调试日志\u0026#34;); logger.info(\u0026#34;信息日志\u0026#34;); logger.warn(\u0026#34;警告日志\u0026#34;); logger.error(\u0026#34;错误日志\u0026#34;); 四、分页 4.1 limit select*fromuserslimt5#从0到5select*fromuserslimit1,5#从第一条到第五条4.2 PageHelper分页插件 官网地址：https://pagehelper.github.io/\n添加依赖 \u0026lt;!--Mybaits分页查件--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.pagehelper\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pagehelper\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Mybatis配置插件 typeAliases 之后\nenvironments 之前\n\u0026lt;!--MyBatis的插件配置--\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin interceptor=\u0026#34;com.github.pagehelper.PageInterceptor\u0026#34;\u0026gt; \u0026lt;!--表示使用mysql的分页方法--\u0026gt; \u0026lt;property name=\u0026#34;helperDialect\u0026#34; value=\u0026#34;mysql\u0026#34;/\u0026gt; \u0026lt;!--表示当前页码长度为0的时候就不行行分页--\u0026gt; \u0026lt;property name=\u0026#34;pageSizeZero\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; 使用 @Test public void test2(){ //调用工具类 得到sqlSession  SqlSession sqlSession = MyBatisUtils.getSqlSession(); //加载dao层映射  MoneyDao mapper = sqlSession.getMapper(MoneyDao.class); //分页第一步 调用接口之前开启分页  PageHelper.startPage(1,5); List\u0026lt;UserEx\u0026gt; userExes = mapper.selectUserMoneyPage(); //分页第二步，对拿到的数据进行处理  PageInfo\u0026lt;UserEx\u0026gt; userExPageInfo = new PageInfo\u0026lt;UserEx\u0026gt;(userExes); logger.info(\u0026#34;总条数\u0026#34;+userExPageInfo.getTotal()); for (UserEx userEx : userExPageInfo.getList()) { System.out.println(\u0026#34;userEx = \u0026#34; + userEx); } //手动关闭sqlsession(学到了spring过后就不需要了)  sqlSession.close(); } 五、常用插件 5.1、Lombok \u0026lt;!--Lombok偷懒插件--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.12\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 进行简单配置\n image-20211018160221472 \n下载IDEA的Lombok的插件支持\n image-20211018160411766 \n使用 package com.xxgc.mybatis.po; import lombok.Getter; import lombok.Setter; import lombok.ToString; /* alt + insert 生成构造函数 */ @Setter @Getter //of={\u0026#34;uName\u0026#34;,\u0026#34;uPass\u0026#34;} 只想要这两个字段 //exclude={\u0026#34;uPass\u0026#34;} 排除字段 @ToString(exclude={\u0026#34;uPass\u0026#34;}) public class User { private long uId; private String uName; private String uPass; } 5.2 TableGo 偷懒工具 可以生成数据库文档\n官网：http://www.tablego.cn/\n六、注解增删改查 6.1 简单使用 需要在Dao层接口上添加 @Select @Insert @Update @Delete\n需要在mybatis-config.xml中配置\n\u0026lt;mappers\u0026gt; \u0026lt;mapper class=\u0026#34;com.xxgc.mybatis.dao.UserDao\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; 6.2 Select查询 在进行多表联合查询的时候，遇到字段不匹配可以使用\n@Results(id = \u0026#34;UserExMap\u0026#34;, value = { @Result(column = \u0026#34;数据库字段名\u0026#34;,property = \u0026#34;类属性名\u0026#34;), @Result(column = \u0026#34;m_money\u0026#34;,property = \u0026#34;money\u0026#34;), @Result(column = \u0026#34;m_type\u0026#34;,property = \u0026#34;type\u0026#34;) }) 注意：只需要配置一次，如果还需要使用的地方用\n@ResultMap(\u0026#34;UserExMap\u0026#34;) 6.3 使用注解进行sql拼接 方法一 //type 类名 method方法名 @SelectProvider(type = UserProvider.class,method = \u0026#34;selectUser\u0026#34;) List\u0026lt;User\u0026gt; selectUserByAttr(@Param(\u0026#34;uId\u0026#34;) int uId, @Param(\u0026#34;uName\u0026#34;)String uName); /*内部内*/ class UserProvider{ /*自定义的方法*/ public String selectUser(Map\u0026lt;String,Object\u0026gt; map){ String sql = \u0026#34;select * from users where 1 = 1 \u0026#34;; if(map.get(\u0026#34;uId\u0026#34;) != null){ sql += \u0026#34;and u_id = #{uId} \u0026#34;; } if(map.get(\u0026#34;uName\u0026#34;) != null \u0026amp;\u0026amp; map.get(\u0026#34;uName\u0026#34;) != \u0026#34;\u0026#34;){ sql += \u0026#34;and u_name = #{uName} \u0026#34;; } return sql; } } 方法二 @Select({ \u0026#34;\u0026lt;script\u0026gt;\u0026#34;, \u0026#34;select * from users\u0026#34;, \u0026#34;\u0026lt;where\u0026gt;\u0026#34;, \u0026#34;\u0026lt;if test=\u0026#39;uId != null\u0026#39;\u0026gt;\u0026#34;, \u0026#34;and u_id = #{uId}\u0026#34;, \u0026#34;\u0026lt;/if\u0026gt;\u0026#34;, \u0026#34;\u0026lt;if test=\u0026#39;uName != null\u0026#39;\u0026gt;\u0026#34;, \u0026#34;and u_name = #{uName}\u0026#34;, \u0026#34;\u0026lt;/if\u0026gt;\u0026#34;, \u0026#34;\u0026lt;/where\u0026gt;\u0026#34;, \u0026#34;\u0026lt;/script\u0026gt;\u0026#34; }) List\u0026lt;User\u0026gt; selectUserByAttr2(@Param(\u0026#34;uId\u0026#34;) int uId, @Param(\u0026#34;uName\u0026#34;)String uName); 七、 Mybatis处理表关联关系 7.1 一对一关系的处理 \u0026lt;select id=\u0026#34;selectMoneyAndUser\u0026#34; resultMap=\u0026#34;getMoney\u0026#34;\u0026gt; SELECT * FROM `money` \u0026lt;/select\u0026gt; \u0026lt;resultMap id=\u0026#34;getMoney\u0026#34; type=\u0026#34;Money\u0026#34;\u0026gt; \u0026lt;!--property和bean类字段对应--\u0026gt; \u0026lt;!--column 和user表相关联的字段--\u0026gt; \u0026lt;!--javaType bean类的字段类型--\u0026gt; \u0026lt;!--select 使用哪个查询语句--\u0026gt; \u0026lt;association property=\u0026#34;user\u0026#34; column=\u0026#34;m_user_id\u0026#34; javaType=\u0026#34;User\u0026#34; select=\u0026#34;selectUser\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;selectUser\u0026#34; resultType=\u0026#34;User\u0026#34;\u0026gt; select * from users where u_id = #{m_user_id} \u0026lt;/select\u0026gt; List\u0026lt;Money\u0026gt; selectMoneyAndUser(); package com.xxgc.mybatis.po; import lombok.Getter; import lombok.Setter; import lombok.ToString; //Money表的映射 @Setter @Getter @ToString public class Money { private long mId; private long mUserId; private int mMoney; private String mType; //一笔钱对应一个用户  private User user; } 7.2 一对多关系处理 \u0026lt;resultMap id=\u0026#34;getMoney\u0026#34; type=\u0026#34;User\u0026#34;\u0026gt; \u0026lt;id column=\u0026#34;u_id\u0026#34; property=\u0026#34;uId\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;u_name\u0026#34; property=\u0026#34;uName\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;u_pass\u0026#34; property=\u0026#34;uPass\u0026#34;/\u0026gt; \u0026lt;!--property和bean属性名对应--\u0026gt; \u0026lt;collection property=\u0026#34;moneyList\u0026#34; javaType=\u0026#34;List\u0026#34; ofType=\u0026#34;Money\u0026#34;\u0026gt; \u0026lt;id column=\u0026#34;m_id\u0026#34; property=\u0026#34;mId\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;m_user_id\u0026#34; property=\u0026#34;mUserId\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;m_money\u0026#34; property=\u0026#34;mMoney\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;m_type\u0026#34; property=\u0026#34;mType\u0026#34;/\u0026gt; \u0026lt;/collection\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;selectUserAndMoney\u0026#34; resultMap=\u0026#34;getMoney\u0026#34;\u0026gt; SELECT * FROM `users`,`money` WHERE `u_id`= `m_user_id` \u0026lt;/select\u0026gt; //查询用户顺便查询用户的Money List\u0026lt;User\u0026gt; selectUserAndMoney(); package com.xxgc.mybatis.po; import lombok.Getter; import lombok.Setter; import lombok.ToString; import java.util.List; /* alt + insert 生成构造函数 */ @Setter @Getter //of={\u0026#34;uName\u0026#34;,\u0026#34;uPass\u0026#34;} 只想要这两个字段 //exclude={\u0026#34;uPass\u0026#34;} 排除字段 @ToString(exclude={\u0026#34;uPass\u0026#34;}) public class User { private long uId; private String uName; private String uPass; private List\u0026lt;Money\u0026gt; moneyList; } 八、Sql条件查询 创建news表\nCREATETABLE`news`(`n_id`bigint(18)NOTNULLAUTO_INCREMENTCOMMENT\u0026#39;新闻id\u0026#39;,`n_title`varchar(300)NOTNULLCOMMENT\u0026#39;新闻标题\u0026#39;,`n_content`varchar(1000)NOTNULLCOMMENT\u0026#39;新闻内容\u0026#39;,`n_author`varchar(30)NOTNULLCOMMENT\u0026#39;作者\u0026#39;,PRIMARYKEY(`n_id`))ENGINE=InnoDBDEFAULTCHARSET=utf8COMMENT=\u0026#39;新闻表\u0026#39;8.1 if标签 \u0026lt;if test=\u0026#34;属性 != null\u0026#34;\u0026gt; \u0026lt;/if\u0026gt; 判断一个属性值是否为空，来拼接sql语句\n8.2 where标签 \u0026lt;where\u0026gt;\u0026lt;/where\u0026gt; 用来代替传统sql语句中的where关键词，它可以在有条件的时候自动追加，没有条件的时候自动取消，可以把第一个条件的and给删除掉。\n8.3 choose、when、otherwise标签 \u0026lt;where\u0026gt; \u0026lt;choose\u0026gt; \u0026lt;when test=\u0026#34;属性 != null\u0026#34;\u0026gt; and 数据库字段 = #{属性} \u0026lt;/when\u0026gt; \u0026lt;when test=\u0026#34;nContent != null\u0026#34;\u0026gt; and n_content = #{nContent} \u0026lt;/when\u0026gt; \u0026lt;otherwise\u0026gt; and n_author = \u0026#34;张三\u0026#34; \u0026lt;/otherwise\u0026gt; \u0026lt;/choose\u0026gt; \u0026lt;/where\u0026gt; 它有点像 Java 中的 switch 语句，当有一个when执行的时候，下面的otherwise就不会执行。\n使用场景：当查询某些数据的时候，需要控制权限，什么条件都不给还是得追加一个条件。\n8.4 sql、include标签 \u0026lt;sql id=\u0026#34;select-news\u0026#34;\u0026gt; SELECT * FROM `news` \u0026lt;/sql\u0026gt; 可以把重复的sql语句（可以加标签）放到这个sql标签里面，写上id\n\u0026lt;include refid=\u0026#34;select-news\u0026#34;\u0026gt;\u0026lt;/include\u0026gt; 在下面需要使用到的地方只需要写include\n8.5 set标签 \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;nTitle != null\u0026#34;\u0026gt; `n_title` = #{nTitle}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;nContent != null\u0026#34;\u0026gt; `n_content` = #{nContent}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;nAuthor != null\u0026#34;\u0026gt; `n_author` = #{nAuthor} \u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; 当在做更新的时候，不知道是哪个字段进行的更新，需要使用到if判断，但是使用if判断过后会有逗号的拼接问题，可以使用标签解决。\n8.6 foreach标签 \u0026lt;!--collection 传入类型 1.如果传入参数类型是一个List的时候，collection属性值为list 2.如果传入参数类型是一个array数组的时候，属性值为array 3.如果想传入多个参数请使用Map集合 index 当前下标 itme 循环条目 open 以什么开始 separator 分隔符 close 以什么结束--\u0026gt; \u0026lt;select id=\u0026#34;selectUserByIds\u0026#34; parameterType=\u0026#34;List\u0026#34; resultType=\u0026#34;User\u0026#34;\u0026gt; SELECT * FROM `users` WHERE `u_id` IN \u0026lt;foreach collection=\u0026#34;list\u0026#34; index=\u0026#34;index\u0026#34; item=\u0026#34;item\u0026#34; open=\u0026#34;(\u0026#34; separator=\u0026#34;,\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; #{item} \u0026lt;/foreach\u0026gt; \u0026lt;/select\u0026gt; 九、Mybatis缓存 什么是缓存？ 缓存是一种数据和处理中心的一个中间件，从缓存查询可以提高效率，可以最大程度使用性能。\n为什么使用缓存？ 减少和数据库的交互次数，减少系统开销，提高系统效率。\n什么样的数据能使用缓存？ 经常查询并且不容易发生改变的数据。\nmybatis缓存   MyBatis包含一个非常强大的查询缓存特性，它可以非常方便的定制和配置缓存，缓存可以极大的提升查询效率。\n  Mybatis框架默认定义了两级缓存：一级缓存和二级缓存\n默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）\n二级缓存需要手动开启和配置，他是基于namespace级别的缓存\n为了提高扩展，Mybatis定义了缓存接口Cache。我们可以通过实现Cache接口来定义二级缓存\n  9.1 一级缓存 ​\t一级缓存也叫本地缓存：\n​\t与数据库在一次会话期间查询到的数据会放到缓存中。\n​\t以后如果需要获取相同数据，会直接从缓存中拿，没必要再去查询数据库。\n​\t注意：\n​\t必须保证多次查询中间，不能有任何的增删改操作，否则缓存数据会清空。\n//手动清理缓存 sqlSession.clearCache(); 9.2 二级缓存 二级缓存使用 1、要启用全局的二级缓存，只需要在你的 SQL 映射文件中添加一行：\n\u0026lt;!--开启二级缓存--\u0026gt; \u0026lt;cache/\u0026gt; 配置缓存\n\u0026lt;cache eviction=\u0026#34;FIFO\u0026#34; flushInterval=\u0026#34;60000\u0026#34; size=\u0026#34;512\u0026#34; readOnly=\u0026#34;true\u0026#34;/\u0026gt; eviction 配置缓存策略\n LRU – 最近最少使用：移除最长时间不被使用的对象。 FIFO – 先进先出：按对象进入缓存的顺序来移除它们。 SOFT – 软引用：基于垃圾回收器状态和软引用规则移除对象。 WEAK – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。  flushInterval 刷新间隔\nsize 缓存可用空间\nreadOnly 只读 会返回相同实例（因为这些实例是不可修改的）\nreadOnly 查询出来的实例是可以修改的，但是如果为false两个实例不相同。\n二级缓存总结： 业务逻辑层去拿数据的时候，会先看二级缓存里面有没有东西，如果有就返回，如果没有就查询，并把查询结果返回给二级缓存。\n9.3 Mybaits缓存插件 ehcache \u0026lt;!-- Mybaits的二级缓存插件EhCache --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.caches\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-ehcache\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--第三方二级缓存--\u0026gt; \u0026lt;cache type=\u0026#34;org.mybatis.caches.ehcache.EhBlockingCache\u0026#34;/\u0026gt; 创建一个配置文件ehcache.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;ehcache\u0026gt; \u0026lt;!-- 配置缓存文件的路劲 java.io.tmpdir，表示临时文件夹，windows表示在C:\\Documents and Settings\\Administrator\\Local Setting\\Temp --\u0026gt; \u0026lt;diskStore path=\u0026#34;../temp/ehcache\u0026#34;/\u0026gt; \u0026lt;!-- 设定缓存的默认数据过期策略 --\u0026gt; \u0026lt;!-- name:缓存名称 maxElementsInMemory：缓存最大个数 eternal:对象是否永久有效，一但设置了，timeout将不起作用 timeToIdleSeconds：设置对象在失效前的允许闲置时间（单位：秒）,仅当eternal=false对象不是永久有效时使用 timeToLiveSeconds：设置对象在失效前允许存活时间,最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用 overflowToDisk：当内存中对象数量达到maxElementsInMemory时，Ehcache将会对象写到磁盘中 diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB maxElementsOnDisk：硬盘最大缓存个数 diskPersistent： 是否缓存虚拟机重启期数据 diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒 memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU。 最近使用(LRU)\u0026#34;策略,其它还有先入先出FIFO,最少使用LFU,较少使用LRU clearOnFlush：内存数量最大时是否清除 --\u0026gt; \u0026lt;defaultCache maxElementsInMemory=\u0026#34;1000\u0026#34; eternal=\u0026#34;false\u0026#34; overflowToDisk=\u0026#34;true\u0026#34; timeToIdleSeconds=\u0026#34;300\u0026#34; timeToLiveSeconds=\u0026#34;600\u0026#34; diskPersistent=\u0026#34;false\u0026#34; diskExpiryThreadIntervalSeconds=\u0026#34;120\u0026#34;/\u0026gt; \u0026lt;cache name=\u0026#34;userCache\u0026#34; maxElementsInMemory=\u0026#34;1000\u0026#34; eternal=\u0026#34;false\u0026#34; overflowToDisk=\u0026#34;true\u0026#34; timeToIdleSeconds=\u0026#34;300\u0026#34; timeToLiveSeconds=\u0026#34;600\u0026#34; memoryStoreEvictionPolicy=\u0026#34;LRU\u0026#34;/\u0026gt; \u0026lt;/ehcache\u0026gt; 2、开启全局缓存\n\u0026lt;!--常用设置--\u0026gt; \u0026lt;settings\u0026gt; \u0026lt;!--开启驼峰命名--\u0026gt; \u0026lt;setting name=\u0026#34;mapUnderscoreToCamelCase\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;!--配置mybatis的日志输出方式--\u0026gt; \u0026lt;setting name=\u0026#34;logImpl\u0026#34; value=\u0026#34;LOG4J\u0026#34;/\u0026gt; \u0026lt;!--开启全局缓存--\u0026gt; \u0026lt;setting name=\u0026#34;cacheEnabled\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; 附录 1.IDEA常用快捷键 alt + insert 生成构造函数 ctrl + alt + f 提取/抽取 全局变量 ctrl + alt + v 自动生成返回结果 ctrl + alt + t 常用包裹代码生成 iter 生成foreach循环 2.IDEA配置自动导包  image-20211009114132613 \n","date":"0001-01-01T00:00:00Z","permalink":"https://example.com/p/","title":""}]