[{"content":"什么是存储过程 是一种在数据库中存储复杂程序，以便外部调用的一种数据库对象 存储过程思想上很简单，就是数据库SQL语言层面的代码封装与重用。\n优点  可封装，并隐藏复杂的商业逻辑。 并可以接受参数，可以有返回值。 存储过程无法使用 SELECT 指令来运行，因为它是子程序，与查看表，数据表或用户定义函数不同。 存储过程可以用在数据检验，强制实行商业逻辑等。  缺点  存储过程，往往定制化于特定的数据库上，因为支持的编程语言不同。当切换到其他厂商的数据库系统时，需要重写原有的存储过程。 存储过程的性能调校与撰写，受限于各种数据库系统。  声明一个存储过程 DELIMITER$$CREATE-- 声明一个储存过程 PROCEDURE 库名.函数名(参数) -- in：这个参数是一个传入值 -- out：这个参数是个返回值 -- outin：表示这个参数既是输入值，也是返回值（使用时需要传入的是变量，而不是一个确切的数值） PROCEDURE`demo`.`myinout`(INidINT,OUTucommINT,INOUTnumberINT)BEGINSETucomm=number;SETnumber=number+100;END$$DELIMITER;SET@number=100;CALLmyinout(1,100,@number);SELECT@number;","date":"2021-09-29T17:06:44+08:00","permalink":"https://example.com/p/mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/","title":"Mysql存储过程"},{"content":"什么是函数？ 函数类似于Java方法，可以传值，也有返回值，配合查询做一些复杂计算。\n创建一个自定义函数 DELIMITER$$CREATE/*函数 库+函数名(参数名 类型)*/FUNCTION`demo`.`usermoney`(numberINT)/*返回值类型(varchar类型需要指定长度)*/RETURNSINT/*开始*/BEGIN/*返回 要执行的sql语句*/RETURN(number*100);/*结束*/END$$DELIMITER;函数的使用 select之后接函数名(参数)，与mysql内置函数使用方法一致\nSELECTusermoney(`u_money`)FROM`users`在函数中创建变量 变量的声明需要放在要执行的sql语句的头部\n/*创建一个变量 使用 DECLARE 关键字*/DECLAREnewmenberVARCHAR(30)DEFAULT\u0026#34;普通用户\u0026#34;;mysql内置常用函数 MySQL 数值型函数    函数名称 作 用     ABS 求绝对值   SQRT 求二次方根   MOD 求余数   CEIL 和 CEILING 两个函数功能相同，都是返回不小于参数的最小整数，即向上取整   FLOOR 向下取整，返回值转化为一个BIGINT   RAND 生成一个0~1之间的随机数，传入整数参数是，用来产生重复序列   ROUND 对所传参数进行四舍五入   SIGN 返回参数的符号   POW 和 POWER 两个函数的功能相同，都是所传参数的次方的结果值   SIN 求正弦值   ASIN 求反正弦值，与函数 SIN 互为反函数   COS 求余弦值   ACOS 求反余弦值，与函数 COS 互为反函数   TAN 求正切值   ATAN 求反正切值，与函数 TAN 互为反函数   COT 求余切值    MySQL 字符串函数    函数名称 作 用     LENGTH 计算字符串长度函数，返回字符串的字节长度   CONCAT 合并字符串函数，返回结果为连接参数产生的字符串，参数可以使一个或多个   INSERT 替换字符串函数   LOWER 将字符串中的字母转换为小写   UPPER 将字符串中的字母转换为大写   LEFT 从左侧字截取符串，返回字符串左边的若干个字符   RIGHT 从右侧字截取符串，返回字符串右边的若干个字符   TRIM 删除字符串左右两侧的空格   REPLACE 字符串替换函数，返回替换后的新字符串   SUBSTRING 截取字符串，返回从指定位置开始的指定长度的字符换   REVERSE 字符串反转（逆序）函数，返回与原始字符串顺序相反的字符串    MySQL 日期和时间函数    函数名称 作 用     CURDATE 和 CURRENT_DATE 两个函数作用相同，返回当前系统的日期值   CURTIME 和 CURRENT_TIME 两个函数作用相同，返回当前系统的时间值   NOW 和 SYSDATE 两个函数作用相同，返回当前系统的日期和时间值   UNIX_TIMESTAMP 获取UNIX时间戳函数，返回一个以 UNIX 时间戳为基础的无符号整数   FROM_UNIXTIME 将 UNIX 时间戳转换为时间格式，与UNIX_TIMESTAMP互为反函数   MONTH 获取指定日期中的月份   MONTHNAME 获取指定日期中的月份英文名称   DAYNAME 获取指定曰期对应的星期几的英文名称   DAYOFWEEK 获取指定日期对应的一周的索引位置值   WEEK 获取指定日期是一年中的第几周，返回值的范围是否为 0〜52 或 1〜53   DAYOFYEAR 获取指定曰期是一年中的第几天，返回值范围是1~366   DAYOFMONTH 获取指定日期是一个月中是第几天，返回值范围是1~31   YEAR 获取年份，返回值范围是 1970〜2069   TIME_TO_SEC 将时间参数转换为秒数   SEC_TO_TIME 将秒数转换为时间，与TIME_TO_SEC 互为反函数   DATE_ADD 和 ADDDATE 两个函数功能相同，都是向日期添加指定的时间间隔   DATE_SUB 和 SUBDATE 两个函数功能相同，都是向日期减去指定的时间间隔   ADDTIME 时间加法运算，在原始时间上添加指定的时间   SUBTIME 时间减法运算，在原始时间上减去指定的时间   DATEDIFF 获取两个日期之间间隔，返回参数 1 减去参数 2 的值   DATE_FORMAT 格式化指定的日期，根据参数返回指定格式的值   WEEKDAY 获取指定日期在一周内的对应的工作日索引    MySQL 聚合函数    函数名称 作用     MAX 查询指定列的最大值   MIN 查询指定列的最小值   COUNT 统计查询结果的行数   SUM 求和，返回指定列的总和   AVG 求平均值，返回指定列数据的平均值    MySQL 流程控制函数    函数名称 作用     IF 判断，流程控制   IFNULL 判断是否为空   CASE 搜索语句    ","date":"2021-09-28T23:11:13+08:00","permalink":"https://example.com/p/mysql%E5%87%BD%E6%95%B0/","title":"Mysql函数"},{"content":"什么是事件？ 是MySQL5.1新增的事件也叫做定时任务，事件调度器,是一组SQL集，用来执行定时任务，跟触发器很像，都是被动执行的，事件由时间触发执行，而触发器是由事件（增删改）触发执行；\n查看事件是否开启  SHOW VARIABLES LIKE 'event_scheduler';\n开启事件:SET GLOBAL event_scheduler = ON/1; SET @@global.event_scheduler = ON/1;\n关闭事件:SET GLOBAL event_scheduler = OFF/0; SET @@global.event_scheduler = OFF/0;\n 查看事件  查看当前所在数据库的事件:\nSHOW EVENTS; SHOW PROCESSLIST; \n查看数据库中所有的事件:\nSELECT * FROM mysql.event;\n 事件的控制  临时关闭/打开事件 ALTER EVENT 事件名 DISABLE/ENABLE; 删除事件 DROP EVENT 事件名;\n 定时执行事件 DELIMITER$$/*创建定时事件*/CREATEEVENT`demo`.`comm`/*指定时间执行*/ONSCHEDULEAT\u0026#39;2021-09-27 16:34:00\u0026#39;/*完成时不保留启用 执行完成之后删除事件*/ONCOMPLETIONNOTPRESERVEENABLEDOBEGINUPDATE`commodity`SET`c_number`=1;END$$DELIMITER;循环执行事件 DELIMITER$$/*创建事件*/CREATEEVENT`demo`.`addmoeny`/*循环执行 间隔时间为1天*/ONSCHEDULEEVERY\u0026#39;1\u0026#39;DAY/*SECOND(秒)*//*循环的开始时间*/STARTS\u0026#39;2021-09-27 00:00:00\u0026#39;/*循环的结束时间*/ENDS\u0026#39;2022-04-29 00:00:00\u0026#39;/*完成时不保留启用*/ONCOMPLETIONNOTPRESERVEENABLE/*开始*/DOBEGINUPDATEmyuserSET`u_money`=`u_money`+10;/*结束*/END$$DELIMITER;","date":"2021-09-27T20:01:36+08:00","permalink":"https://example.com/p/mysql%E4%BA%8B%E5%8A%A1/","title":"Mysql事务"},{"content":"数据库主从异常问题不同步问题 数据库主从异常问题\n场景描述：在使用web功能时发现刚添加的数据在列表中没有展示，或者有时候展示有时候不展示（多个从库时出现）\n如何查找问题：  这时我们已经怀疑可能从库延迟了，我们需要确认下是延迟问题还是同步中断\n我们需要链接到从库执行命令：\nshow slave status\\G\n来查看从库同步情况\n 同步中断问题  如果Slave_IO_Running （负责与主机的io通信）\nSlave_SQL_Running （负责自己的slave mysql进程）\n这两个参数如果有一个是no的，说明同步已经中断了。\n这时我们需要去看Last_Errno(错误码) Last_Error（错误信息），来确定什么原因导致的错误。\n接下来我们可以通过以下命令跳过错误，让同步正常执行\n/*停止同步*/stopslave/*设置跳过错误*/setglobalsql_slave_skip_counter=1;/*开始同步*/startslave 同步延迟问题  当我们发现Master_Log_File参数和Relay_Master_Log_File参数不一致或者Read_Master_Log_Pos和Relay_Log_Pos参数相差很大时，这表明从库延迟了\n  这时我们先确认是主库导致的还是从库自身导致的，我们可以通过查看服务器负载来定位问题，使用命令top和iotop来分别查看cpu和io的使用情况\n  定位到具体服务器后，在数据库中执行show full processlist来查看当前查询语句中执行时间较长的语句，定位后再做优化就可以了，有时可能慢sql已经执行完了，\n  我们使用命令看不到慢sql，那我们就需要到mysql慢日志中去查看最近产生的慢日志，对慢sql进行优化\n ","date":"2021-09-27T19:55:16+08:00","permalink":"https://example.com/p/mysql%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8D%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/","title":"Mysql主从数据库不同步问题"},{"content":"说明： 在项目部署到生产环境时，会有很多不可抗力的因素，数据库会出现崩溃停止运行数据丢失，数据对不上的问题，这个时候就需要两个数据库同步运行，来确保一个数据库崩溃另一个能马上顶上。\n部署步骤： 在windows下部署: 配置文件位于mysql的安装目录下\n在linux下部署: 配置文件位于/etc/my.cnf (不同linux发行版可能会有所不同)\n配置主库    停止主库的mysql进程\nnet stop mysql1\n  配置my.ini文件\n#主数据库端ID号 server_id=1#开启二进制日志 log-bin=mysql-bin#需要复制的数据库名，如果复制多个数据库，重复设置这个选项即可(或者多个库用逗号隔开) #binlog-do-db = db #不需要复制的库，和上项同理 #binlog-ignore-db=mysql #将从服务器从主服务器收到的更新记入到从服务器自己的二进制日志文件中 #log-slave-updates #控制binlog的写入频率。每执行多少次事务写入一次(这个参数性能消耗很大，但可减小MySQL崩溃造成的损失) #sync_binlog = 1 #这个参数一般用在主主同步中，用来错开自增值, 防止键值冲突 #auto_increment_offset = 1 #这个参数一般用在主主同步中，用来错开自增值, 防止键值冲突 #auto_increment_increment = 1 #二进制日志自动删除的天数，默认值为0,表示“没有自动删除”，启动时和二进制日志循环时可能删除 #expire_logs_days = 7 #将函数复制到slave #log_bin_trust_function_creators = 1   保存修改后的配置，重启mysql服务\nnet start mysql\n  登陆到主机的数据库，并建立一个用户给从库连接使用\n允许所有ip连接GRANTREPLICATIONSLAVEON*.*TO\u0026#39;myslave\u0026#39;@\u0026#39;%\u0026#39;IDENTIFIEDBY\u0026#39;123456\u0026#39;;指定ip的做法GRANTREPLICATIONSLAVEON*.*TOmyslave@\u0026#39;192.168.41.0/255.255.255.0\u0026#39;IDENTIFIEDBY\u0026#39;123456\u0026#39;;  myslave是用户名\n  123456密码是用户对应的密码\n  192.168.41.0是ip地址\n    更新数据库权限\nflush privileges;\n  找到File 和 Position 的值\nshow master status\\G;\n   配置从库    停止从库mysql服务\nnet stop mysql\n  配置从库my.ini\nserver_id=2#log-bin = mysql-bin #log-slave-updates #sync_binlog = 0 #log buffer将每秒一次地写入log file中，并且log file的flush(刷到磁盘)操作同时进行。该模式下在事务提交的时候，不会主动触发写入磁盘的操作 #innodb_flush_log_at_trx_commit = 0 #指定slave要复制哪个库 #replicate-do-db = db #MySQL主从复制的时候，当Master和Slave之间的网络中断，但是Master和Slave无法察觉的情况下（比如防火墙或者路由问题）。Slave会等待slave_net_timeout设置的秒数后，才能认为网络出现故障，然后才会重连并且追赶这段时间主库的数据 #slave-net-timeout = 60 #log_bin_trust_function_creators = 1   重启从库mysql服务\nnet start mysql\n  登陆到从库的数据库并执行同步命令\n#执行同步命令，设置主服务器ip，同步账号密码，同步位置 changemastertomaster_host=\u0026#39;ip地址\u0026#39;,master_user=\u0026#39;用户名\u0026#39;,master_password=\u0026#39;密码\u0026#39;,master_log_file=\u0026#39;mysql-bin.主库查看的值\u0026#39;,master_log_pos=主库查询出来的值;#开启同步功能 startslave;#关闭 stopslave;  查看从库状态\nmysql\u0026gt;showslavestatus\\G;***************************1.row***************************Slave_IO_State:WaitingformastertosendeventMaster_Host:10.10.20.111Master_User:accountMaster_Port:3306Connect_Retry:60Master_Log_File:mysql-bin.000033Read_Master_Log_Pos:337523Relay_Log_File:db2-relay-bin.000002Relay_Log_Pos:337686Relay_Master_Log_File:mysql-bin.000033Slave_IO_Running:YesSlave_SQL_Running:YesReplicate_Do_DB:Replicate_Ignore_DB:...Slave_IO_Running及Slave_SQL_Running进程必须正常运行，即Yes状态，否则说明同步失败 若失败查看mysql错误日志中具体报错详情来进行问题定位 最后可以去主服务器上的数据库中创建表或者更新表数据来测试同步\n   ","date":"2021-09-26T21:02:53+08:00","permalink":"https://example.com/p/mysql%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE/","title":"Mysql主从数据库配置"},{"content":"什么是视图？ mysql的视图的5.0.1版本之后开始提供的。 视图（View）是一种虚拟存在的表，并不在数据库中实际存在，视图中的数据会在使用视图时动态生成。\n/*创建视图*/CREATE/*视图算法*//*[ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] 视图定义者 [DEFINER = { user | CURRENT_USER }] sql的安全性 [SQL SECURITY { DEFINER | INVOKER }]*//*数据库+视图名字*/VIEW`demo`.`statisticsview`AS/*要使用哪些数据生成视图*/(SELECTCOUNT(*)ASusers,SUM(`f_quota`)ASflowersFROM`user`,`flowers`WHERE`f_mapping_user`=`u_id`);查询视图 和普通的表查询一样，使用SELECT 即可\nSELECT*FROMstatisticsview","date":"2021-09-26T20:56:53+08:00","permalink":"https://example.com/p/mysql%E8%A7%86%E5%9B%BE/","title":"Mysql视图"},{"content":"事务\n  是什么是事务？ 事务就是一个完整的业务逻辑。\n 举例： 假如张三向李四转账100元。\n​\t1）张三账户扣100元\n​\t2）李四的账户加100元\n以上操作就是一个最小工作单元，要么同时成功要么同时失败，不可拆分。\n   事务支持\n 只有 INSERT DELETE UPDATE 以上三种语句和事务有关系。\n   事务是如何实现同时成功或同时失败？\n   \u0026gt; InnoDB存储引擎；提供一组用来记录事务性活动日志文件。 \u0026gt; \u0026gt; 提交事务： \u0026gt; \u0026gt; ​\t清空事务性活动日志文件，并彻底把数据持久化到表中。 \u0026gt; \u0026gt; 回滚事务： \u0026gt; \u0026gt; ​\t按文件进行回滚操作，并清空事务性活动日志文件。   如何提交事务，回滚事务？\n 提交事务： COMMIT 语句\n回滚事务： ROLLBACK 语句\n关闭默认提交： START TRANSACTION\n   事务包括4个特性\n A：原子性\n​\t说明事务是最小工作单元，不可再分。\nC：一致性\n​\t所有任务要求，在同一事务当中，所有操作必须同时成功，同时失败。\nI：隔离性\n​\tA事务和B事务之间有一定的隔离。\nD：\n​\t持久性 事务结束的一个保障。\n   重点研究事务的隔离性\n A和B事务之间有一道墙，墙可以很厚也可以很薄，墙越厚代表隔离级别越高。\n查询当前事务隔离级别\nSELECT @@tx_isolation\n设置全局事务隔离级别\nSET GLOBAL TRANSACTION ISOLATION LEVEL + 事务隔离级别\n   事务的隔离级别：\n   读未提交：``read uncommitted`。（最低隔离级别）\n什么叫读未提交： 事务A可以读取到事务B未提交的数据。\n问题： 脏读现象\n  读已提交 READ COMMITTED （只能读到提交之后的数据）\n解决的问题： 解决了脏读现象\n存在的问题： 第一次查询数据是三条，第二次查询数据可能是四条。\n不能重复读。 每一次读取的数据都是绝对真实的数据。 oracle数据库的默认隔离级别READ COMMITTED\n  可重复读 REPEATABLE READ 什么是可重复读？\n提交之后也读不到，永远读取的都是开启事务之前的数据。 mysql的默认事务级别 REPEATABLE READ 事务A开启之后，不管多久，每一次在数据A中读取的数据都是一致的。 即使事务B已经将数据修改，事务A读到的数据还是没有改变，这就叫 可重复读。\n问题：\n​\t出现幻影 读取到的数据都是幻象，不够真实。\n  序列化/串行化：``serializable` 这种是最高隔离级别，效率低，但是解决了所有问题。 这种隔离级别表示，事务排队，不能并发。\n优点：每一次读取到的都真实数据。\n缺点：效率太低。\n     ","date":"2021-09-23T14:04:12+08:00","permalink":"https://example.com/p/mysql%E4%BA%8B%E5%8A%A1/","title":"Mysql事务"},{"content":"触发器的概念：\n​\t触发器是一种特殊的存储过程，不同于存储过程，触发器是通过事件触发执行，而不是手动调用执行的。 什么事触发事件？ 触发器（trigger），是指表中内容发生改变（增、删、改）时，系统会自动触发并执行的事件。 作用： 1、可以在触发时，校验或转换数据，保证数据安全。 2、触发器发生错误时，前面用户执行成功的操作会被回滚。 \u0026hellip;\n表结构 CREATEDATABASEdemo;USE`demo`;CREATETABLE`user`(`u_id`BIGINT(18)NOTNULLAUTO_INCREMENTCOMMENT\u0026#39;用户id\u0026#39;,`u_name`VARCHAR(15)NOTNULLCOMMENT\u0026#39;用户名\u0026#39;,`u_sex`CHAR(1)NOTNULLDEFAULT\u0026#39;男\u0026#39;COMMENT\u0026#39;性别\u0026#39;,`u_createtime`DATETIMENOTNULLCOMMENT\u0026#39;创建时间\u0026#39;,`u_eff`INT(1)NOTNULLDEFAULT\u0026#39;1\u0026#39;COMMENT\u0026#39;有效\u0026#39;,PRIMARYKEY(`u_id`))CREATETABLE`flowers`(`f_id`BIGINT(18)NOTNULLAUTO_INCREMENTCOMMENT\u0026#39;花呗表id\u0026#39;,`f_credit_points`INT(4)NOTNULLCOMMENT\u0026#39;信用积分\u0026#39;,`f_quota`INT(5)NOTNULLCOMMENT\u0026#39;花呗额度\u0026#39;,`f_mapping_user`BIGINT(18)NOTNULLCOMMENT\u0026#39;用户id\u0026#39;,PRIMARYKEY(`f_id`))创建触发器 DELIMITER$$/*自定义结束符号*//*创建*/CREATE/*TRIGGER 触发器*//*库名+触发器名*//*BEFORE/AFTER 在sql之前执行还是之后执行*//*INSERT/UPDATE/DELETE触发条件*/TRIGGER`demo`.`userflowers`AFTERINSERT/*作用于哪个表*/ON`demo`.`user`/*每行都受影响，都执行，行级触发器*/FOREACHROWBEGIN/*触发执行的语句*/INSERTINTO`flowers`(`f_credit_points`,`f_quota`,`f_mapping_user`)VALUE(100,1000,new.u_id);END$$DELIMITER;执行语句 INSERTINTO`user`(`u_name`,`u_sex`,`u_createtime`)VALUE(\u0026#34;张三\u0026#34;,\u0026#34;女\u0026#34;,\u0026#34;2021-09-23 09:34:00\u0026#34;);1.   new和old的使用       INSERT 没有old只有new new表示将要插入或者已经插入的数据   UPDATE 既有old也有new old表示更新之前的数据 new表示更新之后的数据   DELETE 没有new只有old old表示删除前或已经被删除的数据    触发器条件使用if elseif else DELIMITER$$CREATETRIGGER`demo`.`userupdate`AFTERUPDATEON`demo`.`user`FOREACHROWBEGIN/*判断是否有效字段变为0*/IFnew.`u_eff`=0THEN/*删除花呗*/DELETEFROM`flowers`WHERE`f_mapping_user`=new.u_id;ELSEIFnew.`u_eff`=1THEN/*添加花呗*/INSERTINTO`flowers`(`f_credit_points`,`f_quota`,`f_mapping_user`)VALUE(100,1000,new.u_id);ELSE/*其它情况*/ENDIF;END$$DELIMITER;变量的使用 DELIMITER$$USE`demo`$$DROPTRIGGER/*!50032 IF EXISTS */`userflowers`$$CREATE/*!50017 DEFINER = \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; */TRIGGER`userflowers`AFTERINSERTON`user`FOREACHROWBEGIN/*触发执行的语句*/INSERTINTO`flowers`(`f_credit_points`,`f_quota`,`f_mapping_user`)VALUE(100,1000,new.u_id);/* 用户变量：以@开始，形式为 @变量名 用户变量只针对当前客户端生效 全局变量：定义方式 set GLOBAL 变量名，或者 set @@global.变量名 对所有客户端生效，但是具有super权限才可以设置全局变量 */SELECTCOUNT(*)FROMUSERINTO@num;UPDATE`statistics`SET`users`=@numWHEREs_id=1;END;$$DELIMITER;","date":"2021-09-23T13:31:02+08:00","permalink":"https://example.com/p/mysql%E8%A7%A6%E5%8F%91%E5%99%A8/","title":"Mysql触发器"},{"content":"AOP  什么是AOP  AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\n Aop在Spring中的作用  提供声明式事务；允许用户自定义切面\n以下名词需要了解下：\n 横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 \u0026hellip;. 切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。 通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。 目标（Target）：被通知对象。 代理（Proxy）：向目标对象应用通知之后创建的对象。 切入点（PointCut）：切面通知 执行的 “地点”的定义。 连接点（JointPoint）：与切入点匹配的执行点。  SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice:\n 前置增强 BeforeAdvice 代表前置增强，因为spring只支持方法级的增强，所以MethodBeforeAdvice 是目前可用前置增强，表示在目标方法执行前实施增强。 后置增强 AfterAdvice 代表后增强，表示目标方法在执行后实施增强 环绕增强 MethodInterceptor 代表环绕增强，表示目标方法执行前后实施增强 异常抛出增强 ThrowsAdvice 代表抛出异常增强，表示目标方法抛出异常后实施增强 引介增强 IntroductionInterceptor 代表引介增强，表示在目标类中添加一些新的方法和属性  即 Aop 在 不改变原有代码的情况下 , 去增加新的功能 .\n 使用Spring实现Aop  【重点】使用AOP织入，需要导入一个依赖包！\n\u0026lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 第一种方式\n通过 Spring API 实现\n首先编写我们的业务接口和实现类\npublic interface UserService { public void add(); public void delete(); public void update(); public void search(); } public class UserServiceImpl implements UserService{ @Override public void add() { System.out.println(\u0026#34;增加用户\u0026#34;); } @Override public void delete() { System.out.println(\u0026#34;删除用户\u0026#34;); } @Override public void update() { System.out.println(\u0026#34;更新用户\u0026#34;); } @Override public void search() { System.out.println(\u0026#34;查询用户\u0026#34;); } } 然后去写我们的增强类 , 我们编写两个 , 一个前置增强 一个后置增强\npublic class Log implements MethodBeforeAdvice { //method : 要执行的目标对象的方法  //objects : 被调用的方法的参数  //Object : 目标对象  @Override public void before(Method method, Object[] objects, Object o) throws Throwable { System.out.println( o.getClass().getName() + \u0026#34;的\u0026#34; + method.getName() + \u0026#34;方法被执行了\u0026#34;); } } public class AfterLog implements AfterReturningAdvice { //returnValue 返回值  //method被调用的方法  //args 被调用的方法的对象的参数  //target 被调用的目标对象  @Override public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable{ System.out.println(\u0026#34;执行了\u0026#34; + target.getClass().getName() +\u0026#34;的\u0026#34;+method.getName()+\u0026#34;方法,\u0026#34; +\u0026#34;返回值：\u0026#34;+returnValue); } } 最后去spring的文件中注册 , 并实现aop切入实现 , 注意导入约束 .\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;!--注册bean--\u0026gt; \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;com.kuang.service.UserServiceImpl\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;log\u0026#34; class=\u0026#34;com.kuang.log.Log\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;afterLog\u0026#34; class=\u0026#34;com.kuang.log.AfterLog\u0026#34;/\u0026gt; \u0026lt;!--aop的配置--\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!--切入点 expression:表达式匹配要执行的方法--\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;pointcut\u0026#34; expression=\u0026#34;execution(* com.kuang.service.UserServiceImpl.*(..))\u0026#34;/\u0026gt; \u0026lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026#34;log\u0026#34; pointcut-ref=\u0026#34;pointcut\u0026#34;/\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026#34;afterLog\u0026#34; pointcut-ref=\u0026#34;pointcut\u0026#34;/\u0026gt; \u0026lt;/aop:config\u0026gt; \u0026lt;/beans\u0026gt; 测试\npublic class MyTest { @Test public void test(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans.xml\u0026#34;); UserService userService = (UserService) context.getBean(\u0026#34;userService\u0026#34;); userService.search(); } } Aop的重要性 : 很重要 . 一定要理解其中的思路 , 主要是思想的理解这一块 .\nSpring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 .\n第二种方式\n自定义类来实现Aop\n目标业务类不变依旧是userServiceImpl\n第一步 : 写我们自己的一个切入类\npublic class DiyPointcut { public void before(){ System.out.println(\u0026#34;---------方法执行前---------\u0026#34;); } public void after(){ System.out.println(\u0026#34;---------方法执行后---------\u0026#34;); } } 去spring中配置\n\u0026lt;!--第二种方式自定义实现--\u0026gt; \u0026lt;!--注册bean--\u0026gt; \u0026lt;bean id=\u0026#34;diy\u0026#34; class=\u0026#34;com.kuang.config.DiyPointcut\u0026#34;/\u0026gt; \u0026lt;!--aop的配置--\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!--第二种方式：使用AOP的标签实现--\u0026gt; \u0026lt;aop:aspect ref=\u0026#34;diy\u0026#34;\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;diyPonitcut\u0026#34; expression=\u0026#34;execution(* com.kuang.service.UserServiceImpl.*(..))\u0026#34;/\u0026gt; \u0026lt;aop:before pointcut-ref=\u0026#34;diyPonitcut\u0026#34; method=\u0026#34;before\u0026#34;/\u0026gt; \u0026lt;aop:after pointcut-ref=\u0026#34;diyPonitcut\u0026#34; method=\u0026#34;after\u0026#34;/\u0026gt; \u0026lt;/aop:aspect\u0026gt; \u0026lt;/aop:config\u0026gt; 测试：\npublic class MyTest { @Test public void test(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans.xml\u0026#34;); UserService userService = (UserService) context.getBean(\u0026#34;userService\u0026#34;); userService.add(); } } 第三种方式\n使用注解实现\n第一步：编写一个注解实现的增强类\npackage com.kuang.config; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.After; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; @Aspect public class AnnotationPointcut { @Before(\u0026#34;execution(* com.kuang.service.UserServiceImpl.*(..))\u0026#34;) public void before(){ System.out.println(\u0026#34;---------方法执行前---------\u0026#34;); } @After(\u0026#34;execution(* com.kuang.service.UserServiceImpl.*(..))\u0026#34;) public void after(){ System.out.println(\u0026#34;---------方法执行后---------\u0026#34;); } @Around(\u0026#34;execution(* com.kuang.service.UserServiceImpl.*(..))\u0026#34;) public void around(ProceedingJoinPoint jp) throws Throwable { System.out.println(\u0026#34;环绕前\u0026#34;); System.out.println(\u0026#34;签名:\u0026#34;+jp.getSignature()); //执行目标方法proceed  Object proceed = jp.proceed(); System.out.println(\u0026#34;环绕后\u0026#34;); System.out.println(proceed); } } 第二步：在Spring配置文件中，注册bean，并增加支持注解的配置\n\u0026lt;!--第三种方式:注解实现--\u0026gt; \u0026lt;bean id=\u0026#34;annotationPointcut\u0026#34; class=\u0026#34;com.kuang.config.AnnotationPointcut\u0026#34;/\u0026gt; \u0026lt;aop:aspectj-autoproxy/\u0026gt; aop:aspectj-autoproxy：说明\n通过aop命名空间的\u0026lt;aop:aspectj-autoproxy /\u0026gt;声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。当然，spring 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工作，但具体实现的细节已经被\u0026lt;aop:aspectj-autoproxy /\u0026gt;隐藏起来了 \u0026lt;aop:aspectj-autoproxy /\u0026gt;有一个proxy-target-class属性，默认为false，表示使用jdk动态代理织入增强，当配为\u0026lt;aop:aspectj-autoproxy poxy-target-class=\u0026#34;true\u0026#34;/\u0026gt;时，表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。 到了这里，AOP的思想和使用相信大家就没问题了！\n","date":"2021-09-11T17:48:58+08:00","permalink":"https://example.com/p/spring07-aop%E4%BD%BF%E7%94%A8/","title":"Spring07 AOP使用"},{"content":"代理模式 为什么要学习代理模式，因为AOP的底层机制就是动态代理！\n代理模式：\n 静态代理 动态代理   静态代理  静态代理角色分析\n  抽象角色 : 一般使用接口或者抽象类来实现\n  真实角色 : 被代理的角色\n  代理角色 : 代理真实角色 ; 代理真实角色后 , 一般会做一些附属的操作 .\n  客户 : 使用代理角色来进行一些操作 .\n  代码实现\nRent . java 即抽象角色\n//抽象角色：租房 public interface Rent { public void rent(); } Host . java 即真实角色\n//真实角色: 房东，房东要出租房子 public class Host implements Rent{ public void rent() { System.out.println(\u0026#34;房屋出租\u0026#34;); } } Proxy . java 即代理角色\n//代理角色：中介 public class Proxy implements Rent { private Host host; public Proxy() { } public Proxy(Host host) { this.host = host; } //租房  public void rent(){ seeHouse(); host.rent(); fare(); } //看房  public void seeHouse(){ System.out.println(\u0026#34;带房客看房\u0026#34;); } //收中介费  public void fare(){ System.out.println(\u0026#34;收中介费\u0026#34;); } } Client . java 即客户\n//客户类，一般客户都会去找代理！ public class Client { public static void main(String[] args) { //房东要租房  Host host = new Host(); //中介帮助房东  Proxy proxy = new Proxy(host); //你去找中介！  proxy.rent(); } } 分析：在这个过程中，你直接接触的就是中介，就如同现实生活中的样子，你看不到房东，但是你依旧租到了房东的房子通过代理，这就是所谓的代理模式，程序源自于生活，所以学编程的人，一般能够更加抽象的看待生活中发生的事情。\n静态代理的好处:\n 可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 . 公共的业务由代理来完成 . 实现了业务的分工 , 公共业务发生扩展时变得更加集中和方便 .  缺点 :\n 类多了 , 多了代理类 , 工作量变大了 . 开发效率降低 .  我们想要静态代理的好处，又不想要静态代理的缺点，所以 , 就有了动态代理 !\n 静态代理再理解  同学们练习完毕后，我们再来举一个例子，巩固大家的学习！\n练习步骤：\n1、创建一个抽象角色，比如咋们平时做的用户业务，抽象起来就是增删改查！\n//抽象角色：增删改查业务 public interface UserService { void add(); void delete(); void update(); void query(); } 2、我们需要一个真实对象来完成这些增删改查操作\n//真实对象，完成增删改查操作的人 public class UserServiceImpl implements UserService { public void add() { System.out.println(\u0026#34;增加了一个用户\u0026#34;); } public void delete() { System.out.println(\u0026#34;删除了一个用户\u0026#34;); } public void update() { System.out.println(\u0026#34;更新了一个用户\u0026#34;); } public void query() { System.out.println(\u0026#34;查询了一个用户\u0026#34;); } } 3、需求来了，现在我们需要增加一个日志功能，怎么实现！\n 思路1 ：在实现类上增加代码 【麻烦！】 思路2：使用代理来做，能够不改变原来的业务情况下，实现此功能就是最好的了！  4、设置一个代理类来处理日志！代理角色\n//代理角色，在这里面增加日志的实现 public class UserServiceProxy implements UserService { private UserServiceImpl userService; public void setUserService(UserServiceImpl userService) { this.userService = userService; } public void add() { log(\u0026#34;add\u0026#34;); userService.add(); } public void delete() { log(\u0026#34;delete\u0026#34;); userService.delete(); } public void update() { log(\u0026#34;update\u0026#34;); userService.update(); } public void query() { log(\u0026#34;query\u0026#34;); userService.query(); } public void log(String msg){ System.out.println(\u0026#34;执行了\u0026#34;+msg+\u0026#34;方法\u0026#34;); } } 5、测试访问类：\npublic class Client { public static void main(String[] args) { //真实业务  UserServiceImpl userService = new UserServiceImpl(); //代理类  UserServiceProxy proxy = new UserServiceProxy(); //使用代理类实现日志功能！  proxy.setUserService(userService); proxy.add(); } } OK，到了现在代理模式大家应该都没有什么问题了，重点大家需要理解其中的思想；\n我们在不改变原来的代码的情况下，实现了对原有功能的增强，这是AOP中最核心的思想.\n 动态代理    动态代理的角色和静态代理的一样 .\n  动态代理的代理类是动态生成的 . 静态代理的代理类是我们提前写好的\n  动态代理分为两类 : 一类是基于接口动态代理 , 一类是基于类的动态代理\n   基于接口的动态代理\u0026mdash;-JDK动态代理 基于类的动态代理\u0026ndash;cglib 现在用的比较多的是 javasist 来生成动态代理 . 百度一下javasist 我们这里使用JDK的原生代码来实现，其余的道理都是一样的！、    JDK的动态代理需要了解两个类\n核心 : InvocationHandler 和 Proxy ， 打开JDK帮助文档看看\n【InvocationHandler：调用处理程序】是由代理实例去调用处理程序的接口，每个代理实例都有一个关联的抵用处理程序\nObject invoke(Object proxy, 方法 method, Object[] args)； //参数 //proxy - 调用该方法的代理实例 //method -所述方法对应于调用代理实例上的接口方法的实例。方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口。 //args -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean 。 【Proxy : 代理】提供了创建动态代理和实例的静态方法，他也就是由这些方法创建的所有动态代理程序的超类，每个代理实例程序都有一个关联的调用处理程序对象，他实现了InvocationHandler接口\n//生成代理类 // 参数1 - Loader 类加载器定义的代理类 // 参数2 - nterfaces 代理类实现的接口列表 // 参数3 - h 调度方法调用的调用处理函数 public Object getProxy(){ return Proxy.newProxyInstance(this.getClass().getClassLoader(),rent.getClass().getInterfaces(),this); } 代码实现\n抽象角色和真实角色和之前的一样！\nRent . java 即抽象角色\n//抽象角色：租房 public interface Rent { public void rent(); } Host . java 即真实角色\n//真实角色: 房东，房东要出租房子 public class Host implements Rent{ public void rent() { System.out.println(\u0026#34;房屋出租\u0026#34;); } } ProxyInvocationHandler. java 即代理角色\npublic class ProxyInvocationHandler implements InvocationHandler { private Rent rent; public void setRent(Rent rent) { this.rent = rent; } //生成代理类，重点是第二个参数，获取要代理的抽象角色！之前都是一个角色，现在可以代理一类角色  public Object getProxy(){ return Proxy.newProxyInstance(this.getClass().getClassLoader(), rent.getClass().getInterfaces(),this); } // proxy : 代理类 method : 代理类的调用处理程序的方法对象.  // 处理代理实例上的方法调用并返回结果  @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { seeHouse(); //核心：本质利用反射实现！  Object result = method.invoke(rent, args); fare(); return result; } //看房  public void seeHouse(){ System.out.println(\u0026#34;带房客看房\u0026#34;); } //收中介费  public void fare(){ System.out.println(\u0026#34;收中介费\u0026#34;); } } Client . java\n//租客 public class Client { public static void main(String[] args) { //真实角色  Host host = new Host(); //代理实例的调用处理程序  ProxyInvocationHandler pih = new ProxyInvocationHandler(); pih.setRent(host); //将真实角色放置进去！  Rent proxy = (Rent)pih.getProxy(); //动态生成对应的代理类！  proxy.rent(); } } 核心：一个动态代理 , 一般代理某一类业务 , 一个动态代理可以代理多个类，代理的是接口！、\n 深化理解  我们来使用动态代理实现代理我们后面写的UserService！\n我们也可以编写一个通用的动态代理实现的类！所有的代理对象设置为Object即可！\npublic class ProxyInvocationHandler implements InvocationHandler { private Object target; public void setTarget(Object target) { this.target = target; } //生成代理类  public Object getProxy(){ return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(),this); } // proxy : 代理类  // method : 代理类的调用处理程序的方法对象.  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { log(method.getName()); Object result = method.invoke(target, args); return result; } public void log(String methodName){ System.out.println(\u0026#34;执行了\u0026#34;+methodName+\u0026#34;方法\u0026#34;); } } 测试！\npublic class Test { public static void main(String[] args) { //真实对象  UserServiceImpl userService = new UserServiceImpl(); //代理对象的调用处理程序  ProxyInvocationHandler pih = new ProxyInvocationHandler(); pih.setTarget(userService); //设置要代理的对象  UserService proxy = (UserService)pih.getProxy(); //动态生成代理类！  proxy.delete(); } } 测试，增删改查，查看结果！\n 动态代理的好处  静态代理有的它都有，静态代理没有的，它也有！\n 可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 . 公共的业务由代理来完成 . 实现了业务的分工 , 公共业务发生扩展时变得更加集中和方便 . 一个动态代理 , 一般代理某一类业务 一个动态代理可以代理多个类，代理的是接口！  ","date":"2021-09-11T17:48:54+08:00","permalink":"https://example.com/p/spring06-%E5%8A%A8/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/","title":"Spring06 动/静态代理"},{"content":"使用注解开发  说明  在spring4之后，想要使用注解形式，必须得要引入aop的包\n`spring-aop\n在配置文件当中，还得要引入一个context约束\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;/beans\u0026gt;  Bean的实现  我们之前都是使用 bean 的标签进行bean注入，但是实际开发中，我们一般都会使用注解！\n1、配置扫描哪些包下的注解\n\u0026lt;!--指定注解扫描包--\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.kuang.pojo\u0026#34;/\u0026gt; 2、在指定包下编写类，增加注解\n@Component(\u0026#34;user\u0026#34;) // 相当于配置文件中 \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;当前注解的类\u0026#34;/\u0026gt; public class User { public String name = \u0026#34;秦疆\u0026#34;; } 3、测试\n@Test public void test(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\u0026#34;beans.xml\u0026#34;); User user = (User) applicationContext.getBean(\u0026#34;user\u0026#34;); System.out.println(user.name); }  属性注入  使用注解注入属性\n1、可以不用提供set方法，直接在直接名上添加@value(\u0026ldquo;值\u0026rdquo;)\n@Component(\u0026#34;user\u0026#34;) // 相当于配置文件中 \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;当前注解的类\u0026#34;/\u0026gt; public class User { @Value(\u0026#34;秦疆\u0026#34;) // 相当于配置文件中 \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;秦疆\u0026#34;/\u0026gt;  public String name; } 2、如果提供了set方法，在set方法上添加@value(\u0026ldquo;值\u0026rdquo;);\n@Component(\u0026#34;user\u0026#34;) public class User { public String name; @Value(\u0026#34;秦疆\u0026#34;) public void setName(String name) { this.name = name; } }  衍生注解  我们这些注解，就是替代了在配置文件当中配置步骤而已！更加的方便快捷！\n@Component三个衍生注解\n为了更好的进行分层，Spring可以使用其它三个注解，功能一样，目前使用哪一个功能都一样。\n @Controller：web层 @Service：service层 @Repository：dao层  写上这些注解，就相当于将这个类交给Spring管理装配了！\n 自动装配注解  在Bean的自动装配已经讲过了，可以回顾！\n 作用域  @scope\n singleton：默认的，Spring会采用单例模式创建这个对象。关闭工厂 ，所有的对象都会销毁。 prototype：多例模式。关闭工厂 ，所有的对象不会销毁。内部的垃圾回收机制会回收  @Controller(\u0026#34;user\u0026#34;) @Scope(\u0026#34;prototype\u0026#34;) public class User { @Value(\u0026#34;秦疆\u0026#34;) public String name; }  小结  XML与注解比较\n XML可以适用任何场景 ，结构清晰，维护方便 注解不是自己提供的类使用不了，开发简单方便  xml与注解整合开发 ：推荐最佳实践\n xml管理Bean 注解完成属性注入 使用过程中， 可以不用扫描，扫描是为了类上的注解  \u0026lt;context:annotation-config/\u0026gt; 作用：\n  进行注解驱动注册，从而使注解生效\n  用于激活那些已经在spring容器里注册过的bean上面的注解，也就是显示的向Spring注册\n  如果不扫描包，就需要手动配置bean\n  如果不加注解驱动，则注入的值为null！\n   基于Java类进行配置  JavaConfig 原来是 Spring 的一个子项目，它通过 Java 类的方式提供 Bean 的定义信息，在 Spring4 的版本， JavaConfig 已正式成为 Spring4 的核心功能 。\n测试：\n1、编写一个实体类，Dog\n@Component //将这个类标注为Spring的一个组件，放到容器中！ public class Dog { public String name = \u0026#34;dog\u0026#34;; } 2、新建一个config配置包，编写一个MyConfig配置类\n@Configuration //代表这是一个配置类 public class MyConfig { @Bean //通过方法注册一个bean，这里的返回值就Bean的类型，方法名就是bean的id！  public Dog dog(){ return new Dog(); } } 3、测试\n@Test public void test2(){ ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MyConfig.class); Dog dog = (Dog) applicationContext.getBean(\u0026#34;dog\u0026#34;); System.out.println(dog.name); } 4、成功输出结果！\n导入其他配置如何做呢？\n1、我们再编写一个配置类！\n@Configuration //代表这是一个配置类 public class MyConfig2 { } 2、在之前的配置类中我们来选择导入这个配置类\n@Configuration @Import(MyConfig2.class) //导入合并其他配置类，类似于配置文件中的 inculde 标签 public class MyConfig { @Bean public Dog dog(){ return new Dog(); } } 关于这种Java类的配置方式，我们在之后的SpringBoot 和 SpringCloud中还会大量看到，我们需要知道这些注解的作用即可！\n","date":"2021-09-11T17:48:51+08:00","permalink":"https://example.com/p/spring05-%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/","title":"Spring05 使用注解开发"},{"content":"Bean的自动装配  自动装配说明   自动装配是使用spring满足bean依赖的一种方法 spring会在应用上下文中为某个bean寻找其依赖的bean。  Spring中bean有三种装配机制，分别是：\n 在xml中显式配置； 在java中显式配置； 隐式的bean发现机制和自动装配。  这里我们主要讲第三种：自动化的装配bean。\nSpring的自动装配需要从两个角度来实现，或者说是两个操作：\n 组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean； 自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC/DI；  组件扫描和自动装配组合发挥巨大威力，使得显示的配置降低到最少。\n**不推荐使用xml配置 , 而使用注解 **\n 测试环境搭建  1、新建一个项目\n2、新建两个实体类，Cat Dog 都有一个叫的方法\npublic class Cat { public void shout() { System.out.println(\u0026#34;miao~\u0026#34;); } } public class Dog { public void shout() { System.out.println(\u0026#34;wang~\u0026#34;); } } 3、新建一个用户类 User\npublic class User { private Cat cat; private Dog dog; private String str; } 4、编写Spring配置文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;dog\u0026#34; class=\u0026#34;com.kuang.pojo.Dog\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;cat\u0026#34; class=\u0026#34;com.kuang.pojo.Cat\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.kuang.pojo.User\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;cat\u0026#34; ref=\u0026#34;cat\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;dog\u0026#34; ref=\u0026#34;dog\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;str\u0026#34; value=\u0026#34;qinjiang\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 5、测试\npublic class MyTest { @Test public void testMethodAutowire() { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans.xml\u0026#34;); User user = (User) context.getBean(\u0026#34;user\u0026#34;); user.getCat().shout(); user.getDog().shout(); } } 结果正常输出，环境OK\n byName  autowire byName (按名称自动装配)\n由于在手动配置xml过程中，常常发生字母缺漏和大小写等错误，而无法对其进行检查，使得开发效率降低。\n采用自动装配将避免这些错误，并且使配置简单化。\n测试：\n1、修改bean配置，增加一个属性 autowire=\u0026ldquo;byName\u0026rdquo;\n\u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.kuang.pojo.User\u0026#34; autowire=\u0026#34;byName\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;str\u0026#34; value=\u0026#34;qinjiang\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 2、再次测试，结果依旧成功输出！\n3、我们将 cat 的bean id修改为 catXXX\n4、再次测试， 执行时报空指针java.lang.NullPointerException。因为按byName规则找不对应set方法，真正的setCat就没执行，对象就没有初始化，所以调用时就会报空指针错误。\n小结：\n当一个bean节点带有 autowire byName的属性时。\n  将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。\n  去spring容器中寻找是否有此字符串名称id的对象。\n  如果有，就取出注入；如果没有，就报空指针异常。\n   byType  autowire byType (按类型自动装配)\n使用autowire byType首先需要保证：同一类型的对象，在spring容器中唯一。如果不唯一，会报不唯一的异常。\nNoUniqueBeanDefinitionException 测试：\n1、将user的bean配置修改一下 ： autowire=\u0026ldquo;byType\u0026rdquo;\n2、测试，正常输出\n3、在注册一个cat 的bean对象！\n\u0026lt;bean id=\u0026#34;dog\u0026#34; class=\u0026#34;com.kuang.pojo.Dog\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;cat\u0026#34; class=\u0026#34;com.kuang.pojo.Cat\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;cat2\u0026#34; class=\u0026#34;com.kuang.pojo.Cat\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.kuang.pojo.User\u0026#34; autowire=\u0026#34;byType\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;str\u0026#34; value=\u0026#34;qinjiang\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 4、测试，报错：NoUniqueBeanDefinitionException\n5、删掉cat2，将cat的bean名称改掉！测试！因为是按类型装配，所以并不会报异常，也不影响最后的结果。甚至将id属性去掉，也不影响结果。\n这就是按照类型自动装配！\n使用注解\n 使用注解  jdk1.5开始支持注解，spring2.5开始全面支持注解。\n准备工作：利用注解的方式注入属性。\n1、在spring配置文件中引入context文件头\nxmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd 2、开启属性注解支持！\n\u0026lt;context:annotation-config/\u0026gt; @Autowired  @Autowired是按类型自动转配的，不支持id匹配。 需要导入 spring-aop的包！  测试：\n1、将User类中的set方法去掉，使用@Autowired注解\npublic class User { @Autowired private Cat cat; @Autowired private Dog dog; private String str; public Cat getCat() { return cat; } public Dog getDog() { return dog; } public String getStr() { return str; } } 2、此时配置文件内容\n\u0026lt;context:annotation-config/\u0026gt; \u0026lt;bean id=\u0026#34;dog\u0026#34; class=\u0026#34;com.kuang.pojo.Dog\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;cat\u0026#34; class=\u0026#34;com.kuang.pojo.Cat\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.kuang.pojo.User\u0026#34;/\u0026gt; 3、测试，成功输出结果！\n【小狂神科普时间】\n@Autowired(required=false) 说明：false，对象可以为null；true，对象必须存对象，不能为null。\n//如果允许对象为null，设置required = false,默认为true @Autowired(required = false) private Cat cat; @Qualifier  @Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配 @Qualifier不能单独使用。  测试实验步骤：\n1、配置文件修改内容，保证类型存在对象。且名字不为类的默认名字！\n\u0026lt;bean id=\u0026#34;dog1\u0026#34; class=\u0026#34;com.kuang.pojo.Dog\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;dog2\u0026#34; class=\u0026#34;com.kuang.pojo.Dog\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;cat1\u0026#34; class=\u0026#34;com.kuang.pojo.Cat\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;cat2\u0026#34; class=\u0026#34;com.kuang.pojo.Cat\u0026#34;/\u0026gt; 2、没有加Qualifier测试，直接报错\n3、在属性上添加Qualifier注解\n@Autowired @Qualifier(value = \u0026#34;cat2\u0026#34;) private Cat cat; @Autowired @Qualifier(value = \u0026#34;dog2\u0026#34;) private Dog dog; 测试，成功输出！\n@Resource  @Resource如有指定的name属性，先按该属性进行byName方式查找装配； 其次再进行默认的byName方式进行装配； 如果以上都不成功，则按byType的方式自动装配。 都不成功，则报异常。  实体类：\npublic class User { //如果允许对象为null，设置required = false,默认为true  @Resource(name = \u0026#34;cat2\u0026#34;) private Cat cat; @Resource private Dog dog; private String str; } beans.xml\n\u0026lt;bean id=\u0026#34;dog\u0026#34; class=\u0026#34;com.kuang.pojo.Dog\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;cat1\u0026#34; class=\u0026#34;com.kuang.pojo.Cat\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;cat2\u0026#34; class=\u0026#34;com.kuang.pojo.Cat\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.kuang.pojo.User\u0026#34;/\u0026gt; 测试：结果OK\n配置文件2：beans.xml ， 删掉cat2\n\u0026lt;bean id=\u0026#34;dog\u0026#34; class=\u0026#34;com.kuang.pojo.Dog\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;cat1\u0026#34; class=\u0026#34;com.kuang.pojo.Cat\u0026#34;/\u0026gt; 实体类上只保留注解\n@Resource private Cat cat; @Resource private Dog dog; 结果：OK\n结论：先进行byName查找，失败；再进行byType查找，成功。\n小结 @Autowired与@Resource异同：\n1、@Autowired与@Resource都可以用来装配bean。都可以写在字段上，或写在setter方法上。\n2、@Autowired默认按类型装配（属于spring规范），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用\n3、@Resource（属于J2EE复返），默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。\n它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired先byType，@Resource先byName。\n","date":"2021-09-11T17:48:33+08:00","permalink":"https://example.com/p/spring04-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/","title":"Spring04 自动装配"},{"content":"Dependency Injection  概念   依赖注入（Dependency Injection,DI）。 依赖 : 指Bean对象的创建依赖于容器 . Bean对象的依赖资源 . 注入 : 指Bean对象所依赖的资源 , 由容器来设置和装配 .   构造器注入  我们在之前的案例已经讲过了\n Set 注入 （重点）  要求被注入的属性 , 必须有set方法 , set方法的方法名由set + 属性首字母大写 , 如果属性是boolean类型 , 没有set方法 , 是 is .\n测试pojo类 :\nAddress.java\npublic class Address { private String address; public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } } Student.java\npackage com.kuang.pojo; import java.util.List; import java.util.Map; import java.util.Properties; import java.util.Set; public class Student { private String name; private Address address; private String[] books; private List\u0026lt;String\u0026gt; hobbys; private Map\u0026lt;String,String\u0026gt; card; private Set\u0026lt;String\u0026gt; games; private String wife; private Properties info; public void setName(String name) { this.name = name; } public void setAddress(Address address) { this.address = address; } public void setBooks(String[] books) { this.books = books; } public void setHobbys(List\u0026lt;String\u0026gt; hobbys) { this.hobbys = hobbys; } public void setCard(Map\u0026lt;String, String\u0026gt; card) { this.card = card; } public void setGames(Set\u0026lt;String\u0026gt; games) { this.games = games; } public void setWife(String wife) { this.wife = wife; } public void setInfo(Properties info) { this.info = info; } public void show(){ System.out.println(\u0026#34;name=\u0026#34;+ name + \u0026#34;,address=\u0026#34;+ address.getAddress() + \u0026#34;,books=\u0026#34; ); for (String book:books){ System.out.print(\u0026#34;\u0026lt;\u0026lt;\u0026#34;+book+\u0026#34;\u0026gt;\u0026gt;\\t\u0026#34;); } System.out.println(\u0026#34;\\n爱好:\u0026#34;+hobbys); System.out.println(\u0026#34;card:\u0026#34;+card); System.out.println(\u0026#34;games:\u0026#34;+games); System.out.println(\u0026#34;wife:\u0026#34;+wife); System.out.println(\u0026#34;info:\u0026#34;+info); } } 1、常量注入\n\u0026lt;bean id=\u0026#34;student\u0026#34; class=\u0026#34;com.kuang.pojo.Student\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;小明\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 测试：\n@Test public void test01(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); Student student = (Student) context.getBean(\u0026#34;student\u0026#34;); System.out.println(student.getName()); } 2、Bean注入\n注意点：这里的值是一个引用，ref\n\u0026lt;bean id=\u0026#34;addr\u0026#34; class=\u0026#34;com.kuang.pojo.Address\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;address\u0026#34; value=\u0026#34;重庆\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;student\u0026#34; class=\u0026#34;com.kuang.pojo.Student\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;小明\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;address\u0026#34; ref=\u0026#34;addr\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 3、数组注入\n\u0026lt;bean id=\u0026#34;student\u0026#34; class=\u0026#34;com.kuang.pojo.Student\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;小明\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;address\u0026#34; ref=\u0026#34;addr\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;books\u0026#34;\u0026gt; \u0026lt;array\u0026gt; \u0026lt;value\u0026gt;西游记\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;红楼梦\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;水浒传\u0026lt;/value\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 4、List注入\n\u0026lt;property name=\u0026#34;hobbys\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;听歌\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;看电影\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;爬山\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; 5、Map注入\n\u0026lt;property name=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026#34;中国邮政\u0026#34; value=\u0026#34;456456456465456\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;建设\u0026#34; value=\u0026#34;1456682255511\u0026#34;/\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; 6、set注入\n\u0026lt;property name=\u0026#34;games\u0026#34;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;value\u0026gt;LOL\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;BOB\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;COC\u0026lt;/value\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt; 7、Null注入\n\u0026lt;property name=\u0026#34;wife\u0026#34;\u0026gt;\u0026lt;null/\u0026gt;\u0026lt;/property\u0026gt; 8、Properties注入\n\u0026lt;property name=\u0026#34;info\u0026#34;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026#34;学号\u0026#34;\u0026gt;20190604\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;性别\u0026#34;\u0026gt;男\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;姓名\u0026#34;\u0026gt;小明\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt;  p命名和c命名注入  User.java ：【注意：这里没有有参构造器！】\npublic class User { private String name; private int age; public void setName(String name) { this.name = name; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } 1、P命名空间注入 : 需要在头文件中加入约束文件\n导入约束 : xmlns:p=\u0026#34;http://www.springframework.org/schema/p\u0026#34; \u0026lt;!--P(属性: properties)命名空间 , 属性依然要设置set方法--\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.kuang.pojo.User\u0026#34; p:name=\u0026#34;狂神\u0026#34; p:age=\u0026#34;18\u0026#34;/\u0026gt; 2、c 命名空间注入 : 需要在头文件中加入约束文件\n导入约束 : xmlns:c=\u0026#34;http://www.springframework.org/schema/c\u0026#34; \u0026lt;!--C(构造: Constructor)命名空间 , 属性依然要设置set方法--\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.kuang.pojo.User\u0026#34; c:name=\u0026#34;狂神\u0026#34; c:age=\u0026#34;18\u0026#34;/\u0026gt; 发现问题：爆红了，刚才我们没有写有参构造！\n解决：把有参构造器加上，这里也能知道，c 就是所谓的构造器注入！\n测试代码：\n@Test public void test02(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); User user = (User) context.getBean(\u0026#34;user\u0026#34;); System.out.println(user); }  Bean的作用域  在Spring中，那些组成应用程序的主体及由Spring IoC容器所管理的对象，被称之为bean。简单地讲，bean就是由IoC容器初始化、装配及管理的对象 .\nSingleton 当一个bean的作用域为Singleton，那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。注意，Singleton作用域是Spring中的缺省作用域。要在XML中将bean定义成singleton，可以这样配置：\n\u0026lt;bean id=\u0026#34;ServiceImpl\u0026#34; class=\u0026#34;cn.csdn.service.ServiceImpl\u0026#34; scope=\u0026#34;singleton\u0026#34;\u0026gt; 测试：\n@Test public void test03(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); User user = (User) context.getBean(\u0026#34;user\u0026#34;); User user2 = (User) context.getBean(\u0026#34;user\u0026#34;); System.out.println(user==user2); } Prototype 当一个bean的作用域为Prototype，表示一个bean定义对应多个对象实例。Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。在XML中将bean定义成prototype，可以这样配置：\n\u0026lt;bean id=\u0026#34;account\u0026#34; class=\u0026#34;com.foo.DefaultAccount\u0026#34; scope=\u0026#34;prototype\u0026#34;/\u0026gt; 或者 \u0026lt;bean id=\u0026#34;account\u0026#34; class=\u0026#34;com.foo.DefaultAccount\u0026#34; singleton=\u0026#34;false\u0026#34;/\u0026gt; Request 当一个bean的作用域为Request，表示在一次HTTP请求中，一个bean定义对应一个实例；即每个HTTP请求都会有各自的bean实例，它们依据某个bean定义创建而成。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：\n\u0026lt;bean id=\u0026#34;loginAction\u0026#34; class=cn.csdn.LoginAction\u0026#34; scope=\u0026#34;request\u0026#34;/\u0026gt; 针对每次HTTP请求，Spring容器会根据loginAction bean的定义创建一个全新的LoginAction bean实例，且该loginAction bean实例仅在当前HTTP request内有效，因此可以根据需要放心的更改所建实例的内部状态，而其他请求中根据loginAction bean定义创建的实例，将不会看到这些特定于某个请求的状态变化。当处理请求结束，request作用域的bean实例将被销毁。\nSession 当一个bean的作用域为Session，表示在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：\n\u0026lt;bean id=\u0026#34;userPreferences\u0026#34; class=\u0026#34;com.foo.UserPreferences\u0026#34; scope=\u0026#34;session\u0026#34;/\u0026gt; 针对某个HTTP Session，Spring容器会根据userPreferences bean定义创建一个全新的userPreferences bean实例，且该userPreferences bean仅在当前HTTP Session内有效。与request作用域一样，可以根据需要放心的更改所创建实例的内部状态，而别的HTTP Session中根据userPreferences创建的实例，将不会看到这些特定于某个HTTP Session的状态变化。当HTTP Session最终被废弃的时候，在该HTTP Session作用域内的bean也会被废弃掉。\n几种作用域中，request、session作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架），只能用在基于web的Spring ApplicationContext环境。\n","date":"2021-09-11T17:41:44+08:00","permalink":"https://example.com/p/spring03-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5di/","title":"Spring03 依赖注入(DI)"},{"content":"HelloSpring  导入Jar包  注 : spring 需要导入commons-logging进行日志记录 . 我们利用maven , 他会自动下载对应的依赖项 .\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.10.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  编写代码  1、编写一个Hello实体类\npublic class Hello { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } public void show(){ System.out.println(\u0026#34;Hello,\u0026#34;+ name ); } } 2、编写我们的spring文件 , 这里我们命名为beans.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!--bean就是java对象 , 由Spring创建和管理--\u0026gt; \u0026lt;bean id=\u0026#34;hello\u0026#34; class=\u0026#34;com.kuang.pojo.Hello\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;Spring\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 3、我们可以去进行测试了 .\n@Test public void test(){ //解析beans.xml文件 , 生成管理相应的Bean对象  ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans.xml\u0026#34;); //getBean : 参数即为spring配置文件中bean的id .  Hello hello = (Hello) context.getBean(\u0026#34;hello\u0026#34;); hello.show(); }  思考   Hello 对象是谁创建的 ? 【hello 对象是由Spring创建的 Hello 对象的属性是怎么设置的 ? hello 对象的属性是由Spring容器设置的  这个过程就叫控制反转 :\n 控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的 反转 : 程序本身不创建对象 , 而变成被动的接收对象 .  依赖注入 : 就是利用set方法来进行注入的.\nIOC是一种编程思想，由主动的编程变成被动的接收\n可以通过newClassPathXmlApplicationContext去浏览一下底层源码 .\n 修改案例一  我们在案例一中， 新增一个Spring配置文件beans.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;MysqlImpl\u0026#34; class=\u0026#34;com.kuang.dao.impl.UserDaoMySqlImpl\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;OracleImpl\u0026#34; class=\u0026#34;com.kuang.dao.impl.UserDaoOracleImpl\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;ServiceImpl\u0026#34; class=\u0026#34;com.kuang.service.impl.UserServiceImpl\u0026#34;\u0026gt; \u0026lt;!--注意: 这里的name并不是属性 , 而是set方法后面的那部分 , 首字母小写--\u0026gt; \u0026lt;!--引用另外一个bean , 不是用value 而是用 ref--\u0026gt; \u0026lt;property name=\u0026#34;userDao\u0026#34; ref=\u0026#34;OracleImpl\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 测试！\n@Test public void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans.xml\u0026#34;); UserServiceImpl serviceImpl = (UserServiceImpl) context.getBean(\u0026#34;ServiceImpl\u0026#34;); serviceImpl.getUser(); } OK , 到了现在 , 我们彻底不用再程序中去改动了 , 要实现不同的操作 , 只需要在xml配置文件中进行修改 , 所谓的IoC,一句话搞定 : 对象由Spring 来创建 , 管理 , 装配 !\nIOC创建对象方式  通过无参构造方法来创建  1、User.java\npublic class User { private String name; public User() { System.out.println(\u0026#34;user无参构造方法\u0026#34;); } public void setName(String name) { this.name = name; } public void show(){ System.out.println(\u0026#34;name=\u0026#34;+ name ); } } 2、beans.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.kuang.pojo.User\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;kuangshen\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 3、测试类\n@Test public void test(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans.xml\u0026#34;); //在执行getBean的时候, user已经创建好了 , 通过无参构造  User user = (User) context.getBean(\u0026#34;user\u0026#34;); //调用对象的方法 .  user.show(); } 结果可以发现，在调用show方法之前，User对象已经通过无参构造初始化了！\n 通过有参构造方法来创建  1、UserT . java\npublic class UserT { private String name; public UserT(String name) { this.name = name; } public void setName(String name) { this.name = name; } public void show(){ System.out.println(\u0026#34;name=\u0026#34;+ name ); } } 2、beans.xml 有三种方式编写\n\u0026lt;!-- 第一种根据index参数下标设置 --\u0026gt; \u0026lt;bean id=\u0026#34;userT\u0026#34; class=\u0026#34;com.kuang.pojo.UserT\u0026#34;\u0026gt; \u0026lt;!-- index指构造方法 , 下标从0开始 --\u0026gt; \u0026lt;constructor-arg index=\u0026#34;0\u0026#34; value=\u0026#34;kuangshen2\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 第二种根据参数名字设置 --\u0026gt; \u0026lt;bean id=\u0026#34;userT\u0026#34; class=\u0026#34;com.kuang.pojo.UserT\u0026#34;\u0026gt; \u0026lt;!-- name指参数名 --\u0026gt; \u0026lt;constructor-arg name=\u0026#34;name\u0026#34; value=\u0026#34;kuangshen2\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 第三种根据参数类型设置 --\u0026gt; \u0026lt;bean id=\u0026#34;userT\u0026#34; class=\u0026#34;com.kuang.pojo.UserT\u0026#34;\u0026gt; \u0026lt;constructor-arg type=\u0026#34;java.lang.String\u0026#34; value=\u0026#34;kuangshen2\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 3、测试\n@Test public void testT(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans.xml\u0026#34;); UserT user = (UserT) context.getBean(\u0026#34;userT\u0026#34;); user.show(); } 结论：在配置文件加载的时候。其中管理的对象都已经初始化了！\nSpring配置  别名  alias 设置别名 , 为bean设置别名 , 可以设置多个别名\n\u0026lt;!--设置别名：在获取Bean的时候可以使用别名获取--\u0026gt; \u0026lt;alias name=\u0026#34;userT\u0026#34; alias=\u0026#34;userNew\u0026#34;/\u0026gt;  Bean的配置  \u0026lt;!--bean就是java对象,由Spring创建和管理--\u0026gt; \u0026lt;!-- id 是bean的标识符,要唯一,如果没有配置id,name就是默认标识符 如果配置id,又配置了name,那么name是别名 name可以设置多个别名,可以用逗号,分号,空格隔开 如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象; class是bean的全限定名=包名+类名 --\u0026gt; \u0026lt;bean id=\u0026#34;hello\u0026#34; name=\u0026#34;hello2 h2,h3;h4\u0026#34; class=\u0026#34;com.kuang.pojo.Hello\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;Spring\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;  import  团队的合作通过import来实现 .\n\u0026lt;import resource=\u0026#34;{path}/beans.xml\u0026#34;/\u0026gt; ","date":"2021-09-11T17:23:33+08:00","permalink":"https://example.com/p/spring02-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/","title":"Spring02 快速上手"},{"content":"Hugo 简介 Hugo是由Steve Francis基于Go语言开发的静态网站构建工具。\n为什么选择Hexo  编译文章生成速度快 Hugo的官方文档写的非常好，部署简洁。 前两者部署时需要安装很多依赖，而hugo可以直接提供二进制文件运行，甚至不需要root权限。 颜值相对较高  安装 官方安装教程(推荐)\nMac安装   安装 brew\nruby -e \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\u0026#34;   运行brew命令进行安装hugo\nbrew install hugo 如果 Homebrew 工作正常，您应该会看到类似于以下内容的内容：\n==\u0026gt; Downloading https://homebrew.bintray.com/bottles/hugo-0.21.sierra.bottle.tar.gz ######################################################################### 100.0% ==\u0026gt; Pouring hugo-0.21.sierra.bottle.tar.gz 🍺 /usr/local/Cellar/hugo/0.21: 32 files, 17.4MB   创建新站点 hugo new site quickstart 添加主题 有关要考虑的主题列表，请参阅themes.gohugo.io。本快速入门使用漂亮的Ananke 主题。\n首先，从 GitHub 下载主题并将其添加到您网站的themes目录中：\ncd quickstart git init git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke 然后，将主题添加到站点配置中：\necho theme = \\\u0026#34;ananke\\\u0026#34; \u0026gt;\u0026gt; config.toml 添加一些内容 您可以手动创建内容文件（例如 as content/\u0026lt;CATEGORY\u0026gt;/\u0026lt;FILE\u0026gt;.\u0026lt;FORMAT\u0026gt;）并在其中提供元数据，但是您可以使用该new命令为您做一些事情（例如添加标题和日期）：\nhugo new posts/my-first-post.md 如果需要，编辑新创建的内容文件，它将以如下内容开头：\n--- title: \u0026#34;My First Post\u0026#34; date: 2019-03-26T08:47:11+01:00 draft: true --- 草稿不会被部署；完成帖子后，更新帖子的标题以说draft: false。更多信息在这里。\n启动 Hugo 服务器 现在，在启用草稿的情况下启动 Hugo 服务器：\nhugo server -D 查看部署的站点http://localhost:1313/ 的\n随意编辑或添加新内容，只需在浏览器中刷新即可快速查看更改（您可能需要在 webbrowser 中强制刷新）。\n自定义主题 您的新网站看起来不错，但在向公众发布之前，您需要对其进行一些调整。\n站点配置 config.toml在文本编辑器中打开：\nbaseURL = \u0026quot;https://example.org/\u0026quot; languageCode = \u0026quot;en-us\u0026quot; title = \u0026quot;My New Hugo Site\u0026quot; theme = \u0026quot;ananke\u0026quot; 用title更个性化的东西替换上面的内容。此外，如果您已经准备好域，请将baseURL. 请注意，运行本地开发服务器时不需要此值。\n**提示：**在 Hugo 服务器运行时对站点配置或站点中的任何其他文件进行更改，您将立即在浏览器中看到更改，但您可能需要清除缓存。\n有关特定于主题的配置选项，请参阅主题站点。\n如需进一步的主题定制，请参阅定制主题。\n构建静态页面 很简单。只需致电：\nhugo -D ./public/默认情况下输出将在目录中（-d/--destination标志更改它，或publishdir在配置文件中设置）。\n","date":"2021-09-10T13:37:10+08:00","permalink":"https://example.com/p/%E8%AE%B0%E4%B8%80%E6%AC%A1-hugo-%E5%AE%89%E8%A3%85/","title":"记一次 Hugo 安装"},{"content":"Filter和Listener FIlter 指过滤器  概念   生活中的过滤器:空气过滤器 净水器 web中的过滤器:当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能 过滤器的一些功能: 一般用于完整通用的操作：  比如登录验证 统一编码设置 敏感字符过滤     快速入门:\n  步骤:\n 定义一个类 实现Filter接口， 复写方法 配置拦截资源: 注解配置 @WebFilter(\u0026quot;/*\u0026quot;) web.xml配置    @WebFilter(\u0026#34;/*\u0026#34;) public class FilterDemo implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(\u0026#34;执行了filter\u0026#34;); chain.doFilter(request, response); } }     过滤器细节\n  web.xml\n  \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;demo1\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;com.edu.web.filter.FilterDemo\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;demo1\u0026lt;/filter-name\u0026gt; \u0026lt;!-- 拦截的请求路径 --\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt;   过滤器执行流程\n 执行 doFilter方法() 对request对象进行 增强 chain.doFilter() 放行 执行对应的Servlet 对response对象进行增强 执行 doFilter后的方法      过滤器生命周期方法\n init 应用服务器启动时执行一次 doFilter 每一次请求被拦截时 执行 destroy 在服务器关闭后，Filter对象被销毁。    过滤器配置详解\n  拦截路径配置\n 具体的资源路径 :1 /index.jsp 只有访问index.jsp时 过滤器才会被执行 拦截目录 /user/* 访问user下的所有执行时过滤器被拦截 拦截指定类型文件 .jsp 注意不加/ 拦截所有资源 /* 拦截方式    指的是资源被访问的方式:\n 可以直接通过浏览器发送请求 资源 可以在服务端通过 转发访问资源      注解配置:\n  设置 WebFilter()\n  dispatcherType:\n  REQUEST 浏览器请求\n  FORWARD 转发\n  INCLUDE 包含访问资源\n  ERROR 错误跳转专员\n  ASYNC: 异步访问资源\nweb.xml\n\u0026lt;filter-mapping\u0026gt; \u0026lt;dispatcher\u0026gt;REQUEST(同上)\u0026lt;/dispatcher\u0026gt; \u0026lt;/filter-mapping\u0026gt;       过滤器链\n 一个项目里可以配置多个过滤器  如果有两个过滤器 分别为过滤器A 过滤器B 执行顺序 A 过滤器B 资源 过滤器B 过滤器A   过滤器先后顺序：  注解配置：按照类名的字符串比较规则，值小的先执行 Afilter和Bfilter 分别比较 A先执行 Web.xml里的配置 谁配置在上面谁先执行。      ","date":"2021-05-11T15:29:19+08:00","permalink":"https://example.com/p/filter%E5%92%8Clistener/","title":"Filter和Listener"},{"content":"MySQL中的数据类型 MySQL支持多种数据类型，主要有数值类型、日期/时间类型和字符串类型。\n数值类型 数值类型包括：\n  整数类型：TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT\n  浮点数类型有FLOAT和DOUBLE\n  定点小数类型DECIMAL\n  日期/时间类型：包括YEAR、TIME、DATE、DATATIME和TIMESTAMP。\n  字符串类型：CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET等。字符串类型又分为文本字符串和二进制字符串。\n  整数类型 数值型数据类型主要用来存储数字，不同的数据类型提供不同的取值范围，可以存储的值的范围越大，其所需要的存储空间也会越大。整数类型的字段可以添加AUTO_INCREMENT自增约束条件。\n   类型名称 存储需求（B）     TINYINT tinyint 1   SMALLINT smallint 2   MEDIUMINT mediumint 3   INT 4   BIGINT 8    需要注意的是，在设计数据库的时候，在实体类中long型的变量对应BIGINT,INT对应int类型的成员变量。\n例：\nCREATE TABLE tb_emp1( id INT(11), name VARCHAR(25). deptId INT(11), salary FLOAT ); id字段的数据类型为INT（11），“11”表示该数据类型指定的显示宽度，指定能显示的数值中数字的个数。\n注意：**显示宽度和数据类型的取值范围是无关的。**显示宽度只是指明MySQL最大可能显示的数字个数，数值的位数小于指定宽度时会有空格填充。但是，如果插入了大于显示宽度的值，只要该值不超过取值范围，数值依然可以插入，而且在查询该列值的时候，将会显示完整的插入值，而不会进行显示宽度处理。例如下列语句创建表user：\nmysql\u0026gt; CREATE TABLE user( -\u0026gt; id INT(4), -\u0026gt; name VARCHAR(20) -\u0026gt; ); 插入数据：\nmysql\u0026gt; INSERT INTO user VALUES(19999,'qing'); 查询结果显示：\n+-------+------+ | id | name | +-------+------+ | 19999 | qing | +-------+------+ INT默认显示4，但是插入19999依然正常显示。请牢记：INT（3）中的数字3仅仅限制显示而已。\n浮点数类型和定点数类型 浮点类型有2中：单精度（FLOAT）和双精度（DOUBLE）。定点类型只有DECIMAL。二者都可以用（M,D）来表示，其中M称为精度，表示总的位数，D称为标度，表示小数点后的位数。\n   类型名称 存储需求（B）     FLOAT 4   DOUBLE 8   DECIMAL（M,D） M+2    DECIMAL类型不同于FLOAT和DOUBLE，DECIMAL类型实际上是以串存放的。\n不论是定点类型还是浮点类型，如果用户指定的数据超出精度范围，则会进行四舍五入处理。\n 问：如果不指定精度，系统如何处理？ 答：FLOAT和DOUBLE在不指定精度的时候，默认按照实际的精度（由计算机硬件和操作系统决定），DECIMAL默认为（10，0）。  日期与时间类型 这里只是简单说一下DATE和TIMESTAMP类型：\n   类型名称 日期格式 存储空间（B）     DATE YYYY-MM-DD 3   TIMESTAMP YYYY-MM-DD HH:MM:SS 4   DATETIME YYYY-MM-DD HH:MM:SS 4     使用CURRENT_DATE或者NOW()插入当前系统日期。 字符串格式自定义添加：“yyyy-MM-dd HH:mm:ss” \u0026ldquo;yyyyMMddHHmmss\u0026rdquo; 应该注意的是，CURRENT_DATE只返回当前日期值，不包括时间部分；NOW()函数返回日期和时间，但是在保存到数据库时，只保留其日期部分。  TIMESTAMP类型显示宽度固定在19个字符，且其值的存储是以UTC（世界标准时间）格式保存的，存储时间时对当前时区进行转换，检索时再次进行转换。即查询时，当前时区不同，显示的时间值是不同的。\n时间搓保存的是当前日期对应毫秒值。范围1970年的1月1日 \u0026mdash;\u0026ndash; 2038年\n文本字符串类型 字符串类型用来存储字符串数据，也可以用来存储其他数据，比如图片和音频的二进制数据等等。 文本字符串分为两类：\n 文本字符串 二进制字符串 一般图片音频视频等数据都是先保存在服务器的硬盘，然后再将地址保存到数据库中  MySQL中文本字符串数据类型\n   类型名称 说明 存储需求     CHAR(M) 固定长度的非二进制字符串 M字节，1\u0026lt;=M\u0026lt;=255   VARCHAR(M) 变长的非二进制字符串 L+1字节，这里L\u0026lt;=M和1\u0026lt;=M\u0026lt;=255   ENUM 枚举类型，只能有一个枚举字符串值 1或2个字节，取决于枚举值的数目(最大值是65535)   SET 一个设置，字符串对象可以有零个或多个SET成员 1，2，3，4或8个字节，取决于集合成员的数量（最多64个成员）   TINYTEXT 非常小的非二进制字符串 L+1个字节，这里L\u0026lt;2 8   TEXT 小的非二进制字符串 L+2个字节，这里L\u0026lt;2^{16}   MEDIUMTEXT 中等大小的非二进制字符串 L+3个字节，这里L\u0026lt;2^{24}   LONGTEXT 大的非二进制字符串 L+4个字节，这里L\u0026lt;2^{32}    blob\n上面几种数据类型，我们着重说一下CHAR和VARCHAR,ENUM,SET\nCHAR(M)为固定长度的字符串，定义时指定字符串列长，保存时右侧填充空格以达到指定长度。M表示列长度，M的范围是0-255个字符。**检索时，尾部的空格将会被删除。**如果存入了一个超过M长度的字符串，会导致该字符串被截断，只保留前M位。\nVARCHAR(M)是长度可变的字符串，M表示最大列的长度。M的范围是0-65535。\n例如，VARCHAR(50) 定义了一个最大长度为50的字符串，如果输入的字符串只有10个字符，那么只需要实际存储的是10个字符和一个长度信息字符。VARCHAR在值保存和值检索的时候，空格保存。\n看下面的例子：\nmysql\u0026gt; create table tmp8( -\u0026gt; ch CHAR(4),varch VARCHAR(4) -\u0026gt; ); mysql\u0026gt; INSERT INTO tmp8('ab ','ab '); mysql\u0026gt; SELECT concat('(',ch,')'),concat('(',varch,')') FROM tmp8; +--------------------+-----------------------+ | concat('(',ch,')') | concat('(',varch,')') | +--------------------+-----------------------+ | (ab) | (ab ) | +--------------------+-----------------------+ 1 row in set (0.02 sec) 从上面可以看出，检索时，CHAR型会删掉尾部的空格，而VARCHAR不会。\nENUM类型：\n来个实际的例子：\nmysql\u0026gt; CREATE TABLE tmp9( -\u0026gt; name CHAR(4), -\u0026gt; sex ENUM('male','female','other','renyao') -\u0026gt; ); Query OK, 0 rows affected (0.33 sec) mysql\u0026gt; DESC tmp9; +-------+-----------------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-----------------------+------+-----+---------+-------+ | name | char(4) | YES | | NULL | | | sex | enum('male','female') | YES | | NULL | | +-------+-----------------------+------+-----+---------+-------+ 2 rows in set (0.01 sec) mysql\u0026gt; INSERT INTO tmp9 VALUES('aaaa','male'); Query OK, 1 row affected (0.06 sec) mysql\u0026gt; INSERT INTO tmp9 VALUES('bbbb','female'); Query OK, 1 row affected (0.07 sec) mysql\u0026gt; SELECT sex,sex+0 FROM tmp9; +--------+-------+ | sex | sex+0 | +--------+-------+ | male | 1 | | female | 2 | +--------+-------+ 2 rows in set (0.00 sec) mysql\u0026gt; INSERT INTO tmp9 VALUES('bbbb',NULL); Query OK, 1 row affected (0.06 sec) mysql\u0026gt; SELECT sex,sex+0 FROM tmp9; +--------+-------+ | sex | sex+0 | +--------+-------+ | male | 1 | | female | 2 | | NULL | NULL | +--------+-------+ 3 rows in set (0.00 sec) 从上面我们可以看到，数据库中存储的是ENUM类型数据的索引值。\n另外，如果ENUM列总有一个默认值，如果该列可以为NULL，那么默认值为NULL,如果NOT NULL，那么为允许列表中的第一个值。\n枚举每个值对应一个整数下标，是从1开始\nSET类型：\nSET也是一个字符串对象，不过跟ENUM不同的是，SET类型的字段可以取 SET列表中的0个或者多个值。SET列最多有64个成员。\n如果插入的的值有重复，那么MySQL会自动删除重复的值，插入SET字段的值的顺序并不重要，MySQL在存储的时候，会按照定义的顺序显示；如果插入不正确的值，MySQL会阻止插入。\nmysql\u0026gt; CREATE TABLE tmp10( -\u0026gt; se SET('A','C','X','D') -\u0026gt; ); Query OK, 0 rows affected (0.30 sec) mysql\u0026gt; INSERT INTO tmp10 VALUES('A,D,X'); Query OK, 1 row affected (0.11 sec) mysql\u0026gt; SELECT * FROM tmp10; +-------+ | se | +-------+ | A,X,D | +-------+ 1 row in set (0.00 sec) 1 注意A,X,D的顺序，是和创建表时的顺序一样的。\n","date":"2021-05-11T15:29:19+08:00","permalink":"https://example.com/p/mysql%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","title":"MySQL中的数据类型"},{"content":"Spring介绍  简介  Spring : 春天 \u0026mdash;\u0026gt;给软件行业带来了春天\n2002年，Rod Jahnson首次推出了Spring框架雏形interface21框架。\n2004年3月24日，Spring框架以interface21框架为基础，经过重新设计，发布了1.0正式版。\n很难想象Rod Johnson的学历 , 他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学。\nSpring理念 : 使现有技术更加实用 . 本身就是一个大杂烩 , 整合现有的框架技术\n官网 : http://spring.io/\n官方下载地址 : https://repo.spring.io/libs-release-local/org/springframework/spring/\nGitHub : https://github.com/spring-projects\n 优点    Spring是一个开源免费的框架 , 容器 .\n  Spring是一个轻量级的框架 , 非侵入式的 .\n  控制反转 IoC , 面向切面 Aop\n  对事物的支持 , 对框架的支持\n  一句话概括：\nSpring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）。\n 组成  Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式 .\n组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下：\n 核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。 Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。 Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。 Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。 Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。 Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。 Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。   拓展  Spring Boot与Spring Cloud\n Spring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务; Spring Cloud是基于Spring Boot实现的； Spring Boot专注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架； Spring Boot使用了约束优于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置 , Spring Cloud很大的一部分是基于Spring Boot来实现，Spring Boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开Spring Boot，属于依赖的关系。 SpringBoot在SpringClound中起到了承上启下的作用，如果你要学习SpringCloud必须要学习SpringBoot。  IoC推导 新建一个空白的maven项目\n 分析实现  我们先用我们原来的方式写一段代码 .\n1、先写一个UserDao接口\npublic interface UserDao { public void getUser(); } 2、再去写Dao的实现类\npublic class UserDaoImpl implements UserDao { @Override public void getUser() { System.out.println(\u0026#34;获取用户数据\u0026#34;); } } 3、然后去写UserService的接口\npublic interface UserService { public void getUser(); } 4、最后写Service的实现类\npublic class UserServiceImpl implements UserService { private UserDao userDao = new UserDaoImpl(); @Override public void getUser() { userDao.getUser(); } } 5、测试一下\n@Test public void test(){ UserService service = new UserServiceImpl(); service.getUser(); } 这是我们原来的方式 , 开始大家也都是这么去写的对吧 . 那我们现在修改一下 .\n把Userdao的实现类增加一个 .\npublic class UserDaoMySqlImpl implements UserDao { @Override public void getUser() { System.out.println(\u0026#34;MySql获取用户数据\u0026#34;); } } 紧接着我们要去使用MySql的话 , 我们就需要去service实现类里面修改对应的实现\npublic class UserServiceImpl implements UserService { private UserDao userDao = new UserDaoMySqlImpl(); @Override public void getUser() { userDao.getUser(); } } 在假设, 我们再增加一个Userdao的实现类 .\npublic class UserDaoOracleImpl implements UserDao { @Override public void getUser() { System.out.println(\u0026#34;Oracle获取用户数据\u0026#34;); } } 那么我们要使用Oracle , 又需要去service实现类里面修改对应的实现 . 假设我们的这种需求非常大 , 这种方式就根本不适用了, 甚至反人类对吧 , 每次变动 , 都需要修改大量代码 . 这种设计的耦合性太高了, 牵一发而动全身 .\n那我们如何去解决呢 ?\n我们可以在需要用到他的地方 , 不去实现它 , 而是留出一个接口 , 利用set , 我们去代码里修改下 .\npublic class UserServiceImpl implements UserService { private UserDao userDao; // 利用set实现  public void setUserDao(UserDao userDao) { this.userDao = userDao; } @Override public void getUser() { userDao.getUser(); } } 现在去我们的测试类里 , 进行测试 ;\n@Test public void test(){ UserServiceImpl service = new UserServiceImpl(); service.setUserDao( new UserDaoMySqlImpl() ); service.getUser(); //那我们现在又想用Oracle去实现呢  service.setUserDao( new UserDaoOracleImpl() ); service.getUser(); } 大家发现了区别没有 ? 可能很多人说没啥区别 . 但是同学们 , 他们已经发生了根本性的变化 , 很多地方都不一样了 . 仔细去思考一下 , 以前所有东西都是由程序去进行控制创建 , 而现在是由我们自行控制创建对象 , 把主动权交给了调用者 . 程序不用去管怎么创建,怎么实现了 . 它只负责提供一个接口 .\n这种思想 , 从本质上解决了问题 , 我们程序员不再去管理对象的创建了 , 更多的去关注业务的实现 . 耦合性大大降低 . 这也就是IOC的原型 !\n IOC本质  控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。\nIoC是Spring框架的核心内容，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。\nSpring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。\n采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。\n控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。\nps:明白IOC的思想，是理解Spring的核心技巧\n","date":"2021-05-11T15:29:19+08:00","permalink":"https://example.com/p/spring01-%E6%A6%82%E8%BF%B0%E5%8F%8Aioc%E7%90%86%E8%AE%BA%E6%8E%A8%E5%AF%BC/","title":"Spring01 概述及IOC理论推导"},{"content":"web开发模式  DAO层 对数据库的增删改查 web层 界面（jsp）加控制器（servlrt） service层 执行多个或一个dao层操作，并将其组合成一个完整的业务逻辑 控制层 使用servlet进行控制 数据访问层 使用DAO、Hibernate、JDBC等技术实现对数据库的增删改查 javaBean 用于封装数据  MVC M模型（model） 模型就是 包括 dao，bean\nV 视图（view） 视图jsp，用于向用户展示模型中的数据\nC 控制（controller） 控制器负责将 模型 中的 数据 显示在不同的 显示层 之中\n早期MVC模式（mode1） 模式一：将显示层、控制层、数据层的操作同意交给jsp或者JavaBean来处理\n前端用户请求 -\u0026gt; jsp -\u0026gt; javaBean -\u0026gt; 数据库jsp和html、java类（javaBean）高度耦合。\n早期MVC模式（mode2） 模式二：以servlet为主展开，由servlet接收客户端的请求，根据请求调用对应的JavaBean或其他程序，最后将要现实的结果交给jsp完成。\n前端用户请求 -\u0026gt; jsp -\u0026gt; servlet -\u0026gt; javaBean -\u0026gt; 数据库SpringMVC 用户请求 -\u0026gt; Spring控制器 -\u0026gt; 夹带事务的模型（业务层，数据访问层）-\u0026gt;数据库传统模型层被拆分为（业务层和数据访问层）\n 需要的jar包 spring-web-*.jar spring-webmvc-*.jar    修改web.xml中的\n\u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;dispatcher\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;dispatcher\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt;   将拦截地址改为/拦截所有请求，并交给SpringMVC的后台控制器来完成\n  编辑springMVC映射文件dispatcher-sevlet.xml(位于WEB-INF目录下)，\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;simpleUrlHandlerMapping\u0026#34; class=\u0026#34;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;mappings\u0026#34;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;!-- /hello 路径的请求交给 id 为 helloController 的控制器处理--\u0026gt; \u0026lt;prop key=\u0026#34;/hello\u0026#34;\u0026gt;helloController\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;helloController\u0026#34; class=\u0026#34;controller.HelloController\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;   修改\u0026lt;prop key=\u0026quot;请求路径\u0026quot;\u0026gt;控制器名\u0026lt;/prop\u0026gt; //将请求路径的请求发送给对应的控制器处理\n  编写控制器（放在controller包下）需要实现Controller(org.springfamework.web.servlet.mvc.Controller)接口\npackage controller; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.mvc.Controller; public class HelloController implements Controller { public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception { ModelAndView mav = new ModelAndView(\u0026#34;index.jsp\u0026#34;); mav.addObject(\u0026#34;message\u0026#34;, \u0026#34;Hello Spring MVC\u0026#34;); return mav; } } SpringMvc使用ModeAndView将模型和视图结合在一起。视图是（index.jsp）数据模型是message，内容是 Hello SpringMvc    跟踪 Spring MVC 的请求 每当用户在 Web 浏览器中点击链接或者提交表单的时候，请求就开始工作了，像是邮递员一样，从离开浏览器开始到获取响应返回，它会经历很多站点，在每一个站点都会留下一些信息同时也会带上其他信息，下图为 Spring MVC 的请求流程：\n第一站：DispatcherServlet 从请求离开浏览器以后，第一站到达的就是 DispatcherServlet，看名字这是一个 Servlet，通过 J2EE 的学习，我们知道 Servlet 可以拦截并处理 HTTP 请求，DispatcherServlet 会拦截所有的请求，并且将这些请求发送给 Spring MVC 控制器。\n\u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;dispatcher\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;dispatcher\u0026lt;/servlet-name\u0026gt; \u0026lt;!-- 拦截所有的请求 --\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt;  DispatcherServlet 的任务就是拦截请求发送给 Spring MVC 控制器。  第二站：处理器映射（HandlerMapping）  问题： 典型的应用程序中可能会有多个控制器，这些请求到底应该发给哪一个控制器呢？  所以 DispatcherServlet 会查询一个或多个处理器映射来确定请求的下一站在哪里，处理器映射会根据请求所携带的 URL 信息来进行决策，例如上面的例子中，我们通过配置 simpleUrlHandlerMapping 来将 /hello 地址交给 helloController 处理：\n\u0026lt;bean id=\u0026#34;simpleUrlHandlerMapping\u0026#34; class=\u0026#34;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;mappings\u0026#34;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;!-- /hello 路径的请求交给 id 为 helloController 的控制器处理--\u0026gt; \u0026lt;prop key=\u0026#34;/hello\u0026#34;\u0026gt;helloController\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;helloController\u0026#34; class=\u0026#34;controller.HelloController\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; 第三站：控制器 一旦选择了合适的控制器， DispatcherServlet 会将请求发送给选中的控制器，到了控制器，请求会卸下其负载（用户提交的请求）等待控制器处理完这些信息：\npublic ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception { // 处理逻辑  .... } 第四站：返回 DispatcherServlet 当控制器在完成逻辑处理后，通常会产生一些信息，这些信息就是需要返回给用户并在浏览器上显示的信息，它们被称为模型（Model）。仅仅返回原始的信息时不够的——这些信息需要以用户友好的方式进行格式化，一般会是 HTML，所以，信息需要发送给一个视图（view），通常会是 JSP。\n控制器所做的最后一件事就是将模型数据打包，并且表示出用于渲染输出的视图名**（逻辑视图名）。它接下来会将请求连同模型和视图名发送回 DispatcherServlet。**\npublic ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception { // 处理逻辑  .... // 返回给 DispatcherServlet  return mav; } 第五站：视图解析器 这样以来，控制器就不会和特定的视图相耦合，传递给 DispatcherServlet 的视图名并不直接表示某个特定的 JSP。（实际上，它甚至不能确定视图就是 JSP）相反，它传递的仅仅是一个逻辑名称，这个名称将会用来查找产生结果的真正视图。\nDispatcherServlet 将会使用视图解析器（view resolver）来将逻辑视图名匹配为一个特定的视图实现，它可能是也可能不是 JSP\n 上面的例子是直接绑定到了 index.jsp 视图\n 第六站：视图 既然 DispatcherServlet 已经知道由哪个视图渲染结果了，那请求的任务基本上也就完成了。\n它的最后一站是视图的实现，在这里它交付模型数据，请求的任务也就完成了。视图使用模型数据渲染出结果，这个输出结果会通过响应对象传递给客户端。\n\u0026lt;%@ page language=\u0026#34;java\u0026#34; contentType=\u0026#34;text/html; charset=UTF-8\u0026#34; pageEncoding=\u0026#34;UTF-8\u0026#34; isELIgnored=\u0026#34;false\u0026#34;%\u0026gt; \u0026lt;h1\u0026gt;${message}\u0026lt;/h1\u0026gt;  使用注解配置 Spring MVC 上面我们已经对 Spring MVC 有了一定的了解，并且通过 XML 配置的方式创建了第一个 Spring MVC 程序，我们来看看基于注解应该怎么完成上述程序的配置：\n第一步：为 HelloController 添加注解 package controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.servlet.ModelAndView; @Controller public class HelloController{ @RequestMapping(\u0026#34;/hello\u0026#34;) public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception { ModelAndView mav = new ModelAndView(\u0026#34;index.jsp\u0026#34;); mav.addObject(\u0026#34;message\u0026#34;, \u0026#34;Hello Spring MVC\u0026#34;); return mav; } } 把实现的接口也给去掉。\n 简单解释一下： @Controller 注解： 很明显，这个注解是用来声明控制器的，但实际上这个注解对 Spring MVC 本身的影响并不大。（Spring 实战说它仅仅是辅助实现组件扫描，可以用 @Component 注解代替，但我自己尝试了一下并不行，因为上述例子没有配置 JSP 视图解析器我还自己配了一个仍没有成功\u0026hellip;） @RequestMapping 注解： 很显然，这就表示路径 /hello 会映射到该方法上  第二步：取消之前的 XML 注释 在 dispatcher-servlet.xml 文件中，注释掉之前的配置，然后增加一句组件扫描：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!--\u0026lt;bean id=\u0026#34;simpleUrlHandlerMapping\u0026#34;--\u0026gt; \u0026lt;!--class=\u0026#34;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\u0026#34;\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;property name=\u0026#34;mappings\u0026#34;\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;props\u0026gt;--\u0026gt; \u0026lt;!--\u0026amp;lt;!\u0026amp;ndash; /hello 路径的请求交给 id 为 helloController 的控制器处理\u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;prop key=\u0026#34;/hello\u0026#34;\u0026gt;helloController\u0026lt;/prop\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/props\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/property\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/bean\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;bean id=\u0026#34;helloController\u0026#34; class=\u0026#34;controller.HelloController\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt;--\u0026gt; \u0026lt;!-- 扫描controller下的组件 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;controller\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; @RequestMapping 注解细节 如果 @RequestMapping 作用在类上，那么就相当于是给该类所有配置的映射地址前加上了一个地址，例如：\n@Controller @RequestMapping(\u0026#34;/wmyskxz\u0026#34;) public class HelloController { @RequestMapping(\u0026#34;/hello\u0026#34;) public ModelAndView handleRequest(....) throws Exception { .... } }  则访问地址： localhost/wmyskxz/hello   配置视图解析器 还记得我们 Spring MVC 的请求流程吗，视图解析器负责定位视图，它接受一个由 DispaterServlet 传递过来的逻辑视图名来匹配一个特定的视图。\n 需求： 有一些页面我们不希望用户用户直接访问到，例如有重要数据的页面，例如有模型数据支撑的页面。 造成的问题： 我们可以在【web】根目录下放置一个【test.jsp】模拟一个重要数据的页面，我们什么都不用做，重新启动服务器，网页中输入 localhost/test.jsp 就能够直接访问到了，这会造成数据泄露\u0026hellip; 另外我们可以直接输入 localhost/index.jsp 试试，根据我们上面的程序，这会是一个空白的页面，因为并没有获取到 ${message} 参数就直接访问了，这会影响用户体验  解决方案 我们将我们的 JSP 文件配置在【WEB-INF】文件夹中的【page】文件夹下，【WEB-INF】是 Java Web 中默认的安全目录，是不允许用户直接访问的*（也就是你说你通过 localhost/WEB-INF/ 这样的方式是永远访问不到的）*\n但是我们需要将这告诉给视图解析器，我们在 dispatcher-servlet.xml 文件中做如下配置：\n\u0026lt;bean id=\u0026#34;viewResolver\u0026#34; class=\u0026#34;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/page/\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; 这里配置了一个 Spring MVC 内置的一个视图解析器，该解析器是遵循着一种约定：会**在视图名上添加前缀和后缀，进而确定一个 Web 应用中视图资源的物理路径的。**让我们实际来看看效果：\n第一步：修改 HelloController 我们将代码修改一下：\n第二步：配置视图解析器： 按照上述的配置，完成：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!--\u0026lt;bean id=\u0026#34;simpleUrlHandlerMapping\u0026#34;--\u0026gt; \u0026lt;!--class=\u0026#34;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\u0026#34;\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;property name=\u0026#34;mappings\u0026#34;\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;props\u0026gt;--\u0026gt; \u0026lt;!--\u0026amp;lt;!\u0026amp;ndash; /hello 路径的请求交给 id 为 helloController 的控制器处理\u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;prop key=\u0026#34;/hello\u0026#34;\u0026gt;helloController\u0026lt;/prop\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/props\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/property\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/bean\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;bean id=\u0026#34;helloController\u0026#34; class=\u0026#34;controller.HelloController\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt;--\u0026gt; \u0026lt;!-- 扫描controller下的组件 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;controller\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;viewResolver\u0026#34; class=\u0026#34;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/page/\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 第三步：剪贴 index.jsp 文件 在【WEB-INF】文件夹下新建一个【page】文件夹，并将【index.jsp】文件剪贴到里面：\n 原理：  我们传入的逻辑视图名为 index ，再加上 “/WEB-INF/page/” 前缀和 “.jsp” 后缀，就能确定物理视图的路径了，这样我们以后就可以将所有的视图放入【page】文件夹下了！\n **注意：**此时的配置仅是 dispatcher-servlet.xml 下的   控制器接收请求数据 使用控制器接收参数往往是 Spring MVC 开发业务逻辑的第一步，为探索 Spring MVC 的传参方式，为此我们先来创建一个简单的表单用于提交数据：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;%@ page language=\u0026#34;java\u0026#34; contentType=\u0026#34;text/html; charset=UTF-8\u0026#34; pageEncoding=\u0026#34;UTF-8\u0026#34; import=\u0026#34;java.util.*\u0026#34; isELIgnored=\u0026#34;false\u0026#34;%\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Spring MVC 传参方式\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026#34;/param\u0026#34; role=\u0026#34;form\u0026#34;\u0026gt; 用户名：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;userName\u0026#34;\u0026gt;\u0026lt;br/\u0026gt; 密码：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;password\u0026#34;\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提 交\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 丑就丑点儿吧，我们就是来测试一下：\n使用 Servlet 原生 API 实现： 我们很容易知道，表单会提交到 /param 这个目录，我们先来使用 Servlet 原生的 API 来看看能不能获取到数据：\n@RequestMapping(\u0026#34;/param\u0026#34;) public ModelAndView getParam(HttpServletRequest request, HttpServletResponse response) { String userName = request.getParameter(\u0026#34;userName\u0026#34;); String password = request.getParameter(\u0026#34;password\u0026#34;); System.out.println(userName); System.out.println(password); return null; } 测试成功：\n使用同名匹配规则 我们可以把方法定义的形参名字设置成和前台传入参数名一样的方法，来获取到数据（同名匹配规则）：\n@RequestMapping(\u0026#34;/param\u0026#34;) public ModelAndView getParam(String userName, String password) { System.out.println(userName); System.out.println(password); return null; } 测试成功：\n 问题： 这样又会和前台产生很强的耦合，这是我们不希望的 解决： 使用 @RequestParam(\u0026quot;前台参数名\u0026quot;) 来注入：   @RequestParam 注解细节： 该注解有三个变量：value、required、defaultvalue value ：指定 name 属性的名称是什么，value 属性都可以默认不写 required ：是否必须要有该参数，可以设置为【true】或者【false】 defaultvalue ：设置默认值  使用模型传参  要求： 前台参数名字必须和模型中的字段名一样  让我们先来为我们的表单创建一个 User 模型：\npackage pojo; public class User { String userName; String password; /* getter and setter */ } 然后测试仍然成功：\n中文乱码问题  注意： 跟 Servlet 中的一样，该方法只对 POST 方法有效（因为是直接处理的 request）  我们可以通过配置 Spring MVC 字符编码过滤器来完成，在 web.xml 中添加：\n\u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;CharacterEncodingFilter\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.CharacterEncodingFilter\u0026lt;/filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt; \u0026lt;!-- 设置编码格式 --\u0026gt; \u0026lt;param-value\u0026gt;utf-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;CharacterEncodingFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt;  控制器回显数据 通过上面，我们知道了怎么接受请求数据，并能解决 POST 乱码的问题，那么我们怎么回显数据呢？为此我们在【page】下创建一个【test2.jsp】：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;%@ page language=\u0026#34;java\u0026#34; contentType=\u0026#34;text/html; charset=UTF-8\u0026#34; pageEncoding=\u0026#34;UTF-8\u0026#34; import=\u0026#34;java.util.*\u0026#34; isELIgnored=\u0026#34;false\u0026#34; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Spring MVC 数据回显\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;回显数据：${message}\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 使用 Servlet 原生 API 来实现 我们先来测试一下 Servlet 原生的 API 是否能完成这个任务：\n@RequestMapping(\u0026#34;/value\u0026#34;) public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) { request.setAttribute(\u0026#34;message\u0026#34;,\u0026#34;成功！\u0026#34;); return new ModelAndView(\u0026#34;test1\u0026#34;); } 在浏览器地址栏中输入：localhost/value 测试\n使用 Spring MVC 所提供的 ModelAndView 对象 使用 Model 对象 在 Spring MVC 中，我们通常都是使用这样的方式来绑定数据，\n 使用 @ModelAttribute 注解：  @ModelAttribute public void model(Model model) { model.addAttribute(\u0026#34;message\u0026#34;, \u0026#34;注解成功\u0026#34;); } @RequestMapping(\u0026#34;/value\u0026#34;) public String handleRequest() { return \u0026#34;test1\u0026#34;; } 这样写就会在访问控制器方法 handleRequest() 时，会首先调用 model() 方法将 message 添加进页面参数中去，在视图中可以直接调用，但是这样写会导致该控制器所有的方法都会首先调用 model() 方法，但同样的也很方便，因为可以加入各种各样的数据。\n 客户端跳转 前面不管是地址 /hello 跳转到 index.jsp 还是 /test 跳转到 test.jsp，这些都是服务端的跳转，也就是 request.getRequestDispatcher(\u0026quot;地址\u0026quot;).forward(request, response);\n那我们如何进行客户端跳转呢？我们继续在 HelloController 中编写：\n@RequestMapping(\u0026#34;/hello\u0026#34;) public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception { ModelAndView mav = new ModelAndView(\u0026#34;index\u0026#34;); mav.addObject(\u0026#34;message\u0026#34;, \u0026#34;Hello Spring MVC\u0026#34;); return mav; } @RequestMapping(\u0026#34;/jump\u0026#34;) public ModelAndView jump() { ModelAndView mav = new ModelAndView(\u0026#34;redirect:/hello\u0026#34;); return mav; } 我们使用 redirect:/hello 就表示我们要跳转到 /hello 这个路径，我们重启服务器，在地址栏中输入：localhost/jump ，会自动跳转到 /hello 路径下：\n也可以这样用：\n@RequestMapping(\u0026#34;/jump\u0026#34;) public String jump() { return \u0026#34;redirect: ./hello\u0026#34;; }  文件上传 我们先来回顾一下传统的文件上传和下载：这里\n我们再来看一下在 Spring MVC 中如何实现文件的上传和下载\n 注意： 需要先导入 commons-io-1.3.2.jar 和 commons-fileupload-1.2.1.jar 两个包  第一步：配置上传解析器 在 dispatcher-servlet.xml 中新增一句：\n\u0026lt;bean id=\u0026#34;multipartResolver\u0026#34; class=\u0026#34;org.springframework.web.multipart.commons.CommonsMultipartResolver\u0026#34;/\u0026gt; 开启对上传功能的支持\n第二步：编写 JSP 文件名为 upload.jsp，仍创建在【page】下：\n\u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;测试文件上传\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026#34;/upload\u0026#34; method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;picture\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;上 传\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 第三步：编写控制器 在 Package【controller】下新建【UploadController】类：\npackage controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.multipart.MultipartFile; import org.springframework.web.servlet.ModelAndView; @Controller public class UploadController { @RequestMapping(\u0026#34;/upload\u0026#34;) public void upload(@RequestParam(\u0026#34;picture\u0026#34;) MultipartFile picture) throws Exception { System.out.println(picture.getOriginalFilename()); } @RequestMapping(\u0026#34;/test2\u0026#34;) public ModelAndView upload() { return new ModelAndView(\u0026#34;upload\u0026#34;); } } 最后测试\n","date":"2021-05-11T15:29:19+08:00","permalink":"https://example.com/p/springmvc%E6%9B%BF%E6%8D%A2%E4%BC%A0%E7%BB%9Fmvc/","title":"SpringMvc替换传统MVC"},{"content":"EL（Expression Language） JSP表达式语言（EL）使得访问存储在JavaBean中的数据变得非常简单。JSP EL既可以用来创建算术表达式也可以用来创建逻辑表达式。在JSP EL表达式内可以使用整型数，浮点数，字符串，常量true、false，还有null。\n一个简单的语法 ${expr} {expr} 其中，expr指的是表达式。在JSP EL中通用的操作符是 . 和 {} 。这两个操作符允许您通过内嵌的JSP对象访问各种各样的JavaBean属性。\n\u0026lt;jsp:setProperty name=\u0026quot;box\u0026quot; property=\u0026quot;perimeter\u0026quot; name=\u0026quot;box\u0026quot; property=\u0026quot;perimeter\u0026quot; value=\u0026quot;${2*box.width+2*box.height}\u0026quot;/\u0026gt;value=\u0026quot;${2*box.width+2*box.height}\u0026quot;/\u0026gt; 当JSP编译器在属性中见到\u0026quot;${}\u0026ldquo;格式后，它会产生代码来计算这个表达式，并且产生一个替代品来代替表达式的值。\n您也可以在标签的模板文本中使用表达式语言。比如jsp:text标签简单地将其主体中的文本插入到JSP输出中：\n\u0026lt;jsp:text\u0026gt; \u0026lt;h1\u0026gt;Hello JSP!\u0026lt;/h1\u0026gt;\u0026lt;h1\u0026gt;Hello JSP!\u0026lt;/h1\u0026gt; \u0026lt;/jsp:text\u0026gt;\u0026lt;/jsp:text\u0026gt; 现在，在jsp:text标签主体中使用表达式，就像这样：\n\u0026lt;jsp:text\u0026gt; Box Perimeter is: ${2*box.width + 2*box.height} \u0026lt;/jsp:text\u0026gt;\u0026lt;/jsp:text\u0026gt; 在EL表达式中可以使用圆括号来组织子表达式。比如${(1 + 2) * 3}等于9，但是${1 + (2 * 3)} 等于7。\n想要停用对EL表达式的评估的话，需要使用page指令将isELIgnored属性值设为true：\n\u0026lt;%@ page isELIgnored =\u0026quot;true|false\u0026quot; %\u0026gt; 这样，EL表达式就会被忽略。若设为false，则容器将会计算EL表达式。\n EL中的基础操作符 EL表达式支持大部分Java所提供的算术和逻辑操作符：\n   操作符 描述     . 访问一个Bean属性或者一个映射条目   [] 访问一个数组或者链表的元素   ( ) 组织一个子表达式以改变优先级   + 加   - 减或负   * 乘   / or div 除   % or mod 取模   == or eq 测试是否相等   != or ne 测试是否不等   \u0026lt; or lt 测试是否小于   \u0026gt; or gt 测试是否大于   \u0026lt;= or le 测试是否小于等于   \u0026gt;= or ge 测试是否大于等于   \u0026amp;\u0026amp; or and 测试逻辑与   || or or 测试逻辑或   ! or not 测试取反   empty 测试是否空值     JSP EL中的函数 JSP EL允许您在表达式中使用函数。这些函数必须被定义在自定义标签库中。函数的使用语法如下：\n${ns:func(param1, param2, ...)} ns指的是命名空间（namespace），func指的是函数的名称，param1指的是第一个参数，param2指的是第二个参数，以此类推。比如，有函数fn:length，在JSTL库中定义，可以像下面这样来获取一个字符串的长度：\n${fn:length(\u0026quot;Get my length\u0026quot;)} 要使用任何标签库中的函数，您需要将这些库安装在服务器中，然后使用标签在JSP文件中包含这些库。\n JSP EL隐含对象 JSP EL支持下表列出的隐含对象：\n   隐含对象 描述     pageScope page 作用域   requestScope request 作用域   sessionScope session 作用域   applicationScope application 作用域   param Request 对象的参数，字符串   paramValues Request对象的参数，字符串集合   header HTTP 信息头，字符串   headerValues HTTP 信息头，字符串集合   initParam 上下文初始化参数   cookie Cookie值   pageContext 当前页面的pageContext    您可以在表达式中使用这些对象，就像使用变量一样。接下来会给出几个例子来更好的理解这个概念。\n pageContext对象 pageContext对象是JSP中pageContext对象的引用。通过pageContext对象，您可以访问request对象。比如，访问request对象传入的查询字符串，就像这样：\n${pageContext.request.queryString}  Scope对象 pageScope，requestScope，sessionScope，applicationScope变量用来访问存储在各个作用域层次的变量。\n举例来说，如果您需要显式访问在applicationScope层的box变量，可以这样来访问：applicationScope.box。\n param和paramValues对象 param和paramValues对象用来访问参数值，通过使用request.getParameter方法和request.getParameterValues方法。\n举例来说，访问一个名为order的参数，可以这样使用表达式：${param.order}，或者${param[\u0026ldquo;order\u0026rdquo;]}。\n接下来的例子表明了如何访问request中的username参数：\n\u0026lt;%@ page import=\u0026quot;java.io.*,java.util.*\u0026quot; %\u0026gt; \u0026lt;% String title = \u0026quot;Accessing Request Param\u0026quot;; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;\u0026lt;% out.print(title); %\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;center\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;% out.print(title); %\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;/center\u0026gt; \u0026lt;div align=\u0026quot;center\u0026quot;\u0026gt; \u0026lt;p\u0026gt;${param[\u0026quot;username\u0026quot;]}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; param对象返回单一的字符串，而paramValues对象则返回一个字符串数组。\n header和headerValues对象 header和headerValues对象用来访问信息头，通过使用 request.getHeader方法和request.getHeaders方法。\n举例来说，要访问一个名为user-agent的信息头，可以这样使用表达式：${header.user-agent}，或者${header[\u0026ldquo;user-agent\u0026rdquo;]}。\n接下来的例子表明了如何访问user-agent信息头：\n\u0026lt;%@ page import=\u0026quot;java.io.*,java.util.*\u0026quot; %\u0026gt; \u0026lt;% String title = \u0026quot;User Agent Example\u0026quot;;String title = \u0026quot;User Agent Example\u0026quot;; %\u0026gt; \u0026lt;html\u0026gt;\u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;head\u0026gt; \u0026lt;title\u0026gt;\u0026lt;% out.print(title); %\u0026gt;\u0026lt;/title\u0026gt;\u0026lt;title\u0026gt;\u0026lt;% out.print(title); %\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;\u0026lt;body\u0026gt; \u0026lt;center\u0026gt;\u0026lt;center\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;% out.print(title); %\u0026gt;\u0026lt;/h1\u0026gt;\u0026lt;h1\u0026gt;\u0026lt;% out.print(title); %\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;/center\u0026gt;\u0026lt;/center\u0026gt; \u0026lt;div align=\u0026quot;center\u0026quot;\u0026gt;\u0026lt;div align=\u0026quot;center\u0026quot;\u0026gt; \u0026lt;p\u0026gt;${header[\u0026quot;user-agent\u0026quot;]}\u0026lt;/p\u0026gt;\u0026lt;p\u0026gt;${header[\u0026quot;user-agent\u0026quot;]}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;\u0026lt;/html\u0026gt; 运行结果如下：\nheader对象返回单一值，而headerValues则返回一个字符串数组。\nEl函数库 导入标签库:\njsp页面需要引入fn函数声明： \u0026lt;%@ taglib prefix=\u0026quot;fn\u0026quot; uri=\u0026quot;http://java.sun.com/jsp/jstl/functions\u0026quot; %\u0026gt; 一般需要C标签配合使用，同时引入C标签声明： \u0026lt;%@ taglib prefix=\u0026quot;c\u0026quot; uri=\u0026quot;http://java.sun.com/jsp/jstl/core\u0026quot; %\u0026gt; 函数:\nString toUpperCase(String input); //把参数转换为大写 String toLowerCase(String input); //把参数转换为小写 int indexOf(String input,String substring); //从大字符串，输出小字符串的位置 boolean contains(String input,String substring); //查看大字符串中是否包含小字符串 boolean containsIgnoreCase(String input,String substring); //忽略大小写的，是否包含 boolean startsWith(String input,String substring); //是否以小串为前缀 boolean endsWith(String input,String substring); //是否以小串为后缀 String substring(String input,int beginIndex, int endIndex); //截取子串 String substringAfter(String input, String substring); //截取大串中，小串所在位置后面的字符串 String substringBefore(String input, String substring); //获取大串中，小串所在位置前面的字符串 substring escapeXml(String input); //把input\u0026quot;\u0026lt;\u0026quot;、\u0026quot;\u0026gt;\u0026quot;、\u0026quot;\u0026amp;\u0026quot;、\u0026quot;'\u0026quot;、\u0026quot;\u0026quot;\u0026quot;,进行转义 String trim(String input); //去除前后空格 String replace(String input,String substringBefore, String substringAfter); //替换 String[] split(String input,String delimiters); //分割字符串，得到字符串数组 int length(Object obj); //可以获取字符串、数组、各种集合的长度 String join(String array[],String separator); //联合字符串数组 1.确保maven中添加了以下依赖：\n \u0026lt;!-- 添加jstl依赖，使其支持\u0026lt;%@taglib prefix=\u0026quot;c\u0026quot; uri=\u0026quot;http://java.sun.com/jsp/jstl/core\u0026quot; %\u0026gt;jstl语法 --\u0026gt; \u0026lt;!-- jstl标签库相关 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;jstl\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jstl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.apache.taglibs/taglibs-standard-impl --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.taglibs\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;taglibs-standard-jstlel\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; ","date":"2021-05-11T15:29:19+08:00","permalink":"https://example.com/p/%E4%BD%BF%E7%94%A8el%E8%A1%A8%E8%BE%BE%E5%BC%8F/","title":"使用EL表达式"},{"content":"数据库分页   在DAO中提供方法\n  public List\u0026lt;Hero\u0026gt; list(int start, int count) start表示开始的个数，count表示取多少条 比如 list(0, 5) ， 即表示第一页，每页有5条数据 比如 list(5, 5) ， 即表示第二页，每页有5条数据   修改HeroListServlet\n  int start = 0; int count = 5; List\u0026lt;Hero\u0026gt; heros = new HeroDAO().list(start, count);   下一页\nHeroListServlet : 通过参数获取start，如果浏览器没有传递参数，就设置为0。 根据start，计算next. next的值就是start+count. 然后把next传递给listHero.jsp\nlistHero.jsp 在最后面增加一个超链\n\u0026lt;a href=\u0026quot;?start=${next}\u0026quot;\u0026gt;[下一页]\u0026lt;/a\u0026gt;\nstart=${next} 从服务器传递过来的next值\n  上一页\nHeroListServlet: 根据start，计算pre. pre的值就是start-count. 然后把pre传递给listHero.jsp\nlistHero.jsp 在下一页前增加一个超链\n\u0026lt;a href=\u0026quot;?start=${pre}\u0026quot;\u0026gt;[上一页]\u0026lt;/a\u0026gt;\nstart=${pre} 从服务器传递过来的pre值\n  第一页\n只需要修改listHero.jsp即可\n\u0026lt;a href=\u0026quot;?start=0\u0026quot;\u0026gt;[首 页]\u0026lt;/a\u0026gt;\n因为首页的start永远都是0\n  最后一页\nHeroListServlet: 在HeroListServlet中计算last last需要根据总数total和每页有多少条数据count来计算得出。\n同时，还要看total是否能够整除count 假设总数是50，是能够被5整除的，那么最后一页的开始就是45\nif (0 == total % count)\nlast = total - count;\n假设总数是51，不能够被5整除的，那么最后一页的开始就是50\nlast = total - total % count;\n  ​\n**listHero.jsp** 在下一页后增加一个超链 `\u0026lt;a href=\u0026quot;?start=${last}\u0026quot;\u0026gt;[末 页]\u0026lt;/a\u0026gt;` start=${last} 从服务器传递过来的last值   边界处理\n上一页，下一页有一个问题， 如果在第一页点击上一页，就会看不到数据了，因为在第一页的时候，pre=-5,也就导致传递到serlvet的start=-5; 同样的在最后一页的时候，点击下一页，也有类似的问题。\n解决办法是进行边界处理：\npre = pre \u0026lt; 0 ? 0 : pre;\n如果pre是负数了，就使用0\nnext = next \u0026gt; last ? last : next;\n如果next大于last，就使用last\n  ","date":"2021-05-11T15:29:19+08:00","permalink":"https://example.com/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E5%88%86%E9%A1%B5/","title":"数据库数据分页"}]